#!/bin/sh -fu
#
# Portpkg -- Source package manager for Slackware
# Copyright (C) 2003-2007 Thomas Pfaff <topf@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# default configuration
MAINTAIN_ALL=false              # Force maintainer mode
AUTO_MAINTAIN=true              # Run own build scripts in maintainer mode
VERBOSE=false                   # Display more output
DRY_RUN=false                   # Simulate downloads/compilations/installations
INTERACTIVE=true                # Ask for comfirmations
NO_REQS=false                   # Disable dependency handling completely
TEST_REQS=false                 # Do not try to install required dependencies
LAZY_CHECKS=false               # Do not try to upgrade required dependencies
DEBUG=false                     # Display debugging output
USE_ALPHA_CODE=false            # Use unstable features
DOWNLOAD_ONLY=false             # Do not compile
PREPARE_ONLY=false              # Do not install
REINSTALL=false                 # Force installation
REBUILD=false                   # Force compilation
REMAINTAIN=false                # Try to skip compilation
NO_FAKEROOT=false               # Do not use compilation sandbox

ARCH=i486                       # Build architecture
CFLAGS=""                       # Compiler flags (effectless for ARCH=i486)
MY_TAG=`whoami`                 # Tag for user written build scripts
MY_REALNAME=$MY_TAG             # Realname for contributed build scripts
MY_EMAIL=$MY_TAG@`hostname`     # Mail address for contributed build scripts

DIST_VER=`cut -d " " -f 2 /etc/slackware-version | cut -d . -f 1,2`
DIST_TARGET=$DIST_VER

# sensitive default values :)
SYNC="sync.portpkg sync.slackware-bin sync.zz.cleanup"
EXPORT="export.portpkg"
REPORT="report.portpkg"
ADDON=""
#PREFER="local/ patches/"
PREFER="local/"
EXCLUDE="pasture/ testing/ extra/ open/ aaa_elflibs"
USE=""
IGNORE="aaa_elflibs glibc-solibs glibc-i18n glibc-profile glibc-zoneinfo cxxlibs openssl-solibs"
SPEC_PRE11="sgml-tools"
SPEC_PAST11="linuxdoc-tools"
SPEC_PRE12="gtk-doc x11 x11-devel"
SPEC_PAST12="libSM /(^|/)libX/ libcm libdmx libxcb libxkbfile mesa"

# find the ports root and some other locations
PRT_ROOT=`until [ "$(pwd)" = "/" ]; do [ -f .ports_root ] && pwd && break; cd ..; done`
PRT_ROOT=${PRT_ROOT:-`[ "$(whoami)" = "root" ] || echo ~/ports`}
LOG_DIR=${PRT_ROOT:-/var/portpkg}/log
SRC_DIR=${PRT_ROOT:-/usr/src}/dist
PKG_DIR=${PRT_ROOT:-/usr/obj}/pkg
PRT_DIR=${PRT_ROOT:-/usr/ports}
TMP=/tmp

# commands used
ADD_CMD='su -c "upgradepkg --install-new --reinstall $pkg_file"'
ROOT_BUILD_CMD='su -c "$build_cmd"'
NOBODY_BUILD_CMD='su nobody -c "$build_cmd"'
WGET_CMD='wget -c -O $dest.part $try'

# include configuration overlay
[ -f /etc/portpkg/local.conf ] && . /etc/portpkg/local.conf
[ -f ~/.portpkg.conf ] && . ~/.portpkg.conf
[ -f $PRT_DIR/portpkg.conf ] && . $PRT_DIR/portpkg.conf

# don't change this
ADM_DIR=/var/log
INST_DIR=$ADM_DIR/packages
CFG_DIR=/etc/portpkg
PATH=$PATH:/sbin:/usr/local/sbin:/usr/sbin
ENGINE_VER=cvs
ENGINE_REV="\$Revision: 1.11 $"
TMPDIR=`mktemp -d $TMP/portpkg-XXXXXX` || exit 1
export TMPDIR
CACHE=`mktemp -d`

# global variables
package="" name="" group="" path="" script="" description=""
sources="" md5sums="" pkg_file="" replace=""
requires="" optional="" blocks=""
build_msg="" install_msg=""
maintain=$MAINTAIN_ALL
no_fakeroot=$NO_FAKEROOT
rebuild=$REBUILD
tmp=$TMP

# internal variables
output=/dev/null
cwd=`pwd`

# config files
synonyms()  { cache synonyms 'grep -vshe ^# -e ^$ $CFG_DIR/synonyms $PRT_DIR/synonyms' "$@"; }
mirrors()   { cache mirrors 'grep -vshe ^# -e ^$ $CFG_DIR/mirrors $PRT_DIR/mirrors' "$@"; }
virtual()   { cache virtual 'grep -vshe ^# -e ^$ $CFG_DIR/virtual $PRT_DIR/virtual' "$@"; }

# config variables
prefer()    { regex "$PREFER"; }
ignore()    { regex "$IGNORE"; }
exclude()   { regex "$EXCLUDE"; }
use()       { regex "$USE"; }

# listers
ls_virt()   { virtual "$@"; }           # obsolete
ls_loc()    { ls_slk "$@" | slk2loc; }  # obsolete
ls_inst()   { cache inst 'find $INST_DIR/ -type f' "$@"; }
ls_pkg()    { cache pkg 'find $PKG_DIR/ -follow -type f -name "*.tgz" 2>/dev/null' "$@"; }
ls_slk()    { cache slk 'find $PRT_DIR/ -follow -name "CVS" -prune -o -type f -name "*SlackBuild" -print 2>/dev/null' "$@"; }
ls_src()    { cache src 'find $SRC_DIR/ -type f -maxdepth 1 2>/dev/null' "$@"; }

# converters
#any2dir()    { sed -r "s,^(.*)/.*$,\1,"; }
any2dir()   { sed -r "s,/?[^/]*$,,"; }
any2base()  { sed -r "s,^.*/,,"; }
pkg2name()  { sed -r "s,^(.*)-.*-.*-.*$,\1,"; }
pkg2ver()   { sed -r "s,^.*-(.*)-.*-.*$,\1,"; }
pkg2rel()   { sed -r "s,^.*-(.*-.*-.*)$,\1,"; }
any2gany()  { sed -r "s,^($PRT_DIR|$PKG_DIR|$INST_DIR)/,,"; }
slk2gname() { sed -r "s,^(|$PRT_DIR/)(.*)[./]SlackBuild$,\2,"; }
slk2name()  { sed -r "s,^.*/(.*)[./]SlackBuild$,\1,"; }

# message system
log()       { echo -e "$@" | tee -a $LOG_DIR/portpkg.log; }
header()    { log "\n+==============================================================================
| $@
+=============================================================================="; }
stanza()    { log "\n$@"; }
row()       { log "  --> $@"; }
warn()      { log "WARNING: $@" >&2; }
error()     { [ "$*" ] && log "** $@" >&2; return 1; }
die()       { error "$@"; exit 1; }
debug()     { $DEBUG && log "$@" >&2 || log "$@" >/dev/null; }
pause()     { $INTERACTIVE || return 0; log -n "\n* $@ " >&2; local s; read s; log -n $s; }

# checks
has_args()  { [ "$*" ] || error "Too few arguments! Try: portpkg --help"; }
is_root()   { [ "$UID" = "0" ] || error "You must be root to run this action!"; }
has_prog()  { which $1 >/dev/null 2>&1 || error "Cannot find $1!"; }
has_ports() { [ -d "$PRT_DIR" ] || error "No ports found! Change to your ports tree or try: portpkg --sync"; }
is_sane()   { echo "$2  $1" | md5sum -c >$output 2>/dev/null || error "Integrity failed: ${1##*/}!"; }

# simple list handlers
list_add()  { echo "$group/$package" >>$CACHE/list_$1; }
list_del()  { sed -i "\,^$group/$package$,d" $CACHE/list_$1; }
in_list()   { fgrep -sqx "$group/$package" $CACHE/list_$1; }
cache_add() { echo "$2" >>$CACHE/$1; }
cache_del() { sed -i "\,^$2$,d" $CACHE/$1; }
cache_reset() { rm -f $CACHE/$1; }
default()   { sort_ver | head -n 1; }

# magic script list to package list converter
slk2loc() # <file_list >pkg_list
# FIXME: preset $BUILD and $VERSION is not supported, only reset!
{
  xargs -r egrep -sHom 4 "^(VERSION|ARCH|BUILD|TAG)=\"?(\\$\{)?[-=%+:._a-zA-Z0-9]+\}?\"?" \
| sed -r "s,\",,g;/=$/d;s,[\./]SlackBuild:,:,;s,\\$\{ARCH:-[^}]+},$ARCH,g;\
s,\\$\{[A-Z]+(:-|=)([^}]+)},\2,g;s,:VERSION=,:0=,;s,:ARCH=,:1=,;s,:BUILD=,:2=,;s,:TAG=,:3=," \
| sort \
| sed -nr ":loop;s,(=.*)-,\1_,;tloop;/:0=/{s,:0=,-,;x;s,\n,,g;/^$/d;/--/d;p};\
/:[12]=/{s,.*=,-,;H};/:3=/{s,.*=,,;H};\${x;s,\n,,g;/--/d;p}"
}

# sort a pkg-list by version
# TODO: correctly sort "pre", "rc", "alpha", "beta"
sort_ver() # <pkg_list >pkg_list
{
  # 1) add 99999999PREFER_ to version strings of prefered matches
  # 2) separate ver/arch/build, dots and alphanumericals (make "2. 0", "1rc 7", etc.)
  # (but *only* within version-arch-build parts!)
  # 3) sort them and remove added stuff
  local re prefer
  re=`echo $PREFER | tr " " "|"`
  prefer="\,(^|/)($re),s,-([^-]*-[^-]*-[^-]*)$,-99999999PREFER_\1,;"
  sed -r "\
`! $LAZY_CHECKS && [ "$PREFER" ] && echo "$prefer"`\
s,-([^-]*)-([^-]*)-([^-]*)$, - \1 - \2 - \3,;\
:split;s,( .+[^0-9 ])([0-9]),\1 \2,;tsplit" \
| sort -nrk 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 \
| sed -r "s, ,,g;s,-99999999PREFER_,-,"
}

# cache the output of "action" and grep a regex
cache() # id action regex
{
  local id=$1 action=$2
  local filter
  shift 2
  [ "$*" ] && filter="grep -h $@" || filter="cat"
  if ! [ -f $CACHE/$id ]; then
    debug "cache(): filling $id"
    eval "$action" >$CACHE/$id
  fi
  $filter $CACHE/$id
}

# download a file and make use of mirrors
get() # url dest [md5sum]
{
  local url=$1 dest=$2 md5sum=${3:-}
  local urls master mirror try module repo
  debug "get() $@"

  # mirrors
  urls=`mirrors | while read master mirror; do \
case $url in $master*) echo $mirror${url#$master};; esac; done | sort -R`"
$url"

  debug "get(): URLs:" $urls
  $DRY_RUN && return 0
  mkdir -p ${dest%/*}

  # try mirrors in random order
  for try in $urls; do
    debug "get(): trying $try"
    urls=`echo "$urls" | fgrep -vx "$try"`
    case $try in
      cvs://*)
        # cvs://repo/module (top level module) or
        # cvs://repo=module
	has_prog cvs || die
        module=`echo $try | sed "s,^[^=]*[=/],,"`
        repo=`echo $try | sed -r "s,^cvs://(.*).$module$,\1,"`
        if [ -d $dest/CVS ]; then
          ( cd $dest
            # this has already been checked out once
            cvs -qz3 up -dP . || ! [ "$urls" ]
          )
        else
          ( cd ${dest%/*}
            cvs -qz3 -d $repo co -d ${dest##*/} -P $module
          )
        fi || continue
        return 0;;
      svn://*)
        # svn://[http://]repo
	case $try in svn://*://*) try=${try#svn://};; esac
        has_prog svn || die
        if [ -d $dest/.svn ]; then
          ( cd $dest
            # this has already been checked out once
            svn up || ! [ "$urls" ]
          )
        else
          ( cd ${dest%/*}
            svn co $try ${dest##*/}
          )
        fi || continue
        return 0;;
      rsync://*)
        # rsync://url
        has_prog rsync || die
        rsync -avz $try $dest || continue
        return 0;;
      *)
        has_prog wget || die
	eval $WGET_CMD || continue
        if [ "$md5sum" ] && ! is_sane $dest.part $md5sum; then
          mv $dest.part $dest.invalid
          continue
        fi
        mv $dest.part $dest
        return 0;;
    esac
  done

  error "Download failed!"
}

# run a plugin either from PRT_DIR/plugins or CFG_DIR/plugins
plugin() # plugin [args]
{
  local plugin=${1:-}
  shift
  if ! [ "$plugin" ]; then
    # not set, skip quietly
    return 0
  elif [ -f $PRT_DIR/plugins/$plugin ]; then
    . $PRT_DIR/plugins/$plugin "$@"
  elif [ -f $CFG_DIR/plugins/$plugin ]; then
    . $CFG_DIR/plugins/$plugin "$@"
  else
    # not found exit with error
    error "Plugin $plugin not found!"
    return 1
  fi
}

# generate a regular expression for grep from a pkgex-list
regex() # pkgex_list >regex_list
{
  local arg syn
  for arg in ${@:-0}; do
    case $arg in
      0)   # nothing
	   echo "-e ^$";;
      @)   # everything
	   echo "-e .";;
      /*/) # arbitrary regex
	   echo "-Ee ${arg%/}" | cut -c 1-4,6-;;
      .)   # local directory (recursively)
	   echo "-Ee ^($cwd|${cwd#$PRT_DIR/})/";;
      */)  # groups (replace slashes with '/(.*/)?')
           case $arg in */*/) arg=`echo "$arg" | sed "s,/,/(.*/)?,g"`;; esac
           echo "-Ee (^|/)$arg";;
      *)   # (g)names and (g)packages (replace slashes with '/(.*/)?')
           syn=`synonyms -Ee "(^|[[:space:]])${arg##*/}($|[[:space:]])"`
           [ "$syn" ] && case $arg in
             */*) arg="${arg%/*}/(`echo $syn | tr ' ' '|'`)";;
             *)   arg="(`echo $syn | tr ' ' '|'`)";;
           esac
           case $arg in */*) arg=`echo "$arg" | sed "s,/,/(.*/)?,g"`;; esac
           echo "-Ee (^|/)$arg(|[./]SlackBuild|(-[^-/]*){3})$";;
    esac
  # now protect pluses
  done | sed -r "s,\+,\\\+,g"
}

# resolve groups/ to names, and [pkgex[%pkgex[...]]]% to a diff-list
# note: do_list doesn't use explicit()!
explicit() # pkgex_list >pkgex-list
{
  local arg re
  for arg in ${@:-.}; do
    case $arg in
      0|@|*/) re=`regex $arg`
              # also look through virtual groups list
              { ls_slk $re | grep -v `exclude` | slk2gname
                virtual $re | any2base
              } | sort -u;;
      *%)     ls_diff `echo "${arg%\%}" | tr "%" " "` | pkg2name;;
      *)      echo $arg;;
    esac
  done
}

# print non-available, but installed ports
ls_diff() # [pkgex] >list
{
  local t=`mktemp -d`
  local check avail inst
  debug "ls_diff() $@"

  # prepare lists
  { ls_slk `regex ${@:-@}` | slk2loc
    $REINSTALL || ls_inst
  } | grep -v $(exclude) | sort_ver | tee $t/avail.full | any2base >$t/avail
  ls_inst | grep -v $(exclude) | any2base >$t/inst
  pkg2name <$t/avail >$t/avail.names
  pkg2name <$t/inst >$t/inst.names

  # find package names that installed and in the ports
  fgrep -xf $t/avail.names $t/inst.names | while read check; do
    check=`regex $check`
    avail=`grep -m 1 $check $t/avail`
    inst=`grep -m 1 $check $t/inst`
    $LAZY_CHECKS && [ "${avail%-*-*}" = "${inst%-*-*}" ] && continue
    echo $avail >>$t/avail.check
    echo $inst >>$t/inst.check
  done
  touch $t/avail.check $t/inst.check

  # neglect architecture differences for ix86
  sed -i "s,-i.86-,-i.86-," $t/avail.check $t/inst.check

  # find version mismatches therein
  fgrep -vxf $t/inst.check $t/avail.check | sed "s,^,.*/," | grep -xf - $t/avail.full | sort -u
}

ls_verbose() # <pkgex
{
  local pkg avail_rel inst_rel name
  printf "\n%-31s %-23s %s\n" "PACKAGE NAME:" "AVAILABLE:" "INSTALLED:"
  while read pkg; do
    avail_rel=`echo $pkg | pkg2rel`
    name=${pkg%-*-*-*}
    inst_rel=`ls_inst $(regex ${name##*/}) | pkg2rel | head -n 1`
    avail_rel=${avail_rel:-(n/a)}
    printf "%-31s %-23s %s\n" "${name##*/}" "$avail_rel" "${inst_rel:--}"
  done
}

# adjust PRT_DIR in case the pkgex "." is used
check_indirect() # pkgex
{
  [ "${1:-}" = "." ] || return
  # yes, all relative to current dir, thus no pkgex resolution
  debug "check_indirect(): indirect mode: disabling dependencies resolution"
  TEST_REQS=true
  debug "check_indirect(): restricting slk cache to `pwd`"
  PRT_DIR=`pwd` ls_slk >/dev/null
  case `pwd` in $PRT_DIR|$PRT_DIR/*) ;; * )
    # pkgex "." is used but the current dir is not inside the tree
    debug "check_indirect(): `pwd` is NOT in PRT_DIR, setting it now"
    PRT_DIR=`pwd`
    PKG_DIR=$PRT_DIR
    SRC_DIR=$PRT_DIR
    LOG_DIR=$PRT_DIR
  esac
}

find_pkg_file()
{
  local f
  f=`ls_pkg "^$PKG_DIR/$group/$package\.tgz$"`
  [ "$f" ] || f=`ls_pkg "/$package\.tgz$"`
  [ "$f" ] || f=`ls_src "/$package\.tgz$"`
  echo "$f" | head -n 1
}

# get information about a port and write it into global variables
get_info() # pkgex
{
  local loc arch build re srcver rel nre
  local decode='sed "s,[{}],,g;s,\$NAME,$name,g;s,\$VERSION,$srcver,g;s,\$ARCH,$arch,g;s,\$BUILD,$build,g;s,\$PRGNAM,$name,g;s,\$TAG,,g"'
  debug "get_info() $@"

  # find port, take the first if more than one available
  check_indirect "$@"
  re=`regex $1`
  loc=`ls_slk $re | grep -v $(exclude) | slk2loc`
  loc=${loc:-`ls_slk $re | slk2loc`}
  if ! [ "$loc" ]; then
    # still nothing? ok, probably (deprecated) name-version-arch-build expression
    loc=`ls_slk $(regex ${1%-*-*-*}) | slk2loc | grep $re`
  fi
  loc=`echo "$loc" | default`

  if ! [ "$loc" ]; then
    error "No such port: $1"
    return 1
  fi

  debug "get_info(): $1 is $loc"

  # set global variables
  group=${loc%/*}
  group=${group#$PRT_DIR/}
  package=${loc##*/}
  name=${package%-*-*-*}

  # clear group if PRT_DIR is the script dir, as group is expected to be inside PRT_DIR
  [ "$group/$name" = "$PRT_DIR" ] && group=""

  rel=${package#$name-}
  version=${rel%%-*}
  arch=${rel#*-}
  arch=${arch%-*}
  build=${rel##*-}
  script=`find ${loc%-*-*-*}.SlackBuild ${loc%-*-*-*}/SlackBuild 2>/dev/null | head -n 1`
  srcver=`sed -n "/^VERSION=/s,^.*=,,p" $script`
  path=${script%/*}
#  description=`grep -she ^$name: -e "^\\$NAME:" $path/slack-desc ${script%SlackBuild}slack-desc $script | eval $decode`
  description=`grep -she ^$name: -e "^\\$NAME:" ${script%?SlackBuild}/slack-desc ${script%?SlackBuild}.slack-desc $script | eval $decode`
  nre=`regex $name`
  requires=`{ \
sed -nr "/^# REQUIRES:/{s,.*: ,,;s, ,\n,g;p}" $script; \
sed -nr "/^[^#][^|]*$/{s, .*,,;s, ,\n,g;p}" $path/requires $path/slack-required 2>/dev/null; \
} | sort -u | grep -v $nre`
  optional=`{ \
sed -nr "/^# OPTIONAL:/{s,.*: ,,;s, ,\n,g;p}" $script; \
sed -nr "/^[^#][^|]*$/{s, .*,,;s, ,\n,g;p}" $path/optional $path/slack-suggests 2>/dev/null; \
sed -nr "/^# opt/{s,.* ,,;s, ,\n,g;p}" $path/requires 2>/dev/null; \
} | sort -u | grep -v $nre`
  blocks=`{ \
sed -nr "/^# BLOCKS:/{s,.*: ,,;s, ,\n,g;p}" $script; \
sed -nr "/^[^#][^|]*$/{s, .*,,;s, ,\n,g;p}" $path/blocks $path/slack-conflicts 2>/dev/null; \
sed -nr "/^# block/{s,.* ,,;s, ,\n,g;p}" $path/requires 2>/dev/null; \
} | sort -u | grep -v $nre`
  sources=`{ \
sed -nr "/^# SOURCES:/{s,.*: ,,;s, ,\n,g;p}" $script; \
sed -nr "/^[^#]/p" $path/sources 2>/dev/null; } | eval $decode
sed -nr "/^DOWNLOAD=/s,^.*=,,p" $path/$name.info 2>/dev/null`
  md5sums=`\
sed -nr "/^# MD5SUMS:/s,.*: ,,p" $script; \
sed -nr "/^[^#]/p" $path/md5sums 2>/dev/null; \
sed -nr "/^MD5SUM=/s,^.*=,,p" $path/$name.info 2>/dev/null`
  replace=`ls_inst -m 1 $nre | any2base`
  pkg_file=`find_pkg_file`

  # flags
  maintain=$MAINTAIN_ALL
  $AUTO_MAINTAIN && case $package in *[0-9]${MY_TAG:-NULL}) maintain=true;; esac
  no_fakeroot=$NO_FAKEROOT
  rebuild=$REBUILD
  [ -f $path/no-fakeroot ] && no_fakeroot=true
  [ -f $path/rebuild ] && rebuild=true
  fgrep -sqx no-fakeroot $path/flags && no_fakeroot=true
  fgrep -sqx rebuild $path/flags && rebuild=true
  grep -sq "^# FLAGS:.* no-fakeroot\( \|$\)" $script && no_fakeroot=true
  grep -sq "^# FLAGS:.* rebuild\( \|$\)" $script && rebuild=true

  # check $TMP
  tmp=$TMP
  if ! grep -sq "^TMP=\${TMP:-" $script; then
    tmp=/tmp
    $DOWNLOAD_ONLY || debug "get_info(): assuming script uses TMP=$tmp"
  fi

  # prepare the action message
  if [ "$replace" = "$package" ]; then
    build_msg="Rebuilding $package"
    install_msg="Reinstalling $package"
  elif [ "$replace" ]; then
    build_msg="Building $package to replace $replace"
    install_msg="Replacing $replace with $package"
  else
    build_msg="Building $package"
    install_msg="Installing $package"
  fi

  return 0
}

# check if all required packages are installed
check_reqs()
{
  local prev req inst_pkg avail_pkg use_pkg list re ex us opt missing check
  debug "check_reqs(): starting for $package"
  $NO_REQS && return 0
  $LAZY_CHECKS && debug "check_reqs(): doing lazy checks"
  $TEST_REQS && debug "check_reqs(): testing dependencies for presence only"
  missing=""
  opt=false
  ex=$(exclude)
  us=$(use)

  check=`echo -e "$requires\n--\n$optional" | grep -v $(ignore)`
  debug "check_reqs(): checking dependencies for $package:" $check
  for req in $check; do
    [ "$req" = "--" ] && opt=true && continue
    re=`regex $req`
    inst_pkg=`ls_inst $re | head -n 1 | any2base`
    avail_pkg=`$TEST_REQS || { \
ls_slk $re | grep -v $ex | slk2loc; \
echo $inst_pkg; } | default`
    use_pkg=`ls_slk $re | grep $us | slk2loc | default`

    # is any version installed?
    if [ "$inst_pkg" ] && ( $LAZY_CHECKS || $TEST_REQS ); then
      debug "check_reqs(): $name: $req: sufficient [$inst_pkg]"
    # is it up-to-date?
    elif [ "${avail_pkg##*/}" = "${inst_pkg:-0}" ]; then
      debug "check_reqs(): $name: $req: match [$inst_pkg]"
    # is it blacklistet?
    elif echo "${avail_pkg:-0}" | grep -sq $ex; then
      debug "check_reqs(): $name: $req: blacklisted [$avail_pkg]"
    # is it optional?
    elif $opt && ! [ "$use_pkg" ]; then
      debug "check_reqs(): $name: $req: optional"
    # anyway, is there an available port?
    elif [ "${avail_pkg:-$use_pkg}" ]; then
      avail_pkg=${avail_pkg:-$use_pkg}
      debug "check_reqs(): $name: $req: mismatch [${inst_pkg:-not installed}]"
      # if there's already one missing go straight on to the next
      [ "$missing" ] && continue
      $DRY_RUN && ! [ "${prev:-}" ] && ! $DOWNLOAD_ONLY && stanza "Preparing dependencies of $package:"
      prev=$name
      ( if $DRY_RUN; then
          stanza() { :; }
          header() { :; }
        fi
#        get_info ${avail_pkg%-*-*-*} || exit 1
        get_info $avail_pkg || die
        add_pkg || die "${avail_pkg##*/} failed! Stopping $prev."
        $DRY_RUN && ! $DOWNLOAD_ONLY && ! $PREPARE_ONLY && row "$install_msg"
        exit 0
      ) || return 1
      pkg_file=`find_pkg_file`
    # is it blacklistet?
    elif echo "$avail_pkg" | grep -sqv $(exclude) && [ "$avail_pkg" ]; then
      debug "check_reqs(): $name: $req: blacklisted [$avail_pkg]"
    elif ! [ "$inst_pkg" ]; then
      debug "check_reqs(): $name: $req: missing"
      missing="$missing $req"
    fi
  done
  if [ "$missing" ]; then
    error "Cannot find required packages:" $missing
    return 1
  fi
  return 0
}

check_opts()
{
  local opt all_opts
  $DOWNLOAD_ONLY && return 0
  for opt in `echo "$optional" | grep -v $(ignore)`; do
    ls_inst -q `regex $opt` || all_opts="$all_opts $opt"
  done
  [ "$all_opts" ] && warn "Optional dependencies to consider:" $all_opts
  return 0
}

check_blocks()
{
  local block
  $NO_REQS && return 0
  for block in $blocks; do
    if ls_inst -q `regex $block`; then
      # we have a blocking package installed, exit!
      error "$block is blocking $name. Please uninstall first!"
      return 1
    fi
  done
}

# update a SlackBuilds header to current variables
update_header()
{
  local t=`mktemp -d`
  local i

  row "Updating script header of ${script#$PRT_DIR/}"

  # generate new header
  { echo "#!/bin/sh"
    { grep "^# MAINTAINER:" $script
      echo "# MAINTAINER: $MY_REALNAME '$MY_TAG' <$MY_EMAIL>"
    } | sort -u
    echo "$sources" | xargs -l echo "# SOURCES:"
    echo "$md5sums" | xargs -l echo "# MD5SUMS:"
    echo "$requires" | xargs -s 75 echo "# REQUIRES:"
    echo "$optional" | xargs -s 75 echo "# OPTIONAL:"
    echo "$blocks" | xargs -s 75 echo "# BLOCKS:"
  } | sed "/^# .*: *$/d" >$t/header

  # clear old script header
  sed "/^#!\/bin\/sh/d" $script >$t/script
  for i in MAINTAINER BLOCKS OPTIONAL REQUIRES MD5SUMS SOURCES; do
    sed -i "/^# $i:/d" $t/script
  done
  cat $t/header $t/script >$script
}

dependencies_of() # dir
{
  local t=`mktemp -d`
  local s
  ( cd $1/; find -type f ) | sed "s,^\./,,;s,\.so\..*,.so," >$t/flist
  find $1/ -type f | xargs file >$t/ftypes

  # find depdendencies, but exclude dependencies of them
  d_deps() { xargs ldd 2>/dev/null | sed -nr "s,.* => /(.+\.so)\..*$,\1,p"; }
  find $1/ | d_deps | fgrep -vf $t/flist >$t/deps
  find $INST_DIR/ | xargs fgrep -whf $t/deps | ( cd /; d_deps ) >$t/deps_deps
  fgrep -vxf $t/deps_deps $t/deps

  # find perl dependencies (modules are identified by their man pages)
  grep -ie ":.*perl" -e "\.pm:" $t/ftypes | cut -d : -f 1 \
  | xargs sed -n "s,^\ *use *\([A-Z][a-z][^';<> ]*\).*,\1,p" \
  | xargs -i echo "usr/man/man3/{}.3"

  # find python dependencies
  grep -e ":.*python" -e "\.py:" $t/ftypes | cut -d : -f 1 \
  | xargs fgrep -h "import " \
  | sed -r "s,^ *,,;s,from (.*) import .*$,\1,g;s, as .*$,,;s,\"[^\"]*\",,g;s,.*import ,,g" \
  | sort -u | while read s; do
    ( cd $INST_DIR/; find | xargs grep -h "/$s\.py$" | grep -v "/site-packages/..*/$s\.py$" )
  done | sort -u

  # find mono dependencies
  if which mono-find-requires >/dev/null 2>&1; then
    grep -e ":.*MS Windows" -e "\.exe:" $t/ftypes | cut -d : -f 1 \
    | mono-find-requires \
    | sed -nr "s,^mono\((.*)\) = (.*)$,.*/lib/mono/.*/\1/\2__,p"
  fi

  # fix misc dependencies
  { grep -sq "^etc/gconf/" $t/flist && which gconftool-2
    grep -sq "\.desktop$" $t/flist && which update-desktop-database
    grep -sq "^etc/dbus-1/" $t/flist && which dbus-daemon
    grep -sq "\.omf$" $t/flist && which scrollkeeper-config
    grep -sq "/gtk-doc/" $t/flist && which gtkdoc-scan
    grep -sq "/share/mime/.*\.xml$" $t/flist && which update-mime-database
  } 2>/dev/null | sed "s,^/,,"
}

# update header, footprint, dependencies
maintainer_mode()
{
  local t=`mktemp -d`
  $maintain || return 0

  # explodepkg package tree?
  if ! [ -d $tmp/package-$name ]; then
    # if *this* is a file we cannot remove, we must fail
    rm -f $tmp/package-$name || die
    mkdir $tmp/package-$name
    tar xzf $tmp/$package.tgz -C $tmp/package-$name/
  fi

  # generate requires list
  echo -n "$requires" >$t/old_req
  echo -n "$optional" >$t/old_opt

  dependencies_of $tmp/package-$name | sort -u >$t/depfiles

  # resolve dependent files to package names
  sed "s,^,^," $t/depfiles | ( cd $INST_DIR/; find -exec grep -lf - {} + ) \
  | sed "s,^\./,," | pkg2name | fgrep -vx "$name" | sort -u >$t/auto_req_raw
  debug "maintainer_mode(): auto reqs: "`cat $t/auto_req_raw`

  # find and strip ignore list
  ls_inst $(ignore) | any2base | pkg2name | fgrep -vxf - $t/auto_req_raw >$t/auto_req

  # strip old lists to see what's new
  fgrep -vxf $t/old_req -f $t/old_opt $t/auto_req >$t/new_req

  # if there's alread a "requires" file, add new dependencies as optional
  if [ "$requires" ]; then
    optional=`{ echo "$optional"; cat $t/new_req; } | sort -u`
  else
    requires=`{ echo "$requires"; cat $t/new_req; } | sort -u`
  fi

  update_header

  # show a few statistics and check for common mistakes
  [ -s $t/new_req ] && row "New dependencies:" `cat $t/new_req`
  fgrep -hxvf $t/auto_req $t/new_req $t/old_req >$t/arb_req
  [ -s $t/arb_req ] && row "Arbitrary dependencies (KEEP THIS LIST SHORT):" `cat $t/arb_req`
  grep -e "-upgraded$" $t/auto_req >$t/check_req
#  ls_slk -v $(exclude) | slk2name | fgrep -vxf - $t/auto_req >>$t/check_req
  ls_inst -v $(exclude) | any2gany | pkg2name | fgrep -vxf - $t/auto_req >>$t/check_req
  [ -s $t/check_req ] && warn "Check these dependencies:" `cat $t/check_req`

  # remove obsolete files
  rm -f arbitrary requires blocks optional slot-in pseudo no-fakeroot flags md5sums sources

  # write a file list of the package (remove creation time and size)
  { printf "PACKAGE SIZE (compressed):   %6s K\n" $((`cat $pkg_file | wc -c`/1024))
    printf "PACKAGE SIZE (uncompressed): %6s K\n" $((`zcat $pkg_file | wc -c`/1024))
    echo "REMOTE SOURCES:  `echo "$sources" | sed "s,^.*[%/],$SRC_DIR/," | xargs du | tail -n 1 | cut -f 1` K"
    echo "$sources" | sed "s,%.*$,,"
    echo "FILE LIST:"
  } >${script%SlackBuild}footprint
  tar tzvf $tmp/$package.tgz | xargs -l | cut -d " " -f 1,2,6- | sort -k 3 | column -t >>${script%SlackBuild}footprint
}

# build package
build_pkg()
{
  local t=`mktemp -d`
  local src srcname dest md5sum script_opt flags_var sh_opt prod build_cmd products

  # requirements check
  check_reqs || return 1
  check_opts || return 1
  check_blocks || return 1

  # package file found in cache?
  if [ "$pkg_file" ] && ! $rebuild; then
    $DOWNLOAD_ONLY && row "$package.tgz found in ${pkg_file%/*}/" && return 0
    check_pkg || return 1
#    ( $DOWNLOAD_ONLY || $PREPARE_ONLY ) && stanza "Already built. Skipping."
#    $DOWNLOAD_ONLY && row "$package.tgz found in ${pkg_file%/*}/" && return 0
    $PREPARE_ONLY && stanza "$package already built. Skipping."
    return 0
  fi

  if $maintain && ! $DOWNLOAD_ONLY; then
    warn "Maintainer mode: Script header will be modified!"
    if $rebuild && echo "$replace" | grep -sqx $package; then
      debug "build_pkg(): rebuilding installed package $package"
    fi
  else
    script_opt="--cleanup"
  fi

  # warnings concerning fakeroot
  if ( $no_fakeroot || ! has_prog fakeroot 2>/dev/null ); then
    if [ "$name" != "fakeroot" ]; then
      $no_fakeroot && warn "Fakeroot disabled for this port!" \
      || warn "Please install fakeroot as soon as possible!"
      $PREPARE_ONLY && warn "Preparing without fakeroot is not a good idea!"
    fi
    # must be verbose for 'su'
    VERBOSE=true
    output=/dev/stdout
  fi

  case `pause "Continue: $build_msg? (s to skip)"` in s|S) continue;; esac
  
  $DOWNLOAD_ONLY || header "Processing $group/$name"
  $DOWNLOAD_ONLY || stanza "$build_msg:"

  cd ${script%/*} || return 1

  # download the source files
  for src in $sources; do
    # if the source is a cgi- or php-script, the file name can be
    # saved with a different name via "URI%name"
    srcname=`basename "${src#*%}"`
    src="${src%\%*}"
    md5sum=`echo "$md5sums" | grep -s " $srcname$" | cut -d " " -f 1`
    dest=$SRC_DIR/$srcname
    if ls_src -q "/$srcname$" && [ -f $dest ]; then
      # srcname is there and is a file: skip it
      $DRY_RUN || row "$srcname found in $SRC_DIR/"
    elif [ "${pkg_file##*/}" = "$srcname" ]; then
      # it's the package itself (pseudo port): skip it
      $DRY_RUN || row "$srcname found in ${pkg_file%/*}/"
      dest=$pkg_file
    else
      # no, it's a directory, so assume it's either CVS or SVN: update it
      row "Downloading $srcname"
      get $src $dest $md5sum || return 1
      cache_add src $dest
    fi
    if ! $DRY_RUN; then
      ln -sf $dest .
      # check md5sums when non-maintainer-mode
      if $maintain && ls_src -q "/$srcname$"; then
        md5sums=`{ echo "$md5sums"; md5sum $srcname; } | xargs -l | sort -u -k 2`
      elif ! [ "$md5sum" ]; then
        warn "No checksums available for $srcname!"
      fi
    fi
  done

  # exit when download-only or dry-run
  $DOWNLOAD_ONLY && return 0
  $DRY_RUN && row "Executing ${script#$PRT_DIR/} $script_opt"
  $DRY_RUN && return 0

  # build package
  if ! $REMAINTAIN; then
    [ -d $tmp/package-$name ] && rm -rf $tmp/package-$name
    rm -f $tmp/$package.tgz

    # find CFLAGS substitution (CFLAGS="$SLKCFLAGS")
    flags_var=`grep -o 'CFLAGS=\"\$[^ ]*' $script | cut -d = -f 2 | tail -n 1 | sed "s,[\"\$],,g"`
    if [ "$flags_var" ]; then
      debug "build_pkg(): using $flags_var for CFLAGS"
    else
      case $package in $name-$version-noarch-*) ;; *)
        $maintain && warn "No CFLAGS variable found! Compiling with default values";;
      esac
      flags_var=CFLAGS
    fi

    # check if the script wants to handle errors on its on ("|| exit 1")
    if grep -sq "^[^#].*|| exit" $script; then
      sh_opt="-x"
    else
      sh_opt="-e -x"
    fi

    # execute SlackBuild
    mkdir -p $LOG_DIR
    date >$LOG_DIR/$name.buildlog
    # set OUTPUT=$tmp here just in case it's a slackbuilds.org type sctipt
    build_cmd="ARCH=$ARCH $flags_var=\"$CFLAGS\" TMP=$tmp OUTPUT=$tmp"
    if ! $no_fakeroot && has_prog fakeroot; then
      # run fakerooted SlackBuild
      row "Executing (fakerooted) ${script#$PRT_DIR/} $script_opt"
      build_cmd="$build_cmd fakeroot sh $sh_opt $script $script_opt"
      if [ "`whoami`" = "root" ]; then
        row "Dropping privileges, becoming nobody"
	build_cmd="HOME=$tmp TMPDIR=$tmp $build_cmd"
	eval "echo \"# $NOBODY_BUILD_CMD\"" >>$LOG_DIR/$name.buildlog
	eval $NOBODY_BUILD_CMD 2>&1 | tee -a $LOG_DIR/$name.buildlog >$output
      else
	echo "$ $build_cmd" >>$LOG_DIR/$name.buildlog
	eval $build_cmd 2>&1 | tee -a $LOG_DIR/$name.buildlog >$output
      fi
    else
      row "Executing ${script#$PRT_DIR/} $script_opt"
      build_cmd="$build_cmd sh $sh_opt $script $script_opt"
      if [ "`whoami`" != "root" ]; then
        row "Gaining root privileges"
        # chown package and package-tree to `whoami`, so we can work with it
        build_cmd="$build_cmd; chown -R `whoami` $tmp/$package.tgz $tmp/package-$name 2>/dev/null"
	eval "echo \"$ $ROOT_BUILD_CMD\"" >>$LOG_DIR/$name.buildlog
	eval $ROOT_BUILD_CMD 2>&1 | tee -a $LOG_DIR/$name.buildlog >$output
      else
	echo "# $build_cmd" >>$LOG_DIR/$name.buildlog
	eval $build_cmd 2>&1 | tee -a $LOG_DIR/$name.buildlog >$output
      fi
    fi

    # find produced packages names
    products=`sed -nr "s,^\+ [^#]*makepkg ?.* (.*\.tgz).*,\1,p" $LOG_DIR/$name.buildlog`
    products=`echo "$products" | sed "s,^\.\./,$tmp/,g"`
    products=${products:-$tmp/$package.tgz}

    # shrink buildlogs
    gzip -f $LOG_DIR/$name.buildlog

    # success? (this is the most promising test to ensure it worked)
    if ! [ -f `echo "$products" | head -n 1` ]; then
      $VERBOSE || gunzip -c $LOG_DIR/$name.buildlog.gz | tail
      error "Compilation failed (see $LOG_DIR/$name.buildlog.gz)!"
      $maintain && ln -sf $LOG_DIR/$name.buildlog.gz PORT_IS_BROKEN
      # query the reporting plugin
      ( plugin $REPORT $LOG_DIR/$name.buildlog.gz )
      return 1
    else
      # remove this tag in any case
      rm -f PORT_IS_BROKEN
      # add package to the cache
      cache_add pkg $PKG_DIR/$group/$package
    fi
  else
    if ! [ "$pkg_file" ]; then
      error "Remaintaining not possible: No package file found!"
      return 1
    fi
    row "Skipping package building"
    cp $pkg_file $tmp/
    products=$tmp/$package.tgz
  fi

  # cruft for maintainers of port scripts :)
  maintainer_mode #| tee -a $LOG_DIR/$name.buildlog

  # clean up
  mkdir -p $PKG_DIR/$group
  for prod in $products; do
    row "Moving ${prod##*/} to $PKG_DIR/$group/"
    mv $prod $PKG_DIR/$group/
    cache_add pkg $PKG_DIR/$group/${prod##*/}
  done
  pkg_file=$PKG_DIR/$group/$package.tgz

  row "Cleaning up"
  for src in $sources; do
    srcname=`basename "$src" | cut -d % -f 2`
    # remove symlinks to sources
    [ -L ${script%/*}/$srcname ] && rm -f ${script%/*}/$srcname
  done

  if [ -d $tmp/package-$name ]; then
    $maintain && row "$tmp/package-$name kept for maintaining purposes" \
    || rm -rf $tmp/package-$name
  fi

  row "Checking package layout"
  check_pkg || return 1
}

# do some basic checks on the current package
check_pkg()
{
  local t=`mktemp -d`
  local s
  debug "check_pkg(): $package"
  $DRY_RUN && return 0
  [ -f $pkg_file ] || return 0

  # prepare a file list
  tar tzvf $pkg_file | xargs -l | cut -d " " -f 1,2,6- >$t/footprint

  # check for common mistakes
  egrep -oe " usr/(local/|etc/|share/pkgconfig/|share/doc/|share/man/|info/dir).*" \
    -e " etc/gconf/gconf\.xml\..*" -e " tmp/.*" -e ".*/$ARCH-slackware-linux-.*" $t/footprint \
  | while read s; do warn "Unusual entries:" /$s; done
  egrep -e "^........w" -e " usr/doc/" -e "^.......... +[0-9]+/" -e "^.......... +[^ ]+/[0-9]+ " $t/footprint \
  | egrep -v "^.rw.r-.r-. +root/root +usr/doc/" \
  | while read s; do warn "Unusual flags:" $s; done
  # check for files that interfere with other packages
  sed "s,.* ,," $t/footprint | grep -ve /$ -e ^install/ \
  | ( cd $INST_DIR; find -exec fgrep -xf - {} + ) | grep -v "^\./$replace:" \
  | sed -r "s,^\./(.*)-.*-.*-.*:(.*)$,/\2 interferes with \1," | while read s; do warn $s; done

  # warn about tags
  case $package in *[0-9]) case $sources in ftp://ftp.slackware.com/*) ;; *)
    error "No packager tag although not from slackware.com!"
    return 1;;
  esac;; esac

  # list .new files
  grep -wo "etc/.*\.new$" $t/footprint | while read s; do
    [ -f /${s%.new} ] && warn "Consider updating /${s%.new} with ${s##*/}!"
  done

  # for now, all this is tolerable
  return 0
}

# really (re)install/upgrade current port
add_pkg()
{
  if in_list canceled; then
    debug "add_pkg() $name has already been canceled, skipping"
    return 0
  elif in_list started; then
    error "Circular dependency! Stopping $name."
    return 1
  # otherwise if tracked as "finished" (because of a dependency), skip it
  elif in_list finished; then
    return 0
  elif ls_inst -q "/$package$" && ! $REINSTALL && ! $rebuild; then
    $DOWNLOAD_ONLY && row "$package is already installed, skipping" \
    || stanza "$package is already installed. Skipping."
    return 0
  else
  # else track it as "started"
    list_add started
  fi

  list_add canceled
  # package file found in cache? (first in its group, then other places)
  build_pkg || return 1
  list_del canceled

  # track as "finished", remove from "started" list
  list_add finished
  list_del started

#  # don't get confused in download-only mode
#  if $DOWNLOAD_ONLY; then
#    cache_add inst $INST_DIR/$package
#    cache_del inst $INST_DIR/$replace
#  fi

  # break-points
  $DOWNLOAD_ONLY && return 0
  $PREPARE_ONLY && return 0

  # what to display?
  list_add canceled
  case `pause "Continue: $install_msg? (s to skip)"` in s|S) continue;; esac
  list_del canceled

  ( cd ${pkg_file%/*}
    pkg_file=${pkg_file##*/}
    [ "$replace" ] && pkg_file="$replace%$pkg_file"
    debug "add_pkg(): $ADD_CMD"
    $DRY_RUN && stanza "$install_msg..."

    # wait while another install process is running
    while pgrep -xu root "upgradepkg|installpkg" >/dev/null; do sleep 1; done

    $DRY_RUN || eval $ADD_CMD
  ) || error "Installation failed!"

  # update install list cache
  cache_del inst $INST_DIR/$replace
  cache_add inst $INST_DIR/$package
}

# prepare and install ports
do_add() # pkgex-list
{
  local arg ret targets

  targets=`explicit "$@"`

  if [ "$targets" = "." ]; then
    check_indirect "$targets"
    targets=`ls_slk "$@" | slk2name`
  fi
  
  [ "$targets" ] || die "No targets given or found!"

  # add targets to USE scope
  USE="${USE:+$USE }$@"
  
  # if we have implicit expressions here (groups), tell what they contain
  if [ `echo "$targets" | wc -l` != `echo "${@:-.}" | wc -w` ]; then
    warn "You are using an implicit expression. Use with caution!"
    if ! $NO_REQS && ! $TEST_REQS; then
      warn "Exact results are NOT COMPLETELY predictable. \
Try --dryrun first and consider using --noreqs and/or --ignore!"
    fi
    
    stanza "Targets: "`echo "$targets" | sed "s,.*/,,"`
  fi

  $DOWNLOAD_ONLY && stanza "Downloading files:"
  
  # clean all lists
  rm -f $CACHE/list_canceled $CACHE/list_started $CACHE/list_finished

  for arg in $targets; do
    ret=1
    get_info $arg || continue
    add_pkg
    ret=$?
  done

  return $ret
}

do_diff() # [pkgex]
{
  local diff_list

  has_ports || die
  diff_list=`ls_diff "$@"`
  [ "$diff_list" ] || die "No differences found."

  echo "$diff_list" | ls_verbose
}

do_export()
{
  [ "$EXPORT" ] || die "Run pp-config to define export method first!"

  stanza "Exporting:"

  ( plugin $EXPORT "$@" )
}

# find ports by pattern
do_find() # text [..] >list
{
  local t=`mktemp -d`
  local arg s

  has_args "$@" || die
  has_ports || die
  find $PRT_DIR/ -name "*slack-desc" -o -name "*SlackBuild" >$t/list 2>/dev/null
  for arg; do
    xargs grep -lsi "^[^ ]*: .*$arg" >$t/list.new <$t/list
    mv $t/list.new $t/list
  done
  [ -s $t/list ] || die "No search results found."
  xargs grep -Hm 1 "^[^ ]*: " <$t/list | cut -d : -f 2- | sort -u
}

# print information about a port
do_info() # pkgex-list
{
  local arg ret
  has_ports || die
  
  for arg in `explicit "$@"`; do
    ret=1
    get_info $arg || continue
    ret=0
    echo -e "\nPACKAGE NAME:       $package"
    [ "$replace" ] && echo "INSTALLED VERSION:  "$replace | fmt -t
    if [ "$pkg_file" ]; then
      printf "PACKAGE SIZE (compressed):    %6s K\n" $((`cat $pkg_file | wc -c`/1024))
      printf "PACKAGE SIZE (uncompressed):  %6s K\n" $((`zcat $pkg_file | wc -c`/1024))
      echo "PACKAGE LOCATION:   ${pkg_file%/*}/" | fmt -t
    fi
    echo "SCRIPT LOCATION:    ${script%/*}/" | fmt -t
    [ "$requires" ] && echo "PACKAGE REQUIRES:   "$requires | fmt -t
    [ "$optional" ] && echo "PACKAGE SUGGESTS:   "$optional | fmt -t
    [ "$blocks" ] && echo "PACKAGE BLOCKS:     "$optional | fmt -t
    [ "$sources" ] && echo "SOURCE LOCATIONS:   "$sources | fmt -t
    [ "$description" ] && echo -e "PACKAGE DESCRIPTION:\n$description"
  done

  return $ret
}

# list available ports
do_list() # [pkgex-list] >glist
{
  local virt
  check_indirect "$@"
  has_ports || die
  case $* in
    "") ls_slk;;
    *)  # grep arguments (in order to see virtual groups we list them here also)
        virt=`virtual $(regex "$@") | any2base`
	  ls_slk `regex "$@" $virt`
        ;;
  esac | slk2loc | sort_ver | any2gany \
  | { $VERBOSE && ls_verbose || cat -; }
}

do_sync()
{
  local importer

  [ "$SYNC" ] || die "Run pp-config to define what to sync!"
  stanza "Updating ports:"

  for importer in $SYNC; do
    ( plugin $importer "$@" )
  done
}

# upgrade all installed ports that are not available
do_upgrade() # [pkgex-list]
{
  local diff_list
  has_ports || die
  do_add `echo "$@" | tr " " "%"`%
}

help()
{
  cat <<EOF

Usage: portpkg [action] [options] [expression [..]]
  Prepare and install a package (default action).

Actions (alternative):
  -d, --diff         Compare installed versions with availables
  -i, --info         View information about specified ports
  -f, --find strs    Find ports by pattern strings
  -l, --list         List available ports
  -s, --sync         Update ports
  -u, --upgrade      Upgrade all (!) outdated ports (see --diff)
  -v, --version	     View version information
  -x, --export msg   Upload ports to portpkg.berlios.de
  -h, --help         Display this page
EOF

  $VERBOSE && cat <<EOF

Options:
  -e, --reinstall    Reinstall package if already installed
  -b, --rebuild      Rebuild package if already build (implies --reinstall)
  -p, --prepare      Build package, but don't install (implies --testreqs)
  -o, --download     Download source files only
  -g, --verbose      Show compile/download output, more help
  -z, --debug        Show debugging messages
  -y, --dryrun       Simulate (implies --noask)
  -q, --noreqs       Don't handle dependencies at all
  -c, --testreqs     Just exit on missing dependencies
  -a, --lazy         Don't upgrade dependencies to newest version
  -m, --maintain     Force maintainer mode
  -r, --remaintain   Skip build script (implies --rebuild and --prepare)
  -n, --noask        Do not ask for confirmations
  -w, --exclude expr Exclude from implicit expressions (single expression!)
  -j, --ignore expr  Ignore these dependencies (single expression!)
  -t, --use expr     Use these optional dependencies (single expression!)
EOF

  cat <<EOF

Expressions:
  [group/]name or    'foobar', 'l/foobar'
  group/ or          'l/', 'local/apps/'
  /regex/ or         '/ooba/'
  [.]                Use current directory
EOF

  $VERBOSE || stanza "(Use --verbose for more help)"
}

version()
{
  cat <<EOF | fmt -t
    
Portpkg version $ENGINE_VER ($ENGINE_REV).
Copyright (C) 2003-2007 Thomas Pfaff <topf@users.berlios.de>.
Portpkg comes with ABSOLUTELY NO WARRANTY. This is free software, and you are welcome to redistribute it under certain conditions.
EOF

  $VERBOSE || stanza "(Use --verbose for more information)"

  $VERBOSE || return 0
  cat <<EOF | fmt -t

PRT_DIR:  $PRT_DIR
SRC_DIR:  $SRC_DIR
PKG_DIR:  $PKG_DIR
LOG_DIR:  $LOG_DIR

EXCLUDE:  $EXCLUDE
IGNORE:   $IGNORE
PREFER:   $PREFER
USE:      $USE

ARCH:         $ARCH
CFLAGS:       $CFLAGS
DIST_VER:     $DIST_VER
DIST_TARGET:  $DIST_TARGET
EOF
}

parse_options()
{
  local shorts longs args start_args action

  action=do_add
  shorts="diflsuvhebogyqxzarpmnw:t:j:c"
  longs="diff,info,find,list,sync,upgrade,version,help,reinstall,\
rebuild,download,verbose,dryrun,noreqs,debug,lazy,remaintain,prepare,\
maintain,export,noask,ignore:,use:,exclude:,testreqs"

  args=`getopt -qo $shorts -l $longs -- "$@"`
  [ "$?" = "0" ] || die "Bad Arguments! Try: portpkg --help"
  start_args="$@"
  eval set -- "$args"

  while [ "$1" ]; do
    case $1 in
      -d|--diff)        action=do_diff;;
      -i|--info)      	action=do_info;;
      -f|--find)        action=do_find;;
      -l|--list)      	action=do_list;;
      -s|--sync)        action=do_sync;;
      -u|--upgrade)     action=do_upgrade;;
      -v|--version)     action=version;;
      -x|--export)      action=do_export;;
      -h|--help)      	action=help;;
      -e|--reinstall)   REINSTALL=true;;
      -b|--rebuild)     REBUILD=true;;
      -o|--download)    DOWNLOAD_ONLY=true;;
      -g|--verbose)   	VERBOSE=true;;
      -y|--dryrun)      DRY_RUN=true;;
      -q|--noreqs)      NO_REQS=true;;
      -c|--testreqs)    TEST_REQS=true;;
      -z|--debug)       DEBUG=true;;
      -a|--lazy)        LAZY_CHECKS=true;;
      -r|--remaintain)  REMAINTAIN=true;;
      -p|--prepare)     PREPARE_ONLY=true;;
      -m|--maintain)    MAINTAIN_ALL=true;;
      -n|--noask)       INTERACTIVE=false;;
      -j|--ignore)      IGNORE="$IGNORE $2"
                        shift;;
      -w|--exclude)     EXCLUDE="$EXCLUDE $2"
			USE=`echo "$USE" | sed -r "s,(^| )$2($| ), ," | xargs`
			shift;;
      -t|--use)		USE="$USE $2"
			EXCLUDE=`echo "$EXCLUDE" | sed -r "s,(^| )$2($| ), ," | xargs`
			shift;;
      --)               shift
                        break;;
    esac
    shift
  done

  $REMAINTAIN && PREPARE_ONLY=true && REBUILD=true
  $PREPARE_ONLY && TEST_REQS=true
  $REBUILD && REINSTALL=true
  $DRY_RUN && INTERACTIVE=false
  $DOWNLOAD_ONLY && INTERACTIVE=false
  $VERBOSE && output=/dev/stdout

  debug "parse_options() $start_args"
  debug "$action() $@"

  $NO_REQS && debug "parse_options(): dependency resolving disabled"
  $LAZY_CHECKS && debug "parse_options(): enabled lazy version checking"
  $DRY_RUN && debug "parse_options(): up-/downloading, packaging and installing simulated"

  $action "$@"
}

destroy()
{
  rm -rf $TMPDIR
  log "`date`" >/dev/null
}

init()
{
  local plugin

  # reset locales
  export LANG=C
  export LANGUAGE=C
  export LC_ALL=C
  export LC_COLLATE=C
  export LC_CTYPE=C
  export LC_MESSAGES=C
  export LC_NUMERIC=C
  export LC_TIME=C

  # make/check temporary directory
  [ "$TMP" ] || die "TMP is emtpy!"
  [ "$TMP" = "/" ] && die "TMP cannot be /!"
  [ -d "$TMP" ] || die "Internal error!"
  [ -d "$LOG_DIR" ] || mkdir -p $LOG_DIR

  # start log entry
  log "+--------------------------+" >/dev/null
  log "`date`" >/dev/null
  log "Portpkg version $ENGINE_VER ($ENGINE_REV)" >/dev/null
  log "`whoami`@`hostname`:`pwd`$ $0 $@" >/dev/null

  # clean up on exit
  trap 'error "ctrl-c pressed"; exit 1' INT
  trap 'destroy' EXIT

  # we need special dependencies for specific Slackware version
  case $DIST_VER in
    [89].*|10.*) IGNORE="$SPEC_PAST11 $SPEC_PAST12 $IGNORE";;
    11.0)        IGNORE="$SPEC_PRE11 $SPEC_PAST12 $IGNORE";;
    *)           IGNORE="$SPEC_PRE11 $SPEC_PRE12 $IGNORE";;
  esac
if $USE_ALPHA_CODE; then
  case $DIST_TARGET in
    current) EXCLUDE="slackware-$DIST_VER/ $EXCLUDE";;
    *)       EXCLUDE="slackware-current/ $EXCLUDE";;
  esac
fi
  case $ARCH in
    i?86)    EXCLUDE="/-(x86_64|s390|powerpc)-[^-]*$/ $EXCLUDE";;
    x86_64)  EXCLUDE="/-(i.86|s390|powerpc)-[^-]*$/ $EXCLUDE";;
    s390)    EXCLUDE="/-(i.86|x86_64|powerpc)-[^-]*$/ $EXCLUDE";;
    powerpc) EXCLUDE="/-(i.86|x86_64|s390)-[^-]*$/ $EXCLUDE";;
    *-*)     die "ARCH value not allowed: $ARCH";;
    "")      die "ARCH is empty";;
  esac
  [ "`whoami`" = "root" ] && warn "You are root! Please run portpkg as unprivileged user!"

  # addon-plugins
  for plugin in $ADDON; do
    plugin $plugin
  done

  # if not used as include file then start me
  case ${0##*/} in
    portpkg)
      parse_options "$@";;
    pp_*)
      # call single function
      eval ${0##*/pp_} "$@";;
    -bash|ash)
      # seems we're running in a shell, don't quit it
      die() { error "$@"; }
      trap 'error "ctrl-c pressed"' INT;;
  esac

#  return 0
}

init "$@"
