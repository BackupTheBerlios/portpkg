<html>
<body>

<div class="wiki view PortpkgGuide">
<div class="text-head">
<h2 class="text-title page title"><a href="doc.php?page=links/PortpkgGuide">PortpkgGuide</a></h2>
</div>
<div class="text-body">

<p>This page addresses the how and why of the administration tool <tt>portpkg</tt> and its inner work and development... It will soon. :-)
</p>

<h2>1. File system</h2>
<table cellpadding="2" border="1" cellspacing="0">
<tr>
<td><tt>/usr/ports</tt></td>
<td>Ports tree copy</td>
</tr><tr>
<td><tt>/usr/src/dist</tt></td>
<td>Downloaded source packages</td>
</tr><tr>
<td><tt>/usr/obj/pkg</tt></td>
<td>Stored binary packages</td>
</tr>
</table>


<p>Planning:
</p>

<table cellpadding="2" border="1" cellspacing="0">
<tr>
<td><tt>/usr/src/cvs</tt></td>
<td>CVS-repositories</td>
</tr>
</table>


<p><em>Tipp: Damit alle Abhängikeiten automatisch aufgelöst werden können, kann man alle .tgz-Pakete, die man sich vom Slackware-Mirror heruntergeladen hat nach <tt>/usr/obj/pkg</tt> kopieren oder man benutzt das in Portpkg mitgelieferte Skript <tt>sync-dist</tt>, das sogenannte Pseudo-Ports erstellt, die wiederum nichts anderes machen, als Slackware-Pakete bei Bedarf von einem Slackware-Mirror herunterzuladen.</em>
</p>


<p><hr noshade="noshade" />
</p>

<h2>2. Ports Tree</h2>

<p>Der Portsbaum ist analog dem Paketverzeichnis von Slackware selbst. Die erste Ebende unter <tt>/usr/ports</tt> sind die Gruppen:
</p>

<table cellpadding="2" border="1" cellspacing="0">
<tr>
<td><tt>ap/</tt></td>
<td>Anwendungen</td>
</tr><tr>
<td><tt>d/</tt></td>
<td>Entwicklungswerkzeuge</td>
</tr><tr>
<td><tt>gnome/</tt></td>
<td>Anwendungen, die auf GNOME aufbauen</td>
</tr><tr>
<td><tt>kde/</tt></td>
<td>Anwendungen, die auf KDE aufbauen</td>
</tr><tr>
<td><tt>l/</tt></td>
<td>Bibliotheken</td>
</tr><tr>
<td><tt>n/</tt></td>
<td>Netzwerkserver, und -clients</td>
</tr><tr>
<td><tt>x/</tt></td>
<td>X-Server und dessen Treiber</td>
</tr><tr>
<td><tt>xap/</tt></td>
<td>X-Anwendungen</td>
</tr><tr>
<td><tt>pasture/</tt></td>
<td>Pakete, die nur aus Kompatibilitätsgründen noch dabei sind</td>
</tr><tr>
<td><tt>testing/</tt></td>
<td>Alles, was noch nicht stabil ist</td>
</tr>
</table>


<p><em>Findige Slacker werden hier sicherlich bemerkt haben, dass die Gruppen <tt>testing/</tt> und <tt>pasture/</tt> eigentlich auf Slackware eine Ebene höher liegen. Dies steht natürlich noch zur Diskussion :)</em>
</p>


<p>In zweiter Ebene stehen die Ports, von denen jeder nur in einer Gruppe sein kann. Für jeden Port gibt es ein Verzeichnis, in dem die Skripte aufbewahrt werden:
</p>





<pre class="markup pre">/usr/ports/
|-- a/
|   `-- slmodem/
|-- ap/
|   |-- abook/
|   |-- athcool/
|   |-- bonnie++/
|   |-- cabextract/
|   |-- cpudyn/
|   |-- exiftags/
|   `-- exifutils/
|-- d/
|   |-- fakeroot/
|   |-- lua/
|   |-- mono/
|   |-- portpkg/
|   |-- ruby/
|   `-- tla/
|-- gnome/
|   |-- aegis-virus-scanner/
|   |-- at-spi/
|   |-- balsa/
(...)
</pre>




<p>Die Dateien, die grundsätzlich in einem Port vorhanden sein können und besondere Bedeutung haben:
</p>

<table cellpadding="2" border="1" cellspacing="0">
<tr>
<td><tt>PORT_IS_BROKEN</tt></td>
<td>Markiert, dass die letzte Kompilation fehlschlug</td>
<td><sup>2</sup>, <sup>3</sup></td>
</tr><tr>
<td><tt>SlackBuild</tt></td>
<td>Bashskript zum erstellen des Pakets</td>
<td><sup>1</sup></td>
</tr><tr>
<td><tt>arbitrary</tt></td>
<td>Abhängigkeiten, die nicht automatisch bestätigt werden konnten</td>
<td><sup>2</sup>, <sup>3</sup></td>
</tr><tr>
<td><tt>buildlog</tt></td>
<td>Log-Datei des SlackBuilds</td>
<td><sup>2</sup>, <sup>3</sup></td>
</tr><tr>
<td><tt>diff</tt></td>
<td>Differenz zum Grund-SlackBuild</td>
<td><sup>2</sup>, <sup>3</sup></td>
</tr><tr>
<td><tt>doinst.sh</tt></td>
<td>Bashskript das von <tt>installpkg</tt> ausgeführt wird</td>
<td>(<sup>1</sup>)</td>
</tr><tr>
<td><tt>footprint</tt></td>
<td>Dateiliste des Pakets</td>
<td><sup>2</sup>, <sup>3</sup></td>
</tr><tr>
<td><tt>pseudo</tt></td>
<td>Markiert einen Pseudoport</td>
<td>(<sup>1</sup>)</td>
</tr><tr>
<td><tt>requires</tt></td>
<td>Liste der Abhängigkeiten</td>
<td>(<sup>1</sup>), <sup>2</sup></td>
</tr><tr>
<td><tt>slack-desc</tt></td>
<td>Beschreibung des Ports/Pakets</td>
<td>(<sup>1</sup>)</td>
</tr><tr>
<td><tt>slot-in</tt></td>
<td>Weisst <tt>portpkg</tt> an, kein Upgrade, sondern eine normale Installation durchzuführen</td>
<td>(<sup>1</sup>)</td>
</tr><tr>
<td><tt>sources</tt></td>
<td>Liste der Quellpakete</td>
<td>(<sup>1</sup>)</td>
</tr>
</table>


<p><em>Hinweise: <sup>1</sup> muss (kann) vorhanden sein, <sup>2</sup> wird von portpkg nachträglich erstellt, <sup>3</sup> nur zur Kontrolle für den Maintainer, wird nicht veröffentlicht.</em>
</p>


<p><hr noshade="noshade" />
</p>

<h2>3. Work process</h2>

<p>Portpkg durchsucht den Portsbaum nach Dateien, die *.SlackBuild oder SlackBuild heißen. Aus diesen wird die Versionsinformation ausgelesen. All das wird zu einer Liste von verfügbaren Paketen zusammengestellt, die mit <tt>portpkg --list</tt> angezeigt werden kann. Wenn mit <tt>portpkg grip</tt> der Port "grip" aufgerufen wird, so geht Portpkg zuerst diese Liste durch und sucht den <strong>ersten zutreffenden</strong> Port und dessen Verzeichnis (in diesem Falle <tt>/usr/ports/xap/grip</tt>, dabei wird natürlich auch sichergestellt, dass z.B. die Suchmaske "nautilus" nicht auf "nautilus-cd-burner" zutrifft), danach geht es eine Checkliste durch:
</p>


  <ol>
  <li> Ist genau diese verfügbare Version schon installiert?</li>
  <li> Ist ein fertiges Paket schon in <tt>/usr/obj/pkg</tt>?</li>
  <li> Ist das Quellpaket schon in <tt>/usr/src/dist</tt>?  </li>
  </ol>


<p>Erst jetzt wird das SlackBuild aufgerufen, dann bei erfolgreicher Kompilation installiert und nach <tt>/usr/obj/pkg</tt> verschoben.
</p>


<p><hr noshade="noshade" />
</p>

<h2>4. Dealing with Ports</h2>

<p>Portpkg übernimmt einige Aufgaben, die das Erstellen von Ports erleichtern, sowohl wenn man "Maintainer" eines Ports ist (d.h. das der in der Datei <tt>/usr/ports/maintain</tt> stehende Tag in der Zeile <tt>MY_TAG</tt>= mit dem Tag des jeweiligen Ports übereinstimmt), als auch für das bauen und installieren von Ports an sich:
</p>


  <ul type="circle">
  <li> Download der erforderlichen Quelldateien (siehe Datei <tt>sources</tt>)</li>
  <li> Automatisches Überprüfen und Ergänzen (im Maintainermodus) von Abhängigkeiten (siehe Datei <tt>requires</tt>)</li>
  <li> Sammeln der Quelldateien und Pakte in speziellen Verzeichnissen (<tt>/usr/src/dist</tt> und <tt>/usr/obj/pkg</tt>)</li>
  <li> Erstellen von diversen Dateien (siehe oben), die dem Maintainer helfen, zu überprüfen, ob das Paket richtig gebaut wurde.  </li>
  </ul>


<p><hr noshade="noshade" />
</p>

<h2>5. Theory</h2>

<p><em>"What is exactly the difference between the ports in Portpkg and the "ports" in Slackware?"</em>
</p>


<p>Slackware doesn't call that ports! It's just the source code of Slackware.
</p>


<p>The most obvious difference seems to be the file <tt>source</tt>: While Slackware stores every source package in the same directory, Portpkg just gives a list of URLs, where to get them. The effect is the same, because they have to be downloaded anyway.
</p>


<p>Moreover the SlackBuilds in Portpkg are a little more consequential in declarations (each SlackBuild has to have the lines VERSION=, ARCH= and BUILD= and its values in plain text) and more consequential in implementation (each port has one SlackBuild, each SlackBuild makes one binary package). Have a look at the .build-scripts, the X11-SlackBuild and the KDE-scipts to see what I mean. This behaviour may change in future to make Portpkg more compatible with the Slackware sources.
</p>


<p>Portpkg ist so konzipiert, dass das Portsarchiv auch ohne <tt>portpkg</tt> benutzt werden kann (sogenannter Handbetrieb :). Um einen Port ohne Zuhilfenahme von <tt>portpkg</tt> zu bauen, würde man ungefähr folgendermaßen vorgehen:
</p>





<pre class="markup pre">
# cd /usr/ports/ap/dbus
# cat sources | sed "s#\$VERSION#1.2.3#" | wget -i -
(...)
# sh ./SlackBuild
(...)
# installpkg /tmp/dbus-*.tgz
(...)
</pre>




<p>Portpkg listet die Ports "on-the-fly". D.h. eine VERSION-Änderung in einer SlackBuild-Datei ist sofort verfügbar und muss nicht erst übersetzt werden.
</p>


<p>Portpkg soll analog zu <tt>installpkg</tt> funktionieren, die Kommandozeilensyntax und -ausgabe sind weitgehend ähnlich.
</p>



</div>
<div class="wiki-plugins">

<div align="right" class="action-links control-links">
<br />
<hr noshade="noshade" />
  <a href="doc.php?page=edit/PortpkgGuide">EditThisPage</a>   <a href="doc.php?page=links/PortpkgGuide">BackLinks</a>   <a href="doc.php?page=info/PortpkgGuide">PageInfo</a>   <small>last changed on Wed Dec 08 15:17:09 2004</small></div>
</div>

</div>

</body>
</html>
