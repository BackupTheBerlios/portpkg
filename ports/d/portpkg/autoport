#!/bin/sh
#
# Autoport -- An Automatic SlackBuild Generator
# Copyright (C) 2004, 2005 Thomas Pfaff <topf@users.berlios.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

source `which portpkg` || exit 1
t=`mktemp -d`

ask()
{
#  $i_act || return
  echo
  echo -n "$@ "
  s=""
  $i_act && read s || echo
}

check()
{
  local pattern=$1
  shift
  local desc=`echo $pattern | sed "s,[\^\$],,g"`
  if egrep -qe "$pattern" "$@" 2>/dev/null; then
    row "Checking for $desc... yes"
    return 0
  else
    row "Checking for $desc... no"
    return 1
  fi
}

snip()
{
  # the #!tag ... #!tag method
  sed -i "/^#\!$1$/,/^#\!$1$/d" $2
  # the xxx ##tag method
  sed -i "/ *##$1$/d" $2
}

encode()
{
  local ver=`echo $version | sed "s,\.,\.,g"`
  local enc=`echo "$@" | sed -e "s,$name,\\$NAME,g" -e "s,$ver,\\$VERSION,g"`
  local test
  local NAME=$name
  local VERSION=$version
  eval test="$enc"
  # try ${NAME} and ${VERSION}
  [ "$test" != "$@" ] && enc=`echo "$@" | sed -e "s,$name,\\${NAME},g" -e "s,$ver,\\${VERSION},g"`
  echo "$enc"
}

decode()
{
#  local dec=`echo "$@" | sed -e "s,\\$NAME,$name,g" -e "s,\\$VERSION,$version,g"`
  local NAME=$name
  local VERSION=$version
  eval echo "$@"
}

stanza "Autoport -- An Automatic SlackBuild Generator
Copyright (C) 2004, 2005 Thomas Pfaff <topf at users dot berlios dot de>
Autoport comes with ABSOLUTELY NO WARRANTY. This is free software, and you
are welcome to redistribute it under certain conditions.

Autoport is quite experimental, but seems to work better than 'addport'. The
difference is, autoport will download the source code package you have to
enter and searches for different keywords to adjust a suitable SlackBuild
script.

If autoport doesn't work as expected, please mail at:
<topf at users dot berlios dot de>"

# defaults
i_act=true
sources=""
name=""
group=""
arch=$ARCH
build=""
build_pkg=false

# parse options
if [ "$*" ]; then
  while [ "$1" ]; do
    case $1 in
      -a)
        i_act=false
        shift;;
      -v)
        version=$2
        shift
        shift;;
      -g)
        group=`echo $2 | cut -d / -f 1`
        shift
        shift;;
      -n)
        name=`echo $2 | cut -d / -f 1`
        shift
        shift;;
      -u)
        [ "$group" ] && get_info $group/$name || get_info $name
        # use abstract url
        sources=`encode $sources`
        shift;;
      -b)
        build_pkg=true
        shift;;
      *://*)
        sources=$1
        shift;;
      *)
        # usage
        stanza "Usage: autoport [-a] [-n name] [-u] [-v version] [-g group] [-b] [source url]
Options:
  -a             Run non-interactive (use defaults)
  -n name        Preset name of port
  -u             Update (try to read-in existing settings, use after -n)
  -v version     Preset version of port
  -g group       Preset group of port
  -b             Execute portpkg after port generation
  source url     Preset URL of source code (if not found via -u)"
        exit 1;;
    esac
  done
fi

#[ "$sources" ] || die "No source url specified! Try: autoport --help"
[ "$group" ] || group=local

ask "* First step: Collect information. Continue? (ctrl-c to quit)"

# first: do we have tags?
[ "$MY_TAG" ] || die "No tag set. Please run 'pp-config'!"

# input information
ask "Source file URL [$sources]:"
sources=${s:-$sources}
[ "$sources" ] || die "Nothing entered. Eh? I can't help you this way!"
sources=`echo "$sources" | sed -e "s,://prdownloads\.,://dl.," -e "s,\?download$,,"`
## set source_out before user can input a different version
#[ "$version" ] && [ "$name" ] && source_out=`encode "$sources"`
# name: guess it, if we haven't yet it
file=`basename $(decode $sources)`
raw_name=`echo $file | rev | cut -d - -f 2- | rev`
[ "$name" ] || name=`echo $raw_name | tr "A-Z" "a-z"`
ask "Name [$name]:"
name=${s:-$name}
# group
ask "Group [$group]:"
group=${s:-$group}
if ! [ "$version" ]; then
  # version: should be always guessed
  version=`echo $file | rev | cut -d - -f 1 | rev`
  version=`basename $version .tar.gz`
  version=`basename $version .tar.bz2`
  version=`basename $version .tgz`
fi
ask "Version [$version]:"
version=${s:-$version}
srcver=$version
version=`echo $version | sed "s,-,,g"`
## set source_out before user can input a different version
#[ "$version" ] && 
[ "$source_out" ] || source_out=`encode "$sources"`
# arch
ask "Arch [$arch]:"
arch=${s:-$arch}
# build: check if we need to increase it
n=1
gpkg=`ls_slk | slk2loc | loc2gpkg | grep -m 1 "^$group/$name-$version-$arch-[0-9]*$MY_TAG$"`
if [ $gpkg ]; then
  echo "There is already $gpkg."
  # find it
  while [ "$group/$name-$version-$arch-$n$MY_TAG" != $gpkg ]; do
    ((n++))
    [ "$n" == "1000" ] && die "Strange: Cannot find build number!"
  done
  # now that we found it, we can find a bigger number too!
  ((n++))
fi
ask "Build [$n$MY_TAG]:"
build=${s:-$n$MY_TAG}
# desc
if [ "$description" ]; then
  desc1=`echo "$description" | sed "s,^$name:[ ]*,," | head -n 1`
  desc2=`echo "$description" | sed "s,^$name:[ ]*,," | sed "1,2d"`
else
  desc1=$raw_name
fi
ask "Description (1-liner) [$desc1]:"
desc1=${s:-$desc1}
stanza "Description (details) (Write or paste and finish with a single '.')"
echo "[$desc2]"
s=""
if $i_act; then
  while [ "$l" != "." ]; do
    read l
    s="$s
$l"
  done
  s=`echo "$s" | sed -e "1d" -e "/^\.$/d"`
fi
desc2=${s:-$desc2}
# combine $desc1 and $desc2
if [ "$desc2" ]; then
  len=${#name}
  desc=`echo "$name: $desc1"
  echo "$name:"
  echo "$desc2" | fmt -u -w $((75-len)) | sed "s,^,$name: ,"
  echo "$name:"`
else
  desc="$name: $desc1"
fi
echo
echo "Creating now a port with this information:"
echo
echo "PACKAGE NAME:  $name-$version-$arch-$build"
echo "SCRIPT LOCATION:  $PRT_DIR/$group/$name/SlackBuild"
echo "SOURCE LOCATION:  $source_out"
echo "PACKAGE DESCRIPTION:"
echo "$desc"

ask "* Last chance to quit. Port scripts will now be written.
* Next step: Downloading and checking source code. Continue? (ctrl-c to quit)"

# now we should redecode the actual source name
sources=`decode $source_out`

path=$PRT_DIR/$group/$name
script=$path/SlackBuild
old_script=""
if [ -f $path/stop.autoport ]; then
  stanza "There's a warning not to autoport this source code:"
  echo "==========================================="
  more $path/stop.autoport
  echo "==========================================="
  ask "Really continue? (ctrl-c to quit)"
fi
if [ -d $path ]; then
  ask "* This port already exists. Really go on? (ctrl-c to quit)"
  old_script=`find $path/ -name "*SlackBuild" | head -n 1`
#  mv ${old_script}{,.old}
#  [ -f $path/doinst.sh ] && mv $path/doinst{.sh,.old}
fi

# write skeletons
failed=false
mkdir -p $path
cat $0 | sed '/^#\!SlackBuild.skel$/,/^#\!SlackBuild.skel$/!d' >$script
echo "$source_out" >$path/sources
echo "$desc" >$path/slack-desc
sed -i "s,%version%,$version," $script
sed -i "s,%build%,$build," $script

# downlaod source file
file=`basename $sources`
if [ -f $SRC_DIR/$file ]; then
  stanza "$file found in $SRC_DIR/."
else
  stanza "Downloading source file:"
  VERBOSE=true
  output=/dev/stdout
  get $sources $SRC_DIR/$file || die
fi

# checking
stanza "Alright, since we have the code, I'll have a look into it:"

# format
echo -n "  --> Checking format... "
mkdir -p $t/src
case $file in
  *.tar.bz2)
    format=tarbz2
    tar xjf $SRC_DIR/$file -C $t/src/ || die "Error while unpacking, maybe wrong URL?"
    tar tjf $SRC_DIR/$file >$t/footprint
    echo ".tar.bz2"
    sed -i "s,%tarmode%,j," $script
    snip rpm $script;;
  *tar.gz|*.tgz) # yes, there was one file called "xxxtar.gz"!
    format=targz
    tar xzf $SRC_DIR/$file -C $t/src/ || die "Error while unpacking, maybe wrong URL?"
    tar tzf $SRC_DIR/$file >$t/footprint
    echo ".tar.gz"
    sed -i "s,%tarmode%,z," $script
    snip rpm $script;;
  *.src.rpm)
    format=srpm
    ( cd $t/
      rm -rf `basename $file .rpm`.tar.gz
      cp $SRC_DIR/$file .
      rpm2targz $file
      tar xzf `basename $file .rpm`.tar.gz
      tar xzf `basename $file .src.rpm`/$name-$version.tar.gz -C $t/src/
      tar tzf `basename $file .src.rpm`/$name-$version.tar.gz >$t/footprint ) \
    || die "Error while unpacking, maybe wrong URL?"
    echo ".src.rpm"
    snip tar $script;;
  *)
    echo "unknown!"
    die "Unknown source format, please write SlackBuild by hand!";;
esac
tarball=`encode "$file"`
sed -i "s,%tarball%,$tarball," $script

# source-prefix
echo -n "  --> Checking source-prefix... "
srcdir_prefix=`cat $t/footprint | sed "s,^\./,," | cut -d / -f 1 | sort -u`
if [ `echo "$srcdir_prefix" | wc -l` == 1 ] && [ "$srcdir_prefix" != "." ]; then
  echo "$srcdir_prefix/"
  if [ "$format" == "srpm" ]; then
#    # srpms are different :)
#    snip cd_sdp $script
    :
  else
    snip extra_sdp $script
  fi
  srcdir_prefix_out=`encode "$srcdir_prefix"`
  sed -i "s,%srcdirprefix%,$srcdir_prefix_out," $script
else
  echo "no prefix"
  snip cd_sdp $script
  srcdir_prefix="."
fi

# docs
docs=`egrep "/ABOUT$|/ABOUT-NLS$|/ANNOUNCE$|/AUTHORS$|/CONFIGURATION$|/CHANGES$\
|/COPYING$|/COPYRIGHT$|/CREDITS$|/ChangeLog$|/Changelog$|/CHANGELOG$\
|/CONTRIBUTORS$|FAQ|/FEATURES$|/FILES$|/HACKING$|/History$|/HISTORY$|/INSTALL\
|/LICENSE$|/LSM$|/MANIFEST$|/NEWS$|README|Readme|/SITES$|RELEASE|/RELNOTES$\
|/THANKS$|/TIPS$|/TODO$|/VERSION$|/CONFIGURATION|/GPL$|/License$|/Doc$|/doc$\
|/Docs|/docs|/Roadmap$|/ROADMAP$|BUGS|/index.ht|INDEX" $t/footprint \
| sed "s,^$srcdir_prefix/,," | grep -v / | sort -u | xargs`
if [ "$docs" ]; then
  row "Checking docs... $docs."
  sed -i "s,%docs%,$docs," $script
else
  row "Checking docs... none."
  snip docs $script
fi
sed -i "s,^$srcdir_prefix/,," $t/footprint

use_inst_destdir=false
use_fix_man=false
use_no_mk=false
# configure/make
if check "^Makefile.PL$" $t/footprint; then
  # Makefile.PL is first choice
#  # tell about name scheme? ("perl-xxx")
#  case $name in perl-*) ;; *) error "Name should be perl-$name" esac
  use_inst_destdir=true
  use_fix_man=true
  snip cfg_autogen $script
  snip cfg_configure $script
  # use cfg_perl
#  snip cfg_hard $script
  # use mk
  snip mk_PREFIX $script
  snip mk_prefix $script
  # use inst_destdir
  snip inst_PREFIX $script
  snip inst_prefix $script
  snip inst $script
  snip inst_python $script
  arch=noarch
else
  snip cfg_perl $script
  if check "^configure$" $t/footprint; then
    check "--prefix" $t/src/$srcdir_prefix/configure || snip ac_prefix $script
    check "--sysconfdir" $t/src/$srcdir_prefix/configure || snip ac_sysconfdir $script
    check "--program-prefix" $t/src/$srcdir_prefix/configure || snip ac_program_prefix $script
    check "--localstatedir" $t/src/$srcdir_prefix/configure || snip ac_localstatedir $script
    check "--disable-static" $t/src/$srcdir_prefix/configure || snip ac_disable_static $script
    snip cfg_autogen $script
    # use cfg_configure
    # cfg_perl disabled
#    snip cfg_hard $script
    # use mk
    snip mk_PREFIX $script
    snip mk_prefix $script
    # inst_destdir?
    # inst_PREFIX?
    # inst_prefix?
    # inst?
    snip inst_python $script
  elif check "^autogen.sh$" $t/footprint; then
    # use cfg_autogen
    # use cfg_configure
    # cfg_perl disabled
#    snip cfg_hard $script
    # use mk
    snip mk_PREFIX $script
    snip mk_prefix $script
    # inst_destdir?
    # inst_PREFIX?
    # inst_prefix?
    # inst?
    snip inst_python $script
  else
    snip cfg_configure $script
    snip cfg_autogen $script
    if check "^setup\.py$" $t/footprint; then
      # setup.py only if no configure
      use_no_mk=true
      #snip cfg_autogen $script
      #snip cfg_configure $script
      #snip cfg_perl $script
      snip cfg_hard $script
      snip mk $script
      snip mk_PREFIX $script
      snip mk_prefix $script
      snip inst_destdir $script
      snip inst_PREFIX $script
      snip inst_prefix $script
      snip inst $script
      # use inst_python
      arch=noarch
    else
      error "Don't know how to build this package."
      failed=true
    fi
  fi
fi

# installation prefix
if check "^Makefile" $t/footprint; then
  if $use_inst_destdir || check "DESTDIR" $t/src/$srcdir_prefix/Makefile*; then
    # use inst_destdir
    snip inst_PREFIX $script
    snip inst_prefix $script
    snip inst $script
    snip cfg_hard $script
  else
    snip inst_destdir $script
    if check "PREFIX" $t/src/$srcdir_prefix/Makefile*; then
      # inst_destdir disabled
      # use inst_PREFIX
      snip inst_prefix $script
      snip inst $script
      snip cfg_hard $script
    else
      snip inst_PREFIX $script
      if check "prefix" $t/src/$srcdir_prefix/Makefile*; then
        # inst_destdir disabled
        # inst_PREFIX disabled
        # use inst_prefix
        snip inst $script
        snip cfg_hard $script
      else
        snip inst_prefix $script
        if check "/usr/local" $t/src/$srcdir_prefix/{,*/}Makefile*; then
          # inst_destdir disabled
          # inst_PREFIX disabled
          # inst_prefix diabled
          # use inst
          :
        else
          error "Don't know how to install this package (no install-prefix)."
          failed=true
        fi
      fi
    fi
  fi
elif $use_no_mk; then
  :
else
  error "Don't know how to install this package (no Makefile)."
  failed=true
fi

# cflags
use_cflags=true
if ! check "CFLAGS" "$t/src/$srcdir_prefix/*"; then
  snip cflags $script
  use_cflags=false
fi

# cxxflags
use_cxxflags=true
if ! check "CXXFLAGS" "$t/src/$srcdir_prefix/*"; then
  snip cxxflags $script
  use_cxxflags=false
fi

## slkcflags
! $use_cflags && ! $use_cxxflags && snip slkcflags $script

# check gconf schemas, scrollkeeper and mime-info
check "\.schemas(|\.in|\.in\.in)$" $t/footprint && schemas=true || schemas=false
check "\.omf$" $t/footprint && omfs=true || omfs=false
check "\.(keys|mime)(|\.in)$" $t/footprint && mimes=true || mimes=false
#$schemas || snip schemas $script
#$omfs || snip omfs $script

# check doc and man paths
check "/share/doc" $t/src/$srcdir_prefix/{,*/}Makefile* || snip fix_doc $script
$use_fix_man || check "/share/man" $t/src/$srcdir_prefix/{,*/}Makefile* || snip fix_man $script

# update doinst.sh
if $schemas || $omfs; then
  if ! grep -sq "^inst()$" $path/doinst.sh; then
    row "Adding inst() to doinst.sh"
    cat $0 | sed '/^#\!doinst.sh_inst$/,/^#\!doinst.sh_inst$/!d' >>$path/doinst.sh
  fi
# only if not gconf or scrollkeeper
else
  snip doinst_inst $script
  if [ -f $path/doinst.sh ]; then
    if grep -q "^inst()$" $path/doinst.sh; then
      row "Removing unneeded inst() from doinst.sh"
      sed -i "/^inst()$/,/^}$/d" $path/doinst.sh
    fi
  fi
fi

# check for config()
if grep -sq "\.new" $script; then
  if ! grep -sq "^config()$" $path/doinst.sh; then
    row "Adding config() to doinst.sh"
    cat $0 | sed '/^#\!doinst.sh_config$/,/^#\!doinst.sh_config$/!d' >>$path/doinst.sh
  fi
# only if not gconf or scrollkeeper
else
#  snip doinst_config $script
  if [ -f $path/doinst.sh ]; then
    if grep -q "^config()$" $path/doinst.sh; then
      row "Removing unneeded config() from doinst.sh"
      sed -i "/^config()$/,/^}$/d" $path/doinst.sh
    fi
  fi
fi

# add mime-installation
mime_inst="usr/bin/update-mime-database usr/share/mime >/dev/null 2>&1"
if $mimes && ! grep -sqx "$mime_inst" $path/doinst.sh; then
  row "Adding mime database intallation to doinst.sh"
  echo "$mime_inst" >>$path/doinst.sh
elif $mimes && grep -sqx "$mime_inst" $path/doinst.sh; then
  row "Removing unneeded mime database intallation from doinst.sh"
  sed -i "\,^$mime_inst$,d" $path/doinst.sh
fi

# anyways check old config()
if grep -sq "^config()$" $path/doinst.sh && ! grep -sq "^config .*\.new$" $path/doinst.sh; then
  row "Removing old and unneeded config() in doinst.sh"
  sed -i "/^config()$/,/^}$/d" $path/doinst.sh
fi

# if doinst.sh is emtpy remove it
if [ -f $path/doinst.sh ] && ! [ -s $path/doinst.sh ]; then
  row "Removing empty doinst.sh"
  rm $path/doinst.sh
fi
[ -f $path/doinst.sh ] || snip doinst $script

# now arch should be known
case $arch in
  noarch)
    sed -i "s,%arch%,$arch," $script
    snip cflags $script
    snip strip $script;;
  *)
    # we know better than the user ;-)
    sed -i "s,%arch%,\${ARCH:-i486}," $script;;
esac

# are there patches?
for section in config install doc post-config post-install post-doc; do
  if [ -f $path/$section-fix.autoport ]; then
    row "Adding $section-fix"
    sed -i "s,#%$section-fix%,. \$CWD/$section-fix.autoport," $script
    # if it's not a post-xxx, then it's meant to replace the section
    case $section in post-*) ;; *) snip meta-$section $script;; esac
  fi
done
if [ "`ls $path/*.patch 2>/dev/null`" ]; then
  row "Adding patches (Please check them later!)"
else
  snip patch $script
fi

# clean up
sed -i "/^#/d" $script
sed -i "s, *##[^ ]*,,g" $script
if [ -f $path/doinst.sh ]; then
  sed -i "/^#/d" $path/doinst.sh
  sed -i "s, *##[^ ]*,,g" $path/doinst.sh
fi

# summary
stanza "We're done. Port written in $path."
if [ -f $path/readme.autoport ]; then
  stanza "There's a readme for this port:"
  echo "==========================================="
  more $path/readme.autoport
  echo "==========================================="
fi

# any errors?
$failed && die "There's been an error. Please write SlackBuild by hand."

# portpkg?
if $build_pkg; then
  ask "* Next step: Call portpkg. Continue? (ctrl-c to quit)"
  portpkg -b $group/$name
fi

exit 0

#----------------------------------------

#!SlackBuild.skel
VERSION=%version%
#SRCVER=%srcver% ##srcver
ARCH=%arch%
BUILD=%build%

TMP=${TMP:-/tmp}
CWD=`pwd`
NAME=`basename $CWD`
PKG=$TMP/package-$NAME
rm -rf $PKG
mkdir -p $PKG/{install,usr/doc/$NAME-$VERSION}

#!slkcflags
case $ARCH in
  i386,i486)   SLKCFLAGS="-O2 -march=$ARCH -mcpu=i686";;
  s390,x86_64) SLKCFLAGS="-O2";;
esac

#!slkcflags
cd $TMP || exit 1
rm -rf $NAME-$VERSION || exit 1 ##extra_sdp
mkdir -p $NAME-$VERSION ##extra_sdp
cd $NAME-$VERSION || exit 1 ##extra_sdp
#rm -rf %srcdirprefix% || exit 1 ##cd_sdp
#!rpm
rpm2targz $CWD/%tarball%
tar xzvf `basename %tarball% .rpm`.tar.gz
tar xzvf $NAME-$VERSION.tar.gz
#!rpm
tar x%tarmode%vf $CWD/%tarball% || exit 1 ##tar
cd %srcdirprefix% || exit 1 ##cd_sdp
cat $CWD/*.patch | patch -p1 --verbose ##patch
chown -R root.root .
#find . -perm %perm644% -exec chmod 644 {} \; ##perms644
#find . -perm %perm755% -exec chmod 755 {} \; ##perms755
#!meta-config
./autogen.sh || exit 1 ##cfg_autogen
#!cfg_configure
CFLAGS="$SLKCFLAGS" \
##cflags
CXXFLAGS="$SLKCFLAGS" \ ##cxxflags
./configure \
  --prefix=/usr \ ##ac_prefix
  --sysconfdir=/etc \ ##ac_sysconfdir
  --localstatedir=/var/lib \ ##ac_localstatedir
  --program-prefix="" \ ##ac_program_prefix
  --disable-static \ ##ac_disable_static
  $ARCH-slackware-linux || exit 1
#!cfg_configure
perl Makefile.PL || exit 1 ##cfg_perl
#!meta-config
#%config-fix%
#%post-config-fix%
find -name Makefile | xargs sed -i "s,/usr/local/etc,$PKG/etc,g" ##cfg_hard
find -name Makefile | xargs sed -i "s,/usr/local/var,$PKG/var,g" ##cfg_hard
find -name Makefile | xargs sed -i "s,/usr/local,$PKG/usr,g" ##cfg_hard
find -name Makefile | xargs sed -i "s,/share/doc,/doc,g" ##fix_doc
find -name Makefile | xargs sed -i "s,/share/man,/man,g" ##fix_man
make || exit 1 ##mk
make PREFIX=/usr || exit 1 ##mk_PREFIX
make prefix=/usr || exit 1 ##mk_prefix
#!meta-install
make install DESTDIR=$PKG || exit 1 ##inst_destdir
make install PREFIX=$PKG/usr || exit 1 ##inst_PREFIX
make install prefix=$PKG/usr || exit 1 ##inst_prefix
make install || exit 1 ##inst
python setup.py build install --root=$PKG || exit 1 ##inst_python
#!meta-install
#%install-fix%
#%post-install-fix%
cp -a \ ##docs
  %docs% \ ##docs
  $PKG/usr/doc/$NAME-$VERSION/ ##docs

cd $PKG || exit 1
cat $CWD/slack-desc >$PKG/install/slack-desc
cat $CWD/doinst.sh >$PKG/install/doinst.sh ##doinst
find -type d | grep -e /bin$ -e /sbin$ | xargs -r chown -R root.bin
find -type d | grep /doc/ | xargs -r chmod 755
find -type f | grep /doc/ | xargs -r chmod 644
find -type f | xargs file | grep ELF | cut -d : -f 1 | xargs -r strip --strip-unneeded ##strip
find -type f | grep -e /man/ -e /info/ | xargs -r gzip -9
find -name "*.omf" -o -name "*.schemas" | sed "s,^\./,inst ," >>$PKG/install/doinst.sh ##doinst_inst
#%polish-fix%
#%post-polish-fix%

makepkg -p -l y -c n $TMP/$NAME-$VERSION-$ARCH-$BUILD.tgz
#!SlackBuild.skel

#!doinst.sh_config
config() {
  NEW="$1"
  OLD="`dirname $NEW`/`basename $NEW .new`"
  # If there's no config file by that name, mv it over:
  if [ ! -r $OLD ]; then
    mv $NEW $OLD
  elif [ "`cat $OLD | md5sum`" = "`cat $NEW | md5sum`" ]; then # toss the redundant copy
    rm $NEW
  fi
  # Otherwise, we leave the .new copy for the admin to consider...
}
#!doinst.sh_config
#!doinst.sh_inst
inst()
{
  case $1 in
    *.omf)
      scrollkeeper-update -p var/lib/scrollkeeper -o $1 >/dev/null 2>&1;;
    *.schemas)
      GCONF_CONFIG_SOURCE=`gconftool-2 --get-default-source` \
      gconftool-2 --makefile-install-rule $1 >/dev/null 2>&1;;
  esac
}
#!doinst.sh_inst
