#!/bin/sh
#BLURB="Export to portpkg.berlios.de"
#
# This plugin exports to portpkg.berlios.de. It detects automagically which
# backend to use:
#  * uploading via HTTP or
#  * submitting via CVS (only if you have a CVS write access).
#
# usage: portpkg --export "This is a summary" <expression>
#        portpkg --export q <expression>	# quote summary from 'info' file
#        portpkg --export <dest>: <expression>  # move to dest (relative to
#						# $PRT_DIR) in CVS (write access!)

SOURCE=:pserver:anonymous@cvs.berlios.de:/cvsroot/portpkg
DEST=http://portpkg.berlios.de/upload.php

# check that we're a plug-in
#if ! [ "$PORTPKG" ]; then
if [ "`basename $0`" != "portpkg" ]; then
  echo "I'm a plugin. Don't run me!"
  exit 1
fi

t=`mktemp -d`
has_args "$@" || die
export_opt=""
dest=""
quote=false
case $1 in
  *:)   export_opt="Moved to ${1%:}/."
        dest=$PRT_DIR/${1%:};;
  q)    quote=true;;
  *\ *) export_opt="$1";;
  *)    die "You must specify a summary of your export! At least two words required.";; esac
shift
has_ports || die

#stanza "Exporting to `echo $SOURCE | cut -d @ -f 2 | cut -d : -f 1`:"
for arg in `explicit "$@"`; do
  debug "do_export(): \$arg=$arg"
  get_info $arg || continue
  path=`dirname $script`

  # quote summary
  if ( $quote || [ "$dest" ] ) && [ -f $path/info ]; then
    tag=`echo $package | egrep -o "[a-zA-Z]+$"`
    export_opt=`grep -si "changelog entry:" $path/info | tr -s " " | cut -d " " -f 3-`" ($tag)"
  fi

  # check if it's broken
  if [ -f $path/PORT_IS_BROKEN ]; then
    error "Cannot export broken ports. Please fix first: $group/$name"
    continue
  fi

  # check if it's already run
  if ! [ "$pkg_file" ] || ! [ -f $pkg_file ] || [ $pkg_file -ot $script ]; then
    error "Build script is newer than last package: $group/$name"
    continue
  fi

  if [ "`find $path/ -type l`" ]; then
    error "Remove any links before export: $group/$name"
    continue
  fi

  # check "ownership"
#  case $package in *[0-9]$MY_TAG) ;; *)
  if ! $maintain; then
    row "$group/$name is not your port. Skipping."
    continue
  fi

  pause "Continue exporting $package? (ctrl-c to abort)"

  # if there's $PRT_DIR/CVS/Root which doesn't contain "anonymous" it must be a CVS
  # write account (?)
#  if [ -f $PRT_DIR/CVS/Root ] && ! grep -sq "anonymous" $PRT_DIR/CVS/Root; then
  if [ -f $path/CVS/Root ] && ! grep -sq "anonymous" $path/CVS/Root; then
    warn "Trying to write directly to CVS!"

    # check again
    has_prog cvs || die
    has_prog rcs2log || die
    has_prog ssh || die

    row "Submitting $package to CVS"

    # CVS in berlios.de requires ssh
    export CVS_RSH=ssh
    $DRY_RUN && pre=echo || pre=""

    if [ "$dest" ]; then
      # first clean $dest/
      if [ -d $dest/$name ]; then
        row "Cleaning destination $dest/$name"
        find $dest/$name -type f ! -path "*CVS*" -exec $pre rm -rf {} \;
      fi

      # copy files
      row "Copying files to $dest/"
      cd `dirname $path`
      find $name/ ! -path "*CVS*" ! -name info -exec $pre cp -vP --parents {} $dest/ \;

      # remove old entry
      row "Removing CVS of old $name"
      cd `dirname $path`
      if [ -d $name/CVS ]; then
        $pre cvs -qz3 rm -f $name && $pre cvs -qz3 ci -m "$export_opt" $name || continue
      fi
      [ "$path" ] && $pre rm -rf $path

      # set new $path
      path=$dest/$name
    fi

    # check if this path is already in the repository
    cd $path || die
    [ -d CVS ] || ( cd .. && $pre cvs -qz3 add `basename $path` ) || die

    # compare local tree with CVS
    find ! -path "*CVS*" ! -path "." ! -name "*.autoport" | sort >$t/local
    find -path "*/CVS/Entries" -exec grep -H / {} \; | rev | cut -d / -f 5,8- | rev | sort >$t/cvs

    # add/remove entries that are new/not here anymore
    fgrep -vxf $t/local $t/cvs | xargs -r $pre cvs -qz3 rm || die
    fgrep -vxf $t/cvs $t/local | xargs -r $pre cvs -qz3 add || die

    # commit
    $pre cvs -qz3 ci -m "$export_opt" || die

    # now update ChangeLog
    touch ChangeLog
    grep -sq "^/ChangeLog/" CVS/Entries || $pre cvs -qz3 add ChangeLog
    $pre rm -f ChangeLog
#    cvs_host=`echo $SOURCE | cut -d @ -f 2 | cut -d : -f 1`
    mail_host=users.berlios.de
    $DRY_RUN || rcs2log -i 2 -h $mail_host >ChangeLog
    $pre sed -i "/: Updated./{N;d}" ChangeLog
    $pre cvs -qz3 ci -m "Updated." ChangeLog
  else
    # use upload backend
    has_prog curl || die

    # hm, use at least 7.12.2 (Slackware 10.1)
    case `curl -V | head -n 1 | cut -d " " -f 2` in
      7.12.0|7.12.1)   die "You need curl >= 7.12.2";;
      7.1[23456789].*) ;;
      *)               die "You need curl >= 7.12.2";;
    esac

    [ "${MY_TAG:-}" ] || die "No tag configured. Please run: pp-config"
    [ "${MY_EMAIL:-}" ] || die "No mail address configured. Please run: pp-config"
    [ "${MY_REALNAME:-}" ] || die "No real name configured. Please run: pp-config"

    row "Preparing $group/$package for upload"

    # make a tarball of this port in $LOG_DIR/
    mkdir -p $LOG_DIR
    rm -f $LOG_DIR/$package.tar.bz2*
    mkdir -p $t/$package/$name
    cp -a $path/* $t/$package/$name/

    # add maintainer information and changelog entry
    cat >$t/$package/$name/info <<EOF
Package:  $package
Maintainer:  $MY_REALNAME '$MY_TAG' <$MY_EMAIL>
Intended group:  $group/
ChangeLog entry:  $export_opt
Timestamp:  `date`
EOF

    # remove private and backup files
    ( cd $t/$package
      find -name "CVS" -exec rm -rf {} \;
      find -name "*.autoport" -exec rm -f {} \;
      find -name "*~" -exec rm -f {} \;
      tar cjf $LOG_DIR/$package.tar.bz2 . )

    # test if there's a key to sign the tarball for $MY_EMAIL
    if has_prog gpg && gpg -K | grep -sq "<$MY_EMAIL>"; then
      gpg -abu $MY_EMAIL $LOG_DIR/$package.tar.bz2
    else
      warn "Please install gnupg next time and generate a key pair for \
$MY_EMAIL and send the public key to one of the project leaders or export \
it to a key server!"
    fi

    # stop here when $DRY_RUN
    $DRY_RUN && continue

    # upload the tarball to $DEST
    row "Uploading $LOG_DIR/$package.tar.bz2"
    curl -F filetoupload=@$LOG_DIR/$package.tar.bz2 $DEST >/dev/null 2>&1 \
    || error "Upload failed!"

    # upload the tarball's signature if any
    if [ -f $LOG_DIR/$package.tar.bz2.asc ]; then
      row "Uploading $LOG_DIR/$package.tar.bz2.asc"
      curl -F filetoupload=@$LOG_DIR/$package.tar.bz2.asc $DEST >/dev/null 2>&1 \
      || error "Upload failed!"
    fi
  fi
done
