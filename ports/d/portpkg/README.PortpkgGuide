PortpkgGuide

   This page addresses the how and why of the administration tool portpkg and
   its inner work and development. This page is concrete incarnation of the
   term work in progress.

Terminology

   Port
           A set of scripts or files that describe how to make a certain
           binary package.

   Package, or binary package
           A file that contains all files that belong together, prepared for
           a certain OS and architecture, mostly machine code and ready to
           run. In Slackware, ending always in .tgz.

   Source package
           A file that contains all files that belong together, mostly plain
           text, valid for several OSes and architectures, and have to be
           prepared for installation first. Ending in .tar.gz, .tar.bz2, .tgz
           or .src.rpm etc.

   SlackBuild

   Ports tree
           Hierarchy of port scripts.

   Package name, or short name
           In Slackware, the first of the 4 segments in a package descriptor,
           delimited by -. E.g.: mplayer is the package name of the package
           mplayer-1.0pre5-i486-1tom.

   Build, or release
           In Slackware, the last of the 4 segments in a package descriptor,
           delimited by -. E.g.: 1tom is the build of the package
           mplayer-1.0pre5-i486-1tom.

Theory

   "What is exactly the difference between the ports in Portpkg and the
   "ports" in Slackware?"

   Slackware doesn't call that ports! It's just the source code of Slackware.

   The most obvious difference seems to be the file source: While Slackware
   stores every source package in the same directory, Portpkg just gives a
   list of URLs, where to get them. The effect is the same, because they have
   to be downloaded anyway.

   Moreover the SlackBuilds in Portpkg are a little more consequential in
   declarations (each SlackBuild has to have the lines VERSION=, ARCH= and
   BUILD= and its values in plain text) and more consequential in
   implementation (each port has one SlackBuild, each SlackBuild makes one
   binary package). Have a look at the .build-scripts, the X11-SlackBuild and
   the KDE-scipts to see what I mean. This behaviour may change in future to
   make Portpkg more compatible with the Slackware sources.

   The concept of Portpkg's ports tree is to provide a functionality without
   portpkg at all, although it's not that easy to use:

 # cd /usr/ports/ap/dbus
 # cat sources | sed "s#\$VERSION#1.2.3#" | wget -i -
 (...)
 # sh ./SlackBuild
 (...)
 # installpkg /tmp/dbus-*.tgz
 (...)

   Portpkg generates a list of available ports on-the-fly. That means a
   VERSION-change in one SlackBuild of a port is immediatly translated.

   Usage and output of portpkg is mostly analogue to the usage and output of
   Slackware's installpkg. Again, layout of the ports tree is analogue to the
   layout of Slackware's source/ directory.

   ---------------------------------------------------------------------------

File system

   +----------------------------------------+
   |/usr/ports   |Ports tree copy           |
   |-------------+--------------------------|
   |/usr/obj/pkg |Stored binary packages    |
   |-------------+--------------------------|
   |/usr/src/dist|Downloaded source packages|
   |-------------+--------------------------|
   |/usr/src/cvs |CVS-repositories^1        |
   +----------------------------------------+

   Notes: ^1 Planning

   ---------------------------------------------------------------------------

Ports Tree

   +-----------------------------------------------------+
   |a/      |Base packages                               |
   |--------+--------------------------------------------|
   |ap/     |Applications (not fitting to xap/ or n/)    |
   |--------+--------------------------------------------|
   |d/      |Development tools                           |
   |--------+--------------------------------------------|
   |gnome/  |Applications, that require the GNOME-desktop|
   |--------+--------------------------------------------|
   |kde/    |Applications, that require the KDE          |
   |--------+--------------------------------------------|
   |l/      |Libraries                                   |
   |--------+--------------------------------------------|
   |n/      |Network servers and clients                 |
   |--------+--------------------------------------------|
   |x/      |X server and its fonts and drivers          |
   |--------+--------------------------------------------|
   |xap/    |X applications                              |
   |--------+--------------------------------------------|
   |pasture/|Packages for compatibility reasons          |
   |--------+--------------------------------------------|
   |testing/|Packages for testing                        |
   +-----------------------------------------------------+

   Findige Slacker werden hier sicherlich bemerkt haben, dass die Gruppen
   testing/ und pasture/ eigentlich auf Slackware eine Ebene hoeher liegen.
   Dies steht natuerlich noch zur Diskussion :)

   In zweiter Ebene stehen die Ports, von denen jeder nur in einer Gruppe
   sein kann. Fuer jeden Port gibt es ein Verzeichnis, in dem die Skripte
   aufbewahrt werden:

 /usr/ports/
 |-- ap/
 |   |-- abook/
 |   |-- athcool/
 |   |-- bonnie++/
 |   |-- cabextract/
 |   |-- cpudyn/
 |   |-- exiftags/
 |   `-- exifutils/
 |-- d/
 |   |-- fakeroot/
 |   |-- lua/
 |   |-- mono/
 |   |-- portpkg/
 |   |-- ruby/
 |   `-- tla/
 |-- gnome/
 |   |-- aegis-virus-scanner/
 |   |-- at-spi/
 |   |-- balsa/
 (...)

   ---------------------------------------------------------------------------

Operating Process

   Portpkg durchsucht den Portsbaum nach Dateien, die *.SlackBuild oder
   SlackBuild heissen. Aus diesen wird die Versionsinformation ausgelesen.
   All das wird zu einer Liste von verfuegbaren Paketen zusammengestellt, die
   mit portpkg --list angezeigt werden kann. Wenn mit portpkg grip der Port
   "grip" aufgerufen wird, so geht Portpkg zuerst diese Liste durch und sucht
   den ersten zutreffenden Port und dessen Verzeichnis (in diesem Falle
   /usr/ports/xap/grip, dabei wird natuerlich auch sichergestellt, dass z.B.
   die Suchmaske "nautilus" nicht auf "nautilus-cd-burner" zutrifft), danach
   geht es eine Checkliste durch:

    1. Ist genau diese verfuegbare Version schon installiert?
    2. Ist ein fertiges Paket schon in /usr/obj/pkg?
    3. Ist das Quellpaket schon in /usr/src/dist?

   Erst jetzt wird das SlackBuild aufgerufen, dann bei erfolgreicher
   Kompilation installiert und nach /usr/obj/pkg verschoben.

   ---------------------------------------------------------------------------

Dealing With Ports

   Portpkg uebernimmt einige Aufgaben, die das Erstellen von Ports
   erleichtern, sowohl wenn man "Maintainer" eines Ports ist (d.h. das der in
   der Datei /usr/ports/maintain stehende Tag in der Zeile MY_TAG= mit dem
   Tag des jeweiligen Ports uebereinstimmt), als auch fuer das bauen und
   installieren von Ports an sich:

     o Download der erforderlichen Quelldateien (siehe Datei sources)
     o Automatisches Ueberpruefen und Ergaenzen (im Maintainermodus) von
       Abhaengigkeiten (siehe Datei requires)
     o Sammeln der Quelldateien und Pakte in speziellen Verzeichnissen
       (/usr/src/dist und /usr/obj/pkg)
     o Erstellen von diversen Dateien (siehe oben), die dem Maintainer
       helfen, zu ueberpruefen, ob das Paket richtig gebaut wurde.

   ---------------------------------------------------------------------------

