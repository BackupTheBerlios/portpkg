#!/bin/bash -u
#
# Portpkg - A portssystem for Slackware written in Bash++
# Copyright (C) 2003, 2004 Thomas Pfaff <toastbrot@web.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# default settings
ENGINE_VER=current
ADM_DIR=/var/log
SCRATCH_DIR=/tmp/portpkg-`whoami`-$$
SRC_DIR=~/sources
PKG_DIR=~/packages
PRT_DIR=~/ports

# default options
action=do_add
download_only=false
reinstall=false
rebuild=false
verbose=false
debug=${debug:-false}
output=/dev/null

# global variables
declare ignore mirrors exclude
declare package name group
declare script description requires size sources

# converters
pkg2name()	{ sed -r "s,^(.*)-.*-.*-.*$,\1,"; }
pkg2ver()	{ sed -r "s,^.*-(.*)-.*-.*$,\1,"; }
pkg2rel()	{ sed -r "s,^.*-(.*-.*-.*)$,\1,"; } 

# message system
stanza()	{ [ "$*" ] && echo -e "\n$@"; }
row()		{ echo -e "  --> $@"; }
warn()		{ echo -e "WARNING: $@"; }
error()		{ [ "$*" ] && stanza "$@" >&2; return 1; }
die()		{ error "$@"; exit 1; }
if $debug; then
debug()		{ echo $@ >&2; }
else
debug()		{ :; }
fi

# checks
has_args()	{ [ "$*" ] || error "Too few arguments! Try: portpkg --help"; }
is_root()	{ [ "$UID" == "0" ] || error "You must be root to run this action!"; }
has_pkg()	{ ls_inst | grep -q "^$1." || error "You need $1.0 or newer!"; }
has_ports()	{ [ -d $PRT_DIR ] || error "No ports found! Try: portpkg --sync"; }

# file utils
ls_inst()	{ find $ADM_DIR/packages/ -type f | sed "s,^.*/,," 2>/dev/null; }
ls_cache()	{ find $PKG_DIR/ -name "*.tgz" | sed -r "s,^.*/(.*/.*)\.tgz$,\1," 2>/dev/null; }
ls_avail()	{ ls_locations | sed -r "s,^/.*/(.*/.*)$,\1," 2>/dev/null; }

# download a file
get()
{
    local url=$1 dest=$2
    has_pkg wget-1.9 || die
    mkdir -p `dirname $dest`
    # mirrors
    if [ "$mirrors" ]; then
	debug "get(): we have mirrors"
	echo "$mirrors" >$t.mirrors
        local line
        while read line; do
	    # seems i won't get around awk
	    local master=$(echo $line | awk '{ print $1 }')
	    local mirror=$(echo $line | awk '{ print $2 }')
	    url=`echo $url | sed "s,^$master,$mirror,"`
	done <$t.mirrors
    fi
    debug "get(): \$url=$url"
    if wget -c -O $dest.part $url 2>&1; then
	mv $dest.part $dest
    else
	error "Download failed!"
    fi
}

# prepare a unique scratch-dir or -file
private() # >filename
{
    local file=$SCRATCH_DIR/$RANDOM
    rm -rf $file
    echo $file
}

# generate a regular expression for grep from a pkgex-list
regex() # >regex_list
{
    local arg
    for arg; do
	case $arg in
	    */)	# groups
		echo -n " -e ^$arg";;
	    *)	# (g_)names and (g_)packages
		echo -n " -e ^$arg-[^-]*-[^-]*-[^-]*$"
		echo -n " -e /$arg-[^-]*-[^-]*-[^-]*$"
		echo -n " -e ^$arg$"
		echo -n " -e /$arg$";;
	esac
    done
    [ "$#" = "0" ] && echo "-e ^$"
}

# resolve groups/ to names
# note: do_list doesn't use explicit()!
explicit() # >pkgex-list
{
    local arg
    for arg; do
	case $arg in
	    */)	do_list $arg | pkg2name | cut -d / -f 2;;
	    *)	echo $arg;;
	esac
    done
}

# list all available ports
ls_locations()
{
    local cache=$SCRATCH_DIR/loc_cache
    if [ -f $cache ]; then
	cat $cache 2>/dev/null
	return
    fi
    find $PRT_DIR/ -follow -mindepth 3 -name "*SlackBuild" \
    | xargs egrep -sH "^VERSION=|^ARCH=|^BUILD=" \
    | tr "\n" " " | sed -r \
    -e "s,/[^/]*SlackBuild:VERSION=,-,g" \
    -e "s, [^ ]*:ARCH=,-,g" \
    -e "s, [^ ]*:BUILD=,-,g" \
    -e "s,\\$\{[A-Z]*:-,,g" \
    -e "s,},,g" \
    | tr " " "\n" \
    | sort \
    | tee $cache 2>/dev/null
}

# print non-available, but installed ports
ls_diff() # >list
{
    debug "ls_diff(): starting"
    local t=`private`
    debug "ls_diff(): call: ls_avail"
    ls_avail | grep -v $exclude | cut -d / -f 2 >$t.avail
    debug "ls_diff(): call: ls_inst"
    ls_inst >$t.inst
    debug "ls_diff(): call: pkg2name"
    pkg2name <$t.avail >$t.avail.names
    pkg2name <$t.inst >$t.inst.names
    debug "ls_diff(): call: fgrep"
    fgrep -xf $t.avail.names $t.inst.names >$t.check.names
    debug "ls_diff(): call: regex"
    local name
    while read name; do
#	grep -m 1 `regex $name` $t.avail >>$t.avail.check
#	grep -m 1 `regex $name` $t.inst >>$t.inst.check
	grep -m 1 "^$name-[^-]*-[^-]*-[^-]*$" $t.avail >>$t.avail.check
	grep -m 1 "^$name-[^-]*-[^-]*-[^-]*$" $t.inst >>$t.inst.check
    done <$t.check.names
    debug "ls_diff(): call: fgrep"
    fgrep -vxf $t.inst.check $t.avail.check
    debug "ls_diff(): finished"
}

# get information about a port and write it into global variables
get_info()
{
    # if there are more than one, take the first
    local url=`ls_locations | grep -m 1 $(regex $1)`
    if ! [ "$url" ]; then
	error "No such port: $1"
	return 1
    fi
    local gpkg=`echo $url | sed -r "s,.*/(.*/.*)$,\1,"`
    group=`echo $gpkg | cut -d / -f 1`
    package=`echo $gpkg | cut -d / -f 2`
    name=`echo $package | pkg2name`
    version=`echo $package | pkg2ver`
    local path=`dirname $url`/$name
    script=`find $path/ -name "*SlackBuild"`
    # remove ' and " from description
    description=`grep -s ^$name: $path/slack-desc | sed "s,['\"],,g" | cut -d : -f 2- | cut -d " " -f 2-`
    requires=`grep -sv ^# $path/requires`
    sources=`grep -sv ^# $path/sources | sed "s,\\$VERSION,$version,g"`
    depends=`fgrep -sxl $name $path/../../*/*/requires | rev | cut -d / -f 2 | rev`
    size=`du $PKG_DIR/$group/$package.tgz 2>/dev/null | cut -f 1`
    return 0
}

# check if all required packages are installed
check_reqs()
{
    local avail=$SCRATCH_DIR/avail_cache
    [ -f $avail ] || ls_avail >$avail
    debug "check_reqs(): starting: $package"
    # remember that for later
    local gpkg=$group/$package
    local refresh=false
    local req
    debug "check_reqs(): \$requires="$requires
    for req in $requires; do
	debug "check_reqs(): \$req=$req"
	local avail_pkg=`grep -m 1 $(regex $req) $avail | cut -d / -f 2`
	debug "check_reqs(): \$avail_pkg=$avail_pkg"
	[ -f $ADM_DIR/packages/$avail_pkg ] && continue
	if [ "$avail_pkg" ]; then
	    debug "check_reqs(): call: do_add $req"
	    if ! do_add $req; then
		error "$req is broken! Stopping."
		return 1
	    fi
	elif ! [ `ls_inst | grep -m 1 $(regex $req)` ]; then
	    error "Cannot find required package $req! Stopping."
	    return 1
	else
	    debug "check_reqs(): $req is sufficient and installed"
	fi
	refresh=true
    done
    # refresh info
    $refresh && get_info $gpkg
    debug "check_reqs(): finished: $package"
    return 0
}

# build package by SlackBuild
mk_source_pkg()
{
    local t=`private`
    local path=`dirname $script`
    local tree=`dirname $(dirname $path)`
    stanza "Building $package:"
    # check ports directory
    if ! [ -f $script ]; then
    	error "Strange: SlackBuild not found!"
	return 1
    fi
    # check SlackBuild header (this is for ls_avail)
    if [ "`egrep -o "^VERSION=|^ARCH=|^BUILD=" $script | xargs`" != "VERSION= ARCH= BUILD=" ]; then
	error "Malformed SlackBuild-header (VERSION, ARCH, BUILD)!"
	return 1
    fi
    # include maintain and switch to maintainer mode if $rel end with
    # -[0-9]*$MY_TAG
    local maintain=false
    if [ -f $tree/maintain ]; then
	local rel=`echo $package | pkg2rel`
	case $rel in *-[0-9]*$MY_TAG) maintain=true;; esac
    fi
    $MAINTAIN_ALL && maintain=true
    $maintain && warn "Maintainer mode: Port scripts will be modified!"
    $rebuild && warn "You shouldn't rebuild. Better change BUILD number!"
    # prepare build directory in /tmp
    mkdir -p $t.script/$name
    cd $t.script/$name/
    cp -a $path/* .
    # download the source files
    local src
    for src in $sources; do
	# if the source is a cgi- or php-script, the file name can be
	# written behind a % by the maintainer
	local srcname=`basename "$src" | cut -d % -f 2`
	local src=`echo "$src" | cut -d % -f 1`
	if [ -f $SRC_DIR/$srcname ]; then
	    row "$srcname found in $SRC_DIR/"
	else
	    row "Downloading $srcname"
	    get $src $SRC_DIR/$srcname || return 1
	fi
	# pseudo ports: don't cache sources
	if [ -f $path/pseudo ]; then
	    mv $SRC_DIR/$srcname .
	else
	    ln -s $SRC_DIR/$srcname .
	fi
    done
    $download_only && return 0
    # build package
    row "Executing $script"
    su -c "rm -rf /tmp/buildlog-$name
           rm -rf /tmp/$package.tgz
           sh $script 2>&1 | tee /tmp/buildlog-$name >$output" || return 1
    $maintain && cp /tmp/buildlog-$name $path/buildlog
    # success?
    if ! [ -f /tmp/$package.tgz ]; then
    	$verbose || tail /tmp/buildlog-$name
	error "Compilation failed (see /tmp/buildlog-$name)!"
	$maintain && touch $path/PORT_IS_BROKEN
	return 1
    fi
    # stuff for maintainers of port scripts :)
    if $maintain; then
	rm -rf $path/PORT_IS_BROKEN
	# is there a build tree?
	if [ -d /tmp/package-$name ]; then
	    # check libraries (don't log the package itself,
	    # aaa_base and aaa_elflibs, gcc and co.,
	    # glibc-derivates and all -solibs)
	    row "Finding requirements"
	    find /tmp/package-$name/ | xargs file | grep ELF \
	    | cut -d : -f 1 | xargs ldd 2>/dev/null | grep -o "/[^ ]*\.so" \
	    | sed -r "s,\./,," | cut -c 2- | sort -u | grep -lf - $ADM_DIR/packages/* \
	    | sed -r "s,^$ADM_DIR/packages/,," | pkg2name \
	    | grep -ve ^$name$ $ignore | sort -u >$t.bin_req
	    echo "$requires" >$t.old_req
	    # now merge into old requirements-list
	    cat $t.bin_req $t.old_req | grep -v ^$ | sort -u >$t.new_req
	    # update requires
	    cat $t.new_req >$path/requires
	    # show tracked dependencies that are not binary
	    local diffs=`diff -u $t.old_req $t.bin_req | grep ^[-][^-] | cut -c 2-`
	    if [ "$diffs" ]; then
		row "Arbitrary requirements: "$diffs
		echo "$diffs" >$path/arbitrary
	    else
		rm -f $path/arbitrary
	    fi
	fi
	# write the footprint
	tar tzvf /tmp/$package.tgz | sort +5 >$path/footprint
	# write the diff: SlackBuild compared to a generic one
	grep -sv "^#" $tree/SlackBuild | diff -bu - $script >$path/diff
    fi
    row "Moving to $PKG_DIR/$group/"
    mkdir -p $PKG_DIR/$group
    cp /tmp/$package.tgz $PKG_DIR/$group/
}

# really (re)install/upgrade current port
add_pkg() # tgz
{
    local t=`private`
    if ! [ -f $PKG_DIR/$group/$package.tgz ]; then
	error "Strange: $package not found."
	return 1
    fi
    # what to display?
    if [ -f $ADM_DIR/packages/$package ]; then
	stanza "Reinstalling $package..."
    elif [ "`ls_inst | grep $(regex $name)`" ]; then
	stanza "Upgrading $name to `echo $package | pkg2rel`..."
    else
    	stanza "Installing $package..."
    fi
    # commercials to fill the time gap
    $verbose || echo "$description" | sed "s,^,$name: ,"
    # call the magic all-in-one install-command
    if ! su -c "upgradepkg --install-new --reinstall \
                $PKG_DIR/$group/$package.tgz | tee $t.install_log >$output"; then
	$verbose || cat $t.install_log
	error "Installation failed!"
    fi
}

# prepare and install ports
do_add() # pkgex-list
{
    debug "do_add(): starting: $@"
    has_ports || die
    has_args $@ || die
    local ret=0
    local arg
    for arg in `explicit $@`; do
	debug "do_add(): \$arg=$arg"
   	ret=1
#	# vite vite!
#	local avail_pkg=`ls_avail | grep -m 1 $(regex $arg) | cut -d / -f 2`
#	if [ -f $ADM_DIR/packages/$avail_pkg ]; then
#	    ret=0
#    	    continue
#	fi
	get_info $arg || continue
	# requirements check (flat, no versions)
	# (...well, a little deeper now :) )
	# (...quite deep now :) )
	check_reqs || continue
	# package file found in cache?
	if ! [ -f $PKG_DIR/$group/$package.tgz ] || $rebuild; then
	    mk_source_pkg || continue
	fi
	if ! $download_only; then
	    # install the package
	    if [ -f $ADM_DIR/packages/$package ] && ! $reinstall; then
		stanza "$package is already installed. Skipping."
	    else
		add_pkg || continue
	    fi
	fi
	ret=0
    done
    return $ret
    debug "do_add(): finished: $@"
}

do_diff()
{
    local t=`private`
    has_ports || die
    local diff_list=`ls_diff`
    [ "$diff_list" ] || die "No differences found."
    stanza "PORT\r\t\t\t\tAVAILABLE\r\t\t\t\t\t\t\tINSTALLED"
    ls_inst >$t.inst
    ls_avail >$t.avail
    local pkg
    for pkg in $diff_list; do
	local avail_rel=`echo $pkg | pkg2rel`
	local name=`echo $pkg | pkg2name`
	local avail=`grep -m 1 $(regex $name) $t.avail | pkg2name`
	local inst_rel=`grep -m 1 $(regex $name) $t.inst | pkg2rel`
	avail=${avail:-$name}
	avail_rel=${avail_rel:-(n/a)}
	echo -e "$avail\r\t\t\t\t$avail_rel\r\t\t\t\t\t\t\t$inst_rel"
    done
}

# find ports by pattern
do_find() # text [..] >list
{
    local t=`private`
    has_ports || die
    local arg
    for arg; do
        grep -shi $arg $PRT_DIR/*/*/slack-desc
    done | grep "^[^ ]*: " | cut -d : -f 1 | sort -u >$t.list
    [ -s $t.list ] && do_list `cat $t.list`
}

# print information about a port
do_info() # pkgex-list
{
    has_ports || die
    has_args $@ || die
    local ret=0
    local arg
    for arg in `explicit $@`; do
	ret=1
	get_info $arg || continue
	local desc=`echo "$description" | head -n 1`
	echo
	echo "PORT NAME:       $group/$package"
	echo "COMPRESSED SIZE: ${size:-(n/a)} K"
	echo "LOCATION:        $script"
	echo "DESCRIPTION:     ${desc:-(n/a)}"
	echo "REQUIREMENTS:    "${requires:-(n/a)}
	echo "DEPENDENCIES:    "${depends:-(n/a)}
	echo "SOURCES:         "${sources:-(n/a)}
	ret=0
    done | fmt -t
    return $ret
}

# list available ports (gives a glist)
do_list() # [pkgex-list] >glist
{
    has_ports || die
    # grep arguments
    if [ "$*" ]; then
    	ls_avail | grep `regex $@` 2>/dev/null
    else
    	ls_avail
    fi
}

do_sync()
{
    local t=`private`
    local cvsroot=:pserver:anonymous@cvs.portpkg.berlios.de:/cvsroot/portpkg
    stanza "Synchronising your ports tree with `echo $cvsroot | cut -d @ -f 2 | cut -d : -f 1`:"
    # coming this summer
    if [ -d $PRT_DIR ]; then
        cd $PRT_DIR || die
	cvs -qz3 up -dPC -I footprint -I diff -I buildlog \
	-I PORT_IS_BROKEN -I arbitrary -I local 2>/dev/null
    else
	mkdir -p $PRT_DIR
        cd `dirname $PRT_DIR` || die
	cvs -qz3 -d $cvsroot co -P ports 2>/dev/null
    fi | sed -r \
    -e "/\(.*\)/d" \
    -e "s,^cvs [a-z]*:,  -->," \
    -e "s,^U,  --> Updating," \
    -e "s,^C,  --> Conflict with," \
    -e "s,^P,  --> Patching," \
    -e "s,^\?,  --> Unknown file," \
    -e "s,^[A-Z\?],  --> &,"
}

# upgrade all installed ports that are not available
do_upgrade() # [pkgex-list]
{
    debug "do_upgrade(): starting: $@"
    has_ports || die
    debug "do_upgrade(): calling: ls_diff"
    local diff_list=`ls_diff | pkg2name`
    [ "$diff_list" ] || die "No upgrades available."
    debug "do_upgrade(): calling: do_add $diff_list"
    do_add $diff_list
}

help()
{
    cat <<EOF

Usage: portpkg [action] [options] [list ...]
  Build and install (or upgrade) a port.
Actions:
  -d, --diff		Compare installed versions with availables
  -i, --info		View information about ports
  -f, --find		Find ports by pattern
  -l, --list		List available ports
  -s, --sync		Sync your ports tree with the official
  -u, --upgrade		Upgrade all (!) outdated ports
  -v, --version		View version information
Options:
  -e, --reinstall	Reinstall port if already installed
  -b, --rebuild		Rebuild port if alread build
  -o, --download	Download source files only
  -g, --verbose		Show compile output
Declaration:
  list: group/ or [group/]name[-version-arch-build]
EOF
}

version()
{
    cat <<EOF
	
Portpkg version $ENGINE_VER.
Copyright (C) 2003, 2004 Thomas Pfaff <toastbrot@web.de>.
This comes with ABSOLUTELY NO WARRANTY. This is free software, and
you are welcome to redistribute it under certain conditions.
EOF
}

parse_options()
{
    debug "parse_options(): starting: $@"
    local args
    args=`getopt -quo diflsuvhebog -l diff,info,find,list,sync,upgrade,version,help,reinstall,rebuild,download,showcompile -- "$@"`
    [ "$?" == "0" ] || die "Bad Arguments! Try: portpkg --help"
    eval set -- "$args"
    while [ "$1" ]; do
    	case $1 in
	    -d|--diff)		action=do_diff;;
	    -i|--info)		action=do_info;;
	    -f|--find)		action=do_find;;
	    -l|--list)		action=do_list;;
	    -s|--sync)		action=do_sync;;
	    -u|--upgrade)	action=do_upgrade;;
	    -v|--version)	action=version;;
	    -h|--help)		action=help;;
	    -e|--reinstall)	reinstall=true;;
	    -b|--rebuild)	rebuild=true;;
	    -o|--download)	download_only=true;;
	    -g|--verbose)	verbose=true
				output=/dev/stdout;;
	    --)			shift
				break;;
	esac
	shift
    done
    $rebuild && reinstall=true
    debug "parse_options(): calling: $action $@"
    $action $@
    exit $?
}

init()
{
    debug "init(): starting"
    # make temporary directory
    case $SCRATCH_DIR in ""|"/") die "Internal error!";; esac
    rm -rf $SCRATCH_DIR
    mkdir -p $SCRATCH_DIR
    chmod 700 $SCRATCH_DIR
    [ -d $SCRATCH_DIR ] || die "Internal error!"
    # clean up on exit
    trap "rm -rf $SCRATCH_DIR" EXIT
    trap "" PIPE
    # check requirements
    has_pkg sed-4 || die
    has_pkg coreutils-5.2 || die
    # prepare the exclude pattern
    [ -f $PRT_DIR/maintain ] && source $PRT_DIR/maintain
    MY_TAG=${MY_TAG:-}
    MAINTAIN_ALL=${MAINTAIN_ALL:-false}
    # global configs
    mirrors=`grep -vse ^# -e ^$ $PRT_DIR/mirrors`
    ignore=`grep -vse ^# -e ^$ $PRT_DIR/ignore`
    ignore=`regex $ignore`
    exclude=`grep -vse ^# -e ^$ $PRT_DIR/exclude`
    exclude=`regex $exclude`
    # if not used as include file, start me
    [ `basename $0` == "portpkg" ] && parse_options $@
    return 0
}

init $@
