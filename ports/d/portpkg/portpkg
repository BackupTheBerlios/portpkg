#!/bin/bash -u
#
# Portpkg -- A ports system for Slackware Linux, written in Bash++
# Copyright (C) 2003-2005 Thomas Pfaff <topf at users dot berlios dot de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# configuration (these values can be overwritten by /etc/portpkg/local.conf)
MAINTAIN_ALL=false
VERBOSE=false
DRY_RUN=false
NO_REQS=false
LAZY_CHECKS=false
DEBUG=false
ARCH=i486
CFLAGS=""
MY_TAG=""
ADM_DIR=/var/log
LOG_DIR=/var/log/portpkg
SRC_DIR=/usr/src/dist
PKG_DIR=/usr/obj/pkg
PRT_DIR=/usr/ports
CFG_DIR=/etc/portpkg
TMP=/tmp

# include configuration overlay
[ -f $CFG_DIR/local.conf ] && . $CFG_DIR/local.conf
[ -f ~/.portpkg.conf ] && . ~/.portpkg.conf

# constant values
ENGINE_VER=cvs
TMPDIR=`mktemp -d $TMP/portpkg-XXXXXX` || exit 1
export TMPDIR
ADD_SUM_CALL=`mktemp`
ADD_SUM_START=`mktemp`
ADD_SUM_FINISH=`mktemp`
CACHE=`mktemp -d`

# default arguments
action=do_add
download_only=false
prepare_only=false
reinstall=false
rebuild=false
remaintain=false
output=/dev/null

# global variables
declare \
  ignore mirrors exclude \
  package name group \
  script description requires optional blocks size u_size sources pkg_file \
  maintain slot_in pseudo no_fakeroot

# listers
ls_inst() { cache $CACHE/inst "find $ADM_DIR/packages/ -type f | sed \"s,^.*/,,\" 2>/dev/null" "$@"; }
ls_pkg()  { cache $CACHE/pkg "find $PKG_DIR/ -name \"*.tgz\" -follow | sed -r \"s,^.*/(.*/.*)\.tgz$,\1,\" 2>/dev/null" "$@"; }
ls_slk()  { cache $CACHE/slk "find \$repos -name \"*SlackBuild\" -follow 2>/dev/null" "$@"; }
ls_loc()  { cache $CACHE/loc "ls_slk | slk2loc" "$@"; }

# converters
pkg2name()  { sed -r "s,^(.*)-.*-.*-.*$,\1,"; }
pkg2ver()   { sed -r "s,^.*-(.*)-.*-.*$,\1,"; }
pkg2rel()   { sed -r "s,^.*-(.*-.*-.*)$,\1,"; } 
loc2gpkg()  { sed -r "s,^.*/(.*/.*)$,\1," 2>/dev/null; }
slk2gname() { sed "s,.*/\(.*/.*\)/.*$,\1,"; }
slk2loc()   { xargs grep -sH "^VERSION=\|^ARCH=\|^BUILD=" -m 3 2>/dev/null \
  | sed -n "\,:VERSION=,{s,/[^/]*:VERSION=,-,;N;s,\n.*=,-,;N;s,\n.*=,-,;s,\${ARCH:-[^}]*},$ARCH,;s,\${[A-Z]*:-\([^}]*\)},\1,g;p}" 2>/dev/null; }
# FIXME: preset $BUILD and $VERSION is not supported, only reset!

# message system
msg_level=0
stanza() { [ "$msg_level" = "0" ] && echo -e "\n$@"; }
#stanza() { [ "$*" ] && echo -e "\n$@"; }
row()    { echo -e "  --> $@"; }
warn()   { echo -e "WARNING: $@"; }
error()  { [ "$*" ] && stanza "$@" >&2; return 1; }
die()    { error "$@"; exit 1; }
debug()  { $DEBUG && echo "$@" >&2; }

# checks
has_args()  { [ "$*" ] || error "Too few arguments! Try: portpkg --help"; }
is_root()   { [ "$UID" == "0" ] || error "You must be root to run this action!"; }
has_prog()  { which $1 >/dev/null 2>&1 || error "Cannot find $1!"; }
has_ports() { [ -d "$PRT_DIR" ] || error "No ports found! Try: portpkg --sync"; }

# cache the output of "action" and grep a regex
cache() # file action regex
{
  local file=$1 action=$2
  shift 2
  [ "$*" ] && local filter="grep $@" || local filter="cat"
  if ! [ -f $file ]; then
    eval "$action" | tee $file | $filter -
  else
    $filter $file
  fi
}

# download a file and make use of mirrors
get()
{
  local url=$1 dest=$2
  has_prog wget || die
  mkdir -p `dirname $dest`
  local o_url=$url

  # mirrors
  if [ "$mirrors" ]; then
    echo "$mirrors" >$t/mirrors
    local master mirror
    while read master mirror; do
      url=`echo $url | sed "s,^$master,$mirror,"`
    done <$t/mirrors
  fi
  debug "get(): \$url=$url"

  local log=$LOG_DIR/`basename $dest`.wgetlog
  mkdir -p $LOG_DIR
  rm -f $log || die
  $VERBOSE && log=/dev/stdout

  # try primary url if mirror fails
  if wget -c -O $dest.part $url >$log 2>&1 \
  || wget -c -O $dest.part $o_url >>$log 2>&1; then
    mv $dest.part $dest
  else
    $VERBOSE || tail $log
    error "Download failed!"
  fi
}

# generate a regular expression for grep from a pkgex-list
regex() # >regex_list
{
  local arg
  for arg; do
    case $arg in
      */)
        # groups
        echo -n " -e \(^\|\/\)$arg";;
      *)
        # (g_)names and (g_)packages
        echo -n " -e \(^\|\/\)$arg\(\|-[^-]*-[^-]*-[^-]*\)$";;
    esac
  done
  [ $# == 0 ] && echo "-e ^$" || true
}

# resolve groups/ to names
# note: do_list doesn't use explicit()!
explicit() # >pkgex-list
{
  local arg
  for arg; do
    case $arg in
      */) ls_slk `regex $arg` | slk2gname | cut -d / -f 2;;
      *)  echo $arg;;
    esac
  done
}

# print non-available, but installed ports
ls_diff() # >list
{
  debug "ls_diff(): starting"
  local t=`mktemp -d`
  ls_loc -v $exclude | loc2gpkg | cut -d / -f 2 >$t/avail
  ls_inst >$t/inst
  pkg2name <$t/avail >$t/avail.names
  pkg2name <$t/inst >$t/inst.names
  local check
  fgrep -xf $t/avail.names $t/inst.names \
  | sed "s,.*,&-[^-]*-[^-]*-[^-]*," | while read check; do
    grep -xm 1 "$check" $t/avail >>$t/avail.check
    grep -xm 1 "$check" $t/inst >>$t/inst.check
  done
#  $LAZY_CHECKS && sed -i "s,\(.*-.*\)-.*-.*,\1," $t/avail.check
#  $LAZY_CHECKS && sed -i "s,\(.*-.*\)-.*-.*,\1," $t/inst.check
  fgrep -vxf $t/inst.check $t/avail.check | sort -u
  debug "ls_diff(): finished"
}

# get information about a port and write it into global variables
get_info() # pkgex
{
  debug "get_info(): starting: $@"

  # find port, take the first if more than one available
  local loc=`ls_loc -v $exclude 2>/dev/null | grep -m 1 $(regex $1)`
  # maybe an exluded one explicitly named?
  [ "$loc" ] || case $1 in */*)
    loc=`ls_loc -m 1 $(regex $1)`
    [ "$loc" ] && debug "get_info(): Excluded port specified explicitly!";;
  esac

  if ! [ "$loc" ]; then
    error "No such port: $1"
    return 1
  fi

  group=`echo $loc | loc2gpkg | cut -d / -f 1`
  package=`echo $loc | loc2gpkg | cut -d / -f 2`
  name=`echo $package | pkg2name`
  version=`echo $package | pkg2ver`
  local path=`dirname $loc`/$name
  script=`find $path/ -name "*SlackBuild" | head -n 1`
  description=`grep -s ^$name: $path/slack-desc`
  requires=`grep -sv ^# $path/requires`
  optional=`grep -sv ^# $path/optional`
  sources=`grep -sv ^# $path/sources | sed "s,[{}],,g;s,\\$NAME,$name,g;s,\\$VERSION,$version,g"`
  blocks=`grep -sve ^# -e ^$ $path/blocks | sort -u`

  # info about cached .tgz-packages
  pkg_file=`find $PKG_DIR/{$group/,} -name $package.tgz 2>/dev/null | head -n 1`
  if [ "$pkg_file" ]; then
    local s=`gzip -l $pkg_file 2>/dev/null | tail -n 1`
    size=`echo $s | awk '{ print $1 }'`
    u_size=`echo $s | awk '{ print $2 }'`
    ((size/=1024))
    ((u_size/=1024))
  else
    size=""
    u_size=""
  fi

  # maintained port?
  maintain=false
  local build=`echo $package | sed -r "s,^.*-(.*)$,\1,"`
  [ "$MY_TAG" ] && case $build in *[0-9]$MY_TAG) maintain=true;; esac
  $MAINTAIN_ALL && maintain=true
  [ -f $path/slot-in ] && slot_in=true || slot_in=false
  [ -f $path/pseudo ] && pseudo=true || pseudo=false
  [ -f $path/no-fakeroot ] && no_fakeroot=true || no_fakeroot=false
  debug "get_info(): finished: $@"
  return 0
}

# check if all required packages are installed
check_reqs()
{
  $NO_REQS && return 0
  local t=`mktemp -d`
  ls_loc -v $exclude | loc2gpkg >$t/avail
  ls_inst >$t/inst
  debug "check_reqs(): starting: $package"
  # remember group and name for a refresh later
  local gpkg=""
  $LAZY_CHECKS && debug "check_reqs(): being lazy"
  debug "check_reqs(): $name requires: "$requires
  local req
  for req in $requires; do
    debug "check_reqs(): checking $req"
    local inst_pkg=`grep -m 1 $(regex $req) $t/inst`
    local avail_pkg=`grep -m 1 $(regex $req) $t/avail | cut -d / -f 2`

    # is any version installed?
    if [ "$inst_pkg" ]; then
      debug "check_reqs(): $req is installed"
      # if not in strict mode then it's sufficient
      $LAZY_CHECKS && continue
    fi

    # anyway, is there an available port?
    if [ "$avail_pkg" ]; then
      debug "check_reqs(): $req available as $avail_pkg"
      # is it up-to-date?
      fgrep -qx $avail_pkg $t/inst && continue
      debug "check_reqs(): call: add_pkg $avail_pkg"
      $DRY_RUN && ! [ "$gpkg" ] && stanza "Preparing for $package:"
      local gpkg=$group/$package
      $DRY_RUN && msg_level=`expr $msg_level + 1`
      if ! add_pkg $avail_pkg; then
        $DRY_RUN && msg_level=`expr $msg_level - 1`
        error "$avail_pkg is broken! Stopping `echo $gpkg | pkg2name | cut -d / -f 2`."
        return 1
      fi
      $DRY_RUN && msg_level=`expr $msg_level - 1`
      $DRY_RUN && row "Requiring $avail_pkg"

      # after that add_pkg we have to refresh
      get_info $gpkg
    elif ! [ "$inst_pkg" ]; then
      error "Cannot find required package $req! Stopping."
      return 1
    fi
  done
  debug "check_reqs(): finished: $package"
  return 0
}

check_blocks() {
  for block in $blocks; do
    if [ "`ls_inst $(regex $block) | head -n 1`" ]; then
      # we have a blocking package installed, exit!
      error "$block is blocking $name. Please uninstall first!"
      return 1
    fi
  done
}

maintainer_mode()
{
  local t=`mktemp -d`
  row "Going maintainer mode"

  # regenerate md5sums and footprint (assume we are in the script dir)
  row "Writing: footprint md5sums requires"
#  rm -rf md5sums
#  rm -rf footprint

  # md5sum only source files, which are symlinks here
  find . -type l | sed "s,^\./,," | sort | xargs -r md5sum >>md5sums
  sort +1 -uo md5sums md5sums

#  # sign md5sums
#  if [ -d ~/.gnupg ] && [ `which gpg` ]; then
#    row "Signing md5sums"
#    cat md5sums | gpg --clearsign >$path/md5sums
#  fi

  # write a file list of the package (remove creation time)
  tar tzvf $TMP/$package.tgz | awk '{ printf "%s %-12s %8s %s\n",$1,$2,$3,$6 }' \
  | sort +3 >footprint

  # explodepkg package tree?
  if ! [ -d $TMP/package-$name ]; then
    # if *this* is file we cannot remove, fail
    rm -f $TMP/package-$name || die
    mkdir $TMP/package-$name
    tar xzf $TMP/$package.tgz -C $TMP/package-$name/
  fi

  # generate requires list
  echo "$requires" >$t/old_req
  find $TMP/package-$name/ -type f | xargs file >$t/ftypes
  { # shared libraries
    grep ":.*ELF" $t/ftypes | cut -d : -f 1 | xargs -r ldd \
    | sed -n "\,=>,s,^.* => \(.*\) (.*)$,\1,p" | sort -u | cut -c 2- | xargs -i echo ^{}
    # perl modules (identify them by man pages when searching /var/log/packages/*)
    grep -ie ":.*perl" -e "\.pm:" $t/ftypes | cut -d : -f 1 \
    | xargs sed -n "s,^\ *use *\([A-Z][a-z][^';<> ]*\).*,\1,p" | xargs -i echo "/man./{}\."
  } | sed "s,/\./,/,g" | grep -lf - $ADM_DIR/packages/* | rev | cut -d / -f 1 \
  | cut -d - -f 4- | rev| pkg2name | rev | cut -d / -f 1 | rev \
  | sed -e "s,-solibs$,," -e "s,^x11$,&\nx11-devel," | grep -v ^$name$ >$t/auto_req_raw
  # perl or python in general?
  grep -qie ":.*perl" -e "\.pm:" $t/ftypes && echo perl >>$t/auto_req_raw
  grep -qie ":.*python" -e "\.py:" $t/ftypes && echo python >>$t/auto_req_raw
  # sort automatic requirements list
  sort -uo $t/auto_req_raw $t/auto_req_raw

  # find and strip ignore list
  ls_inst $ignore | pkg2name | cut -d / -f 2 >$t/ignore
  fgrep -vxf $t/ignore $t/auto_req_raw >$t/auto_req

  # now generate new "requires" file
  touch optional
  fgrep -hxvf optional $t/auto_req $t/old_req | grep -v ^$ | sort -u >requires

  # show a few statistics
  fgrep -xf $t/ignore $t/auto_req_raw | xargs -r echo "  --> Ignoring dependencies:"
  fgrep -xvf $t/old_req requires | xargs -r echo "  --> New dependencies:"
  fgrep -xf optional $t/auto_req | xargs -r echo "  --> Dependant options:"
  fgrep -xvf $t/auto_req requires | fgrep -vxf optional | tee arbitrary \
  | xargs -r echo "  --> Arbitrary dependencies:"

  # check for common mistakes
  grep -woe "usr/\(local/\|etc/\|share/doc/\|share/man/\|info/dir\).*" \
    -e "/$ARCH-slackware-linux-" footprint >$t/check_path
  grep -e "^........w" -e " root/root .*\( \|/\)bin/" footprint >$t/check_perm
  grep -e "-upgraded$" $t/auto_req >$t/check_req
  ls_loc -v $exclude | loc2gpkg | pkg2name | cut -d / -f 2 \
  | fgrep -vxf - $t/auto_req >>$t/check_req
  cat $t/check_path | xargs -r -l echo "WARNING: Check this path:"
  cat $t/check_perm | xargs -r -l echo "WARNING: Check these permissions:"
  cat $t/check_req | xargs -r echo "WARNING: Check these dependencies:"

  # remove empty files
  [ -s arbitrary ] || rm -f arbitrary
  [ -s requires ] || rm -f requires
  [ -s optional ] || rm -f optional
  [ -s md5sums ] || rm -f md5sums
}

# build package
build_pkg()
{
  local t=`mktemp -d`
  stanza "Building $package:"

  if $maintain; then
    local script_opt=""
    warn "Maintainer mode: Modifying files: requires md5sums footprint"
    $rebuild && warn "You shouldn't rebuild. Better change BUILD number!"
  else
    local script_opt="--cleanup"
  fi

  cd `dirname $script` || return 1

#  # assume, all symlinks here are links to source files
#  find -type l | xargs -r rm

  # download the source files
  local src
  for src in $sources; do
    # if the source is a cgi- or php-script, the file name can be
    # written behind a % in sources
    local srcname=`basename "$src" | cut -d % -f 2`
    local src=`echo "$src" | cut -d % -f 1`
    if [ -f $SRC_DIR/$srcname ]; then
      row "$srcname found in $SRC_DIR/"
    else
      row "Downloading $srcname"
      $DRY_RUN || get $src $SRC_DIR/$srcname || return 1
    fi
    if ! $DRY_RUN; then
      ln -s $SRC_DIR/$srcname .
      # check md5sums when non-maintainer-mode
      if ! $maintain && grep -sq " $srcname$" md5sums \
      && ! grep " $srcname$" md5sums | md5sum -c --status 2>/dev/null; then
        error "Integrity checking failed: $srcname"
        return 1
      fi
    fi
  done

#  # check md5sums when non-maintainer-mode
#  if ! $maintain && ! $DRY_RUN && [ -f md5sums ] \
#  && ! md5sum -c md5sums >$t/md5sum 2>&1; then
#    sed -n "/FAILED/s,\(.*\):.*,\1,p" $t/md5sum | xargs -r echo "  --> MD5SUM mismatch:"
#    error "Integrity checking failed!"
#    return 1
#  fi

  # exit when download-only or dry-run
  $download_only && return 0
  $DRY_RUN && row "Executing $script $script_opt"
  $DRY_RUN && return 0

  # build package
  if ! $remaintain; then
    [ -d $TMP/package-$name ] && rm -rf $TMP/package-$name
    rm -f $TMP/$package.tgz

    # find CFLAGS substitution (CFLAGS="$SLKCFLAGS")
    local flags_var=`grep -o "CFLAGS=\\"*\\$[^ ]*" $script | cut -d = -f 2 | tail -n 1 | sed "s,[\"\$],,g"`
    if [ "$flags_var" ]; then
      debug "build_pkg(): use $flags_var for CFLAGS"
    else
      case $package in $name-$version-noarch-*) ;; *)
        $maintain && warn "No CFLAGS variable found! Compiling with default values";;
      esac
      flags_var=CFLAGS
    fi

    # check if the script wants to handle errors on its on ("|| exit 1")
    if grep -sq "|| exit 1$" $script; then
      local sh_opt="-x"
    else
      local sh_opt="-e -x"
    fi

    # execute SlackBuild
    mkdir -p $LOG_DIR
    if ! $no_fakeroot && has_prog fakeroot; then
      # run fakerooted SlackBuild
      row "Executing (fakerooted) $script $script_opt"
      if [ "`whoami`" = "root" ]; then
        row "Dropping privileges, becoming nobody"
        su nobody -c "ARCH=$ARCH $flags_var=\"$CFLAGS\" HOME=$TMP TMPDIR=$TMP \
          PATH=\$PATH:/sbin fakeroot sh $sh_opt $script $script_opt" 2>&1 \
        | tee $LOG_DIR/$name.buildlog >$output
      else
        eval "ARCH=$ARCH $flags_var=\"$CFLAGS\" PATH=\$PATH:/sbin \
          fakeroot sh $sh_opt $script $script_opt" 2>&1 \
        | tee $LOG_DIR/$name.buildlog >$output
      fi
    else
      $no_fakeroot && warn "Fakeroot disabled for this port!" \
      || warn "Please install fakeroot as soon as possible!"
      $prepare_only && warn "Preparing without fakeroot is not a good idea!"
      row "Executing $script $script_opt"
      if [ "`whoami`" != "root" ]; then
        row "Gaining root privileges"
        su -c "ARCH=$ARCH $flags_var=\"$CFLAGS\" sh $sh_opt $script $script_opt" 2>&1 \
        | tee $LOG_DIR/$name.buildlog >$output
      else
        eval "ARCH=$ARCH $flags_var=\"$CFLAGS\" sh $sh_opt $script $script_opt" 2>&1 \
        | tee $LOG_DIR/$name.buildlog >$output
      fi
#      # this is a hack-around for some faulty install scripts
#      chmod 1777 /tmp
    fi

    # success? (this is the most promising test to ensure it worked)
    if ! [ -f $TMP/$package.tgz ]; then
      $VERBOSE || tail $LOG_DIR/$name.buildlog
      error "Compilation failed (see $LOG_DIR/$name.buildlog)!"
      $maintain && ln -sf $LOG_DIR/$name.buildlog PORT_IS_BROKEN
      return 1
    else
      # remove this tag in any case
      rm -f PORT_IS_BROKEN
    fi
  else
    if ! [ "$pkg_file" ]; then
      error "Remaintaining not possible: No package file found!"
      return 1
    fi
    row "Skipping package building"
    cp $pkg_file $TMP/
  fi

  # cruft for maintainers of port scripts :)
  $maintain && maintainer_mode

  # clean up
  row "Moving $package to $PKG_DIR/$group/"
  mkdir -p $PKG_DIR/$group
  mv $TMP/$package.tgz $PKG_DIR/$group/
  row "Cleaning up"
  for src in $sources; do
    local srcname=`basename "$src" | cut -d % -f 2`
    # remove symlinks to sources
    rm -f `dirname $script`/$srcname
    # pseudo ports: don't cache sources
    $pseudo && rm -f $SRC_DIR/$srcname
  done
  $maintain || ( [ -d $TMP/package-$name ] && rm -rf $TMP/package-$name )
}

# really (re)install/upgrade current port
add_pkg() # pkgex
{
  local t=`mktemp -d`

  # track argument and remove if found
  echo $1 >>$ADD_SUM_CALL
  get_info $1 || return 1
  sed -i "\,^$1$,d" $ADD_SUM_CALL

  # if it is already tracked as started and not finished, it is either broken
  # or a circular dependency and should fail now
  if fgrep -sqx "$group/$package" $ADD_SUM_START; then
    debug "add_pkg(): broke up $package intentionally"
    error "Circular dependency! Stopping $name."
    return 1
  fi

  # track as started and skip if we already did that (maybe because of a dependency)
  fgrep -sqx "$group/$package" $ADD_SUM_FINISH && return 0
  echo $group/$package >>$ADD_SUM_START

  # requirements check
  check_reqs || return 1

  # package file found in cache? (first in its group, then other places)
  if ! [ $pkg_file ] || $rebuild; then
    build_pkg || return 1
    pkg_file=$PKG_DIR/$group/$package.tgz
  elif $download_only; then
    stanza "Already built. No need to download source files. Skipping."
  fi

  # track as finished
  echo $group/$package >>$ADD_SUM_FINISH
  sed -i "\,^$group/$package$,d" $ADD_SUM_START
  $download_only && return 0
  $prepare_only && return 0

  # install the package
  if ls_inst -Fqx $package && ! $reinstall; then
    stanza "$package is already installed. Skipping."
    return 0
  fi
  $slot_in && warn "Slot-in: Other releases will stay installed!"

  # what to display?
  ls_inst >$t/inst
  if ! $slot_in && fgrep -qx $package $t/inst; then
    stanza "Reinstalling $package..."
    local add="upgradepkg --reinstall"
  elif ! $slot_in && grep -qm 1 $(regex $name) $t/inst; then
    stanza "Upgrading $name to `echo $package | pkg2rel`..."
    local add="upgradepkg"
  else
    stanza "Installing $package..."
    local add="installpkg"
  fi
  echo $group/$package >>$CACHE/inst
  $DRY_RUN && [ "$msg_level" = "0" ] && echo -e "PACKAGE DESCRIPTION:\n$description"
  $DRY_RUN && return 0

  # call the install-command
  if ! su -c "$add $pkg_file | tee $t/install_log | grep -e ^PACKAGE \
  -e ^$name: -e ^Executing"; then
    cat $t/install_log
    error "Installation failed!"
    return 1
  fi
  return 0
}

# prepare and install ports
do_add() # pkgex-list
{
  debug "do_add(): starting: $@"
  has_args "$@" || die
  has_ports || die
#  is_root || die
  local ret
  local arg
  for arg in `explicit "$@"`; do
    debug "do_add(): \$arg=$arg"
    add_pkg $arg
    ret=$?
  done

  debug "do_add(): finished: $@"
  return $ret
}

do_diff()
{
  local t=`mktemp -d`
  has_ports || die
  local diff_list=`ls_diff`
  [ "$diff_list" ] || die "No differences found."
  stanza "PACKAGE NAME:\r\t\t\t\tAVAILABLE:\r\t\t\t\t\t\t\tINSTALLED:"
  ls_inst >$t/inst
  local pkg
  for pkg in $diff_list; do
    debug "do_diff(): \$pkg=$pkg"
    local avail_rel=`echo $pkg | pkg2rel`
    local name=`echo $pkg | pkg2name`
    local inst_rel=`grep -m 1 $(regex $name) $t/inst | pkg2rel`
    avail=${avail:-$name}
    avail_rel=${avail_rel:-(n/a)}
    echo -e "$name\r\t\t\t\t$avail_rel\r\t\t\t\t\t\t\t$inst_rel"
  done
}

do_export()
{
  has_args "$@" || die
  stanza "Exporting:"

  ( . $CFG_DIR/plugins/export.portpkg )
}

# find ports by pattern
do_find() # text [..] >list
{
  local t=`mktemp -d`
  has_args "$@" || die
  has_ports || die
  find $PRT_DIR/ -follow -name "*slack-desc" >$t/list
  local arg
  for arg; do
    cat $t/list | xargs grep -lsi $arg >$t/list.new
    mv $t/list.new $t/list
  done
  [ -s $t/list ] && do_list `cat $t/list | slk2gname`
}

# print information about a port
do_info() # pkgex-list
{
  has_ports || die
  has_args "$@" || die
  local ret=0
  local arg
  debug "do_info(): starting: $@"
  debug "do_info(): for arg in "`explicit "$@"`
  for arg in `explicit "$@"`; do
    ret=1
    debug "do_info(): testing $arg"
    get_info $arg || continue
    echo
    echo "PACKAGE NAME:  $package"
    [ "$size" ] && echo "COMPRESSED PACKAGE SIZE:  $size K"
    [ "$u_size" ] && echo "UNCOMPRESSED PACKAGE SIZE:  $u_size K"
    [ "$pkg_file" ] && echo "PACKAGE LOCATION:  $pkg_file"
    echo "SCRIPT LOCATION:  $script"
    [ "$requires" ] && echo "PACKAGE REQUIRES:  "$requires | fmt -t 2>/dev/null
    [ "$optional" ] && echo "PACKAGE SUGGESTS:  "$optional | fmt -t 2>/dev/null
    [ "$sources" ] && echo "SOURCE LOCATIONS:  "$sources | fmt -t 2>/dev/null
    [ "$description" ] && echo -e "PACKAGE DESCRIPTION:\n$description"
    ret=0
  done
  debug "do_info(): finished: $@"
  return $ret
}

# list available ports
do_list() # [pkgex-list] >glist
{
  has_ports || die
  # grep arguments
  local regex
  [ "$*" ] && regex=`regex $*` || regex="-v ^$"
  ls_loc $regex 2>/dev/null | loc2gpkg
}

do_sync()
{
  stanza "Syncing your data base:"

  ( . $CFG_DIR/plugins/sync.portpkg )

  # start 3rd-party-importers
  local importer
  for importer in `find $CFG_DIR/importers/* 2>/dev/null`; do
    [ -x $importer ] && $importer
  done

  ( . $CFG_DIR/plugins/sync.zz.cleanup )
}

# upgrade all installed ports that are not available
do_upgrade() # [pkgex-list]
{
  has_ports || die
  local diff_list=`ls_diff | pkg2name`
  [ "$diff_list" ] || die "No upgrades available."
  debug "do_upgrade(): call: do_add $diff_list"
  do_add $diff_list
}

help()
{
  cat <<EOF

Usage: portpkg [action] [options] [list [...]]
  Build and install (or upgrade) a package.
Actions (alternative):
  -d, --diff        Compare installed versions with availables
  -i, --info        View information about specified ports
  -f, --find strs   Find ports by pattern strings
  -l, --list        List available ports
  -s, --sync        Sync local ports tree
  -u, --upgrade     Upgrade all (!) outdated ports (see --diff)
  -v, --version	    View version information
  -x, --export msg  Upload ports to portpkg.berlios.de
Options:
  -e, --reinstall   Reinstall package if already installed
  -b, --rebuild     Rebuild package if already build (implies --reinstall)
  -p, --prepare     Build package, but don't install (implies --noreqs)
  -o, --download    Download source files only
  -g, --verbose	    Show compile/download output
  -y, --dryrun	    Simulate install/build/download/upload
  -q, --noreqs	    Don't install/upgrade dependencies
  -a, --lazy        Don't upgrade dependencies to newest version
  -m, --maintain    Force maintainer mode
Lists:
  group/ or [group/]name[-version-arch-build]
EOF
}

version()
{
  cat <<EOF
    
Portpkg version $ENGINE_VER.
Copyright (C) 2003-2005 Thomas Pfaff <topf at users dot berlios dot de>.
Portpkg comes with ABSOLUTELY NO WARRANTY. This is free software, and you
are welcome to redistribute it under certain conditions.
EOF
}

parse_options()
{
  local shorts="diflsuvhebogyqx:zarpm"
  local longs="diff,info,find,list,sync,upgrade,version,help,reinstall,\
rebuild,download,verbose,dryrun,noreqs,debug,lazy,remaintain,prepare,\
maintain,export:"
  local args
  args=`getopt -qo $shorts -l $longs -- "$@"`
  [ "$?" == "0" ] || die "Bad Arguments! Try: portpkg --help"
  local start_args="$@"
  eval set -- "$args"
  while [ "$1" ]; do
    case $1 in
      -d|--diff)        action=do_diff;;
      -i|--info)      	action=do_info;;
      -f|--find)        action=do_find;;
#                        find_opt=$2
#                        shift;;
      -l|--list)      	action=do_list;;
      -s|--sync)        action=do_sync;;
      -u|--upgrade)     action=do_upgrade;;
      -v|--version)     action=version;;
      -x|--export)      action=do_export
                        export_opt="$2"
                        shift;;
      -h|--help)      	action=help;;
      -e|--reinstall)   reinstall=true;;
      -b|--rebuild)     rebuild=true;;
      -o|--download)    download_only=true;;
      -g|--verbose)   	VERBOSE=true;;
      -y|--dryrun)      DRY_RUN=true;;
      -q|--noreqs)      NO_REQS=true;;
      -z|--debug)       DEBUG=true;;
      -a|--lazy)        LAZY_CHECKS=true;;
      -r|--remaintain)  remaintain=true;;
      -p|--prepare)     prepare_only=true;;
      -m|--maintain)    MAINTAIN_ALL=true;;
      --)               shift
                        break;;
    esac
    shift
  done

  $prepare_only && NO_REQS=true
  $rebuild && reinstall=true
  $remaintain && rebuild=true
  $VERBOSE && output=/dev/stdout

  debug "init(): exclude=\"$exclude\""
  debug "init(): ignore=\"$ignore\""
  debug "init(): ARCH=$ARCH"
  debug "parse_options(): starting: $start_args"
  debug "parse_options(): call: $action $@"

  $NO_REQS && warn "Dependency resolving disabled!"
  $LAZY_CHECKS && warn "Enable lazy dependency checking!"
  $DRY_RUN && warn "Up-/downloading, packaging and installing simulated!"
  $action "$@"

  exit $?
}

init()
{
  # make temporary directory
  [ -d "$TMPDIR" ] || die "Internal error!"

  # clean up on exit
  trap "rm -rf $TMPDIR" EXIT
  trap "" PIPE

  # check
  has_prog sed || die
  case $ARCH in *-*) die "ARCH value not allowed: $ARCH";; esac

  # read mirrors, ignore and exclude
  repos=`grep -vshe ^# -e ^$ $CFG_DIR/repos{.local,} | sed "s,^,$PRT_DIR/,"`
  mirrors=`grep -vshe ^# -e ^$ $CFG_DIR/mirrors{.local,}`
  ignore=`grep -vshe ^# -e ^$ $CFG_DIR/ignore{.local,}`
  exclude=`grep -vshe ^# -e ^$ $CFG_DIR/exclude{.local,}`
  ignore=`regex $ignore`
  exclude=`regex $exclude`

  # if not used as include file then start me
  [ `basename $0` == "portpkg" ] && parse_options "$@"

  return 0
}

init "$@"
