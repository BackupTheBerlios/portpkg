#!/bin/sh -u
#
# Portpkg -- A ports system for Slackware Linux, written in Bash++
# Copyright (C) 2003-2005 Thomas Pfaff <topf at users dot berlios dot de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# default configuration
MAINTAIN_ALL=false
VERBOSE=false
DRY_RUN=false
INTERACTIVE=true
NO_REQS=false
TEST_REQS=false
LAZY_CHECKS=false
DEBUG=false
USE_ALPHA_CODE=false
DOWNLOAD_ONLY=false
PREPARE_ONLY=false
REINSTALL=false
REBUILD=false
REMAINTAIN=false
NO_FAKEROOT=false
ARCH=i486
CFLAGS=""
MY_TAG=`whoami`

SYNC="sync.portpkg sync.slackware-bin sync.zz.cleanup"
EXPORT="export.portpkg"
MIRRORS=""

TMP=/tmp
ADM_DIR=/var/log
CFG_DIR=/etc/portpkg

# find the ports root and some other locations
PRT_ROOT=`until [ -f .ports_root ] || [ "$(pwd)" = "/" ]; do cd ..; done; [ -f .ports_root ] && pwd`
PRT_ROOT=${PRT_ROOT:-`[ "$(whoami)" = "root" ] || echo ~/ports`}
LOG_DIR=${PRT_ROOT:-/var/portpkg}/log
SRC_DIR=${PRT_ROOT:-/usr/src}/dist
PKG_DIR=${PRT_ROOT:-/usr/obj}/pkg
PRT_DIR=${PRT_ROOT:-/usr/ports}

INSTALLPKG=installpkg
UPGRADEPKG=upgradepkg

# include configuration overlay
[ -f $CFG_DIR/local.conf ] && . $CFG_DIR/local.conf
[ -f ~/.portpkg.conf ] && . ~/.portpkg.conf
[ -f $PRT_DIR/portpkg.conf ] && . $PRT_DIR/portpkg.conf

# constant values
ENGINE_VER=cvs
TMPDIR=`mktemp -d $TMP/portpkg-XXXXXX` || exit 1
#export TMPDIR
CACHE=`mktemp -d`

# global variables
package="" name="" group="" path="" script="" description=""
sources="" md5sums="" pkg_file=""
requires="" optional="" blocks="" uses=""
maintain=$MAINTAIN_ALL
no_fakeroot=$NO_FAKEROOT
rebuild=$REBUILD

# internal variables
repos="" ignore="" mirrors="" exclude="" use="" arch_filter=""
output=/dev/null
level_one=true

# listers
ls_inst() { cache $CACHE/inst "find $ADM_DIR/packages/ -type f | sed \"s,^.*/,,\"" "$@"; }
ls_pkg()  { cache $CACHE/pkg "find $PKG_DIR/ -name \"*.tgz\" -follow | sed -r \"s,^$PKG_DIR/(.*)\.tgz$,\1,\"" "$@"; }
if $USE_ALPHA_CODE; then
ls_slk()  { cache $CACHE/slk "find $PRT_DIR/ -name \"*SlackBuild\" 2>/dev/null" "$@"; }
else
ls_slk()  { cache $CACHE/slk "find \$repos -name \"*SlackBuild\" -follow 2>/dev/null" "$@"; }
fi
ls_loc()  { cache $CACHE/loc "ls_slk | slk2loc" "$@"; }

# converters
any2dir()   { sed -r "s,^(.*)/.*$,\1,"; }
any2base()  { sed -r "s,^.*/,,"; }
pkg2name()  { sed -r "s,^(.*)-.*-.*-.*$,\1,"; }
pkg2ver()   { sed -r "s,^.*-(.*)-.*-.*$,\1,"; }
pkg2rel()   { sed -r "s,^.*-(.*-.*-.*)$,\1,"; } 
loc2gpkg()  { sed -r "s,^$PRT_DIR/,,"; }
slk2gname() { sed -r "s,^$PRT_DIR/(.*)[\./]SlackBuild$,\1,"; }
slk2loc()   { xargs grep -sH "^VERSION=\|^ARCH=\|^BUILD=" -m 3 \
  | sed -n "\,:VERSION=,{s,[\./]SlackBuild:VERSION=,-,;N;s,\n.*=,-,;N;s,\n.*=,-,;s,\${ARCH:-[^}]*},$ARCH,;s,\${[A-Z]*:-\([^}]*\)},\1,g};\,$arch_filter,p"; }
# FIXME: preset $BUILD and $VERSION is not supported, only reset!
# TODO: slk2loc should strip ^$PRT_DIR/

# message system
stanza() { $level_one && echo -e "\n$@"; }
row()    { echo -e "  --> $@"; }
warn()   { echo -e "WARNING: $@"; }
error()  { [ "$*" ] && echo -e "$@" >&2; return 1; }
die()    { error "$@"; exit 1; }
debug()  { $DEBUG && echo "$@" >&2; }
pause()  { $INTERACTIVE || return 0; echo -ne "\n$@ " >&2; local s; read s; echo -n $s; }

# checks
has_args()   { [ "$*" ] || error "Too few arguments! Try: portpkg --help"; }
is_root()    { [ "$UID" = "0" ] || error "You must be root to run this action!"; }
has_prog()   { which $1 >/dev/null 2>&1 || error "Cannot find $1!"; }
has_ports()  { [ -d "$PRT_DIR" ] || error "No ports found! Change to your ports tree or try: portpkg --sync"; }
is_integer() { echo "$2  $1" | md5sum -c --status 2>/dev/null || error "Integrity failed: `basename $1`!"; }

# sort a pkg-list by version
sort_ver() # <pkg_list >pkg_list
{
  sed -r "s,-([^-]*)-([^-]*)-([^-]*)$, \1 \2 \3,;\
s,( [^-]*)\.,\1 ,;s,( [^-]*)\.,\1 ,;s,( [^-]*)\.,\1 ,;s,( [^-]*)\.,\1 ," \
| sort -k 2n -k 3n -k 4n -k 5n -k 6n | tac \
| sed -r "s, ,-,;s, ([^ ]*) ([^ ]*)$,-\1-\2,;s, ,.,g"
}

if $USE_ALPHA_CODE; then
# pipe only the "default" package of a list (new style)
default() { sort_ver | head -n 1; }
else
# pipe only the "default" package of a list (old style)
default() { head -n 1; }
fi

# cache the output of "action" and grep a regex
cache() # file action regex
{
  local file=$1 action=$2
  local filter
  shift 2
  [ "$*" ] && filter="grep $@" || filter="cat"
  if ! [ -f $file ]; then
    eval "$action" | tee $file | $filter -
  else
    $filter $file
  fi
}

# download a file and make use of mirrors
get() # url dest [md5sum]
{
  local url=$1 dest=$2 md5sum=${3:-}
  local urls master mirror try
  debug "get() $@"

  # mirrors
  if [ "$mirrors" ]; then
    urls=`echo "$mirrors" | while read master mirror; do \
echo $url | sed -n "s,^$master,$mirror,p"; done | tac`" $url"
  fi

  debug "get(): urls="$urls
  mkdir -p `dirname $dest`

  # try primary url if mirror fails
  for try in $urls; do
    debug "get(): trying $try"
    case $try in
      cvs://*)
        # example: cvs://:pserver:anonymous@anoncvs.gnome.org:/cvs/gnome/rhythmbox
	has_prog cvs || die
        if [ -d $dest/CVS ]; then
          ( cd $dest
          cvs -qz3 up -dP . )
        else
          ( cd `dirname $dest`
          cvs -qz3 -d `echo $try | sed "s,^cvs://,,;s,/[^/]*$,,"` co -P `basename $try` )
        fi
        return 0;;
      *)
        has_prog wget || die
        wget -c -O $dest.part $try || continue
        if [ "$md5sum" ] && ! is_integer $dest.part $md5sum; then
          mv $dest.part $dest.invalid
          continue
        fi
        mv $dest.part $dest
        return 0;;
    esac
  done

  error "Download failed!"
}

# generate a regular expression for grep from a pkgex-list
regex() # >regex_list
{
  local arg
  for arg; do
    case $arg in
      */)
        # groups
        echo -n " -e \(^\|/\)$arg";;
      */*)
        # explicit expression (group/name and group/package)
        echo -n " -e \(^\|/\)${arg%/*}\(/.*/\|/\)${arg#*/}\(\|-[^-]*-[^-]*-[^-]*\)$";;
      *)
        # (g_)names and (g_)packages
        echo -n " -e \(^\|/\)$arg\(\|-[^-]*-[^-]*-[^-]*\)$";;
    esac
  done
  [ $# = 0 ] && echo "-e ^$" || true
}

# resolve groups/ to names
# note: do_list doesn't use explicit()!
explicit() # >pkgex-list
{
  local arg
  for arg; do
    case $arg in
      */) #ls_slk `regex $arg` | slk2gname | any2base
	  ls_slk | slk2gname | grep `regex $arg` | any2base
          # also look through virtual groups list
#          grep -hs `regex $arg` {$CFG_DIR,$PRT_DIR}/virtual | any2base;;
          grep -hs `regex $arg` $CFG_DIR/virtual $PRT_DIR/virtual | any2base;;
      *)  echo $arg;;
    esac
  done
  # direct mode: use current dir
  [ $# = 0 ] && echo "." || true
}

# print non-available, but installed ports
ls_diff() # >list
{
  local t=`mktemp -d`
  local check
  debug "ls_diff(): starting"

  # prepare lists
  ( ls_loc -v $exclude | any2base; ls_inst ) | sort_ver >$t/avail
  ls_inst >$t/inst
  pkg2name <$t/avail >$t/avail.names
  pkg2name <$t/inst >$t/inst.names

  # find package names that installed and in the ports
  fgrep -xf $t/avail.names $t/inst.names \
  | sed "s,.*,&-[^-]*-[^-]*-[^-]*," | while read check; do
    grep -xm 1 "$check" $t/avail >>$t/avail.check
    grep -xm 1 "$check" $t/inst >>$t/inst.check
  done

  # neglect architecture differences for ix86
  sed -i "s,-i.86-,-i.86-," $t/avail.check $t/inst.check

  # find version mismatches therein
  fgrep -vxf $t/inst.check $t/avail.check | grep -xf - $t/avail | sort -u
}

# get information about a port and write it into global variables
get_info() # pkgex
{
  local loc
  debug "get_info() $@"

  case $1 in
    .)   # direct mode: find SlackBuild in current dir
         loc=`find $(pwd)/ -maxdepth 1 -name "*SlackBuild" | slk2loc | default`
         TEST_REQS=true
         debug "Direct mode: Dependencies resolution disabled!";;
    */*) # explicitly named port: no exclude list
         loc=`ls_loc $(regex $1) | default`
         [ "$loc" ] && debug "get_info(): Excluded port specified explicitly!";;
    *)   # find port, take the first if more than one available
         loc=`ls_loc $(regex $1) | grep -v $exclude | default`;;
  esac

  if ! [ "$loc" ]; then
    error "No such port: $1"
    return 1
  fi

  # set global variables
  group=`echo $loc | loc2gpkg | any2dir`
  package=`echo $loc | any2base`
  name=`echo $package | pkg2name`
  version=`echo $package | pkg2ver`
  script=`find $(echo $loc | pkg2name).SlackBuild $(echo $loc | pkg2name)/SlackBuild 2>/dev/null | head -n 1`
  path=`dirname $script`
  description=`grep -she ^$name: -e "^\\$NAME:" $path/slack-desc $script \
| sed "s,\\$NAME,$name,"`
  requires=`{ \
grep -s "^# REQUIRES: " $script | cut -d " " -f 3- | tr " " "\n"; \
grep -sve ^$ -e ^# $path/requires; \
grep -sve ^$ -e ^# $path/slack-required | cut -d " " -f 1; } | sort -u`
  optional=`{ \
grep -s "^# OPTIONAL: " $script | cut -d " " -f 3- | tr " " "\n"; \
grep -sve ^$ -e ^# $path/optional; \
grep -sve ^$ -e ^# $path/slack-suggests | cut -d " " -f 1; \
grep -s "^# opt" $path/requires | sed "s,.* ,,"; } | sort -u`
  sources=`{ \
grep -s "^# SOURCES: " $script | cut -d " " -f 3- | tr " " "\n"; \
grep -sve ^$ -e ^# $path/sources; } | sed "s,[{}],,g;s,\\$NAME,$name,g;s,\\$VERSION,$version,g"`
  md5sums=`grep -sve ^$ -e ^# $path/md5sums`
  blocks=`{ \
grep -s "^# BLOCKS: " $script | cut -d " " -f 3- | tr " " "\n"; \
grep -sve ^$ -e ^# $path/blocks; \
grep -sve ^$ -e ^# $path/slack-conflicts | cut -d " " -f 1; \
grep -s "^# block" $path/requires | sed "s,.* ,,"; } | sort -u`
  uses=`( $NO_REQS || $TEST_REQS ) || ls_loc $(regex $optional) | grep $use | pkg2name | any2base | sort -u`
  pkg_file=`{ \
ls_pkg "^$group/$package$"
ls_pkg "/$package$"; } | sed "s,..*,$PKG_DIR/&.tgz," | head -n 1`
#  [ "$pkg_file" ] && pkg_file=$PKG_DIR/$pkg_file.tgz

  # flags
  maintain=$MAINTAIN_ALL
  [ "$MY_TAG" ] && case $package in *[0-9]$MY_TAG) maintain=true;; esac
#  $MAINTAIN_ALL && maintain=true
  no_fakeroot=$NO_FAKEROOT
  rebuild=$REBUILD
  [ -f $path/no-fakeroot ] && no_fakeroot=true #|| no_fakeroot=false
  [ -f $path/rebuild ] && rebuild=true #|| no_fakeroot=false
  grep -sqx no-fakeroot $path/flags && no_fakeroot=true
  grep -sqx rebuild $path/flags && rebuild=true
  grep -sq "^# FLAGS:.* no-fakeroot\( \|$\)" $script && no_fakeroot=true
  grep -sq "^# FLAGS:.* rebuild\( \|$\)" $script && rebuild=true

  return 0
}

# check if all required packages are installed
check_reqs()
{
  local prev req inst_pkg avail_pkg
  debug "check_reqs(): starting for $package"
  $NO_REQS && return 0
  $LAZY_CHECKS && debug "check_reqs(): being lazy"
  $TEST_REQS && debug "check_reqs(): testing only"
  debug "check_reqs(): $name requires: "$requires
  for req in $requires $uses; do
    debug "check_reqs(): testing $req"
    inst_pkg=`ls_inst $(regex $req) | head -n 1`
    avail_pkg=`$TEST_REQS || ls_loc $(regex $req) | grep -v $exclude | any2base | default`

    # is any version installed?
    if [ "$inst_pkg" ]; then
      debug "check_reqs(): $req is installed ($inst_pkg)"
      # is this sufficient?
      $LAZY_CHECKS && continue
    fi

    # anyway, is there an available port?
    if [ "$avail_pkg" ]; then
      debug "check_reqs(): $req available as $avail_pkg"
      # is it up-to-date?
      ls_inst -qx $avail_pkg && continue
      $DRY_RUN && ! [ "$prev" ] && stanza "Preparing dependencies of $package:"
      prev=$name
      ( $DRY_RUN && level_one=false
      get_info $avail_pkg || exit 1
      add_pkg || die "$avail_pkg is broken! Stopping $prev." ) || return 1
      $DRY_RUN && row "Installing dependency $avail_pkg"
    elif ! [ "$inst_pkg" ]; then
      error "Cannot find required package $req! Stopping."
      return 1
    fi
  done
  return 0
}

check_opts()
{
  local opt all_opts
  for opt in $optional; do
    ls_inst -q `regex $opt` || all_opts="$all_opts $opt"
  done
  [ "$all_opts" ] && warn "Optional dependencies to consider:"$all_opts
  return 0
}

check_blocks()
{
  local block
  for block in $blocks; do
    if ls_inst -q `regex $block`; then
      # we have a blocking package installed, exit!
      error "$block is blocking $name. Please uninstall first!"
      return 1
    fi
  done
}

maintainer_mode()
{
  local t=`mktemp -d`
  local md5 s i
  $maintain || return 0
  has_prog /usr/lib/rpm/find-requires || die

  # regenerate md5sums and footprint
  row "Rewriting: footprint script-header"

  # write a file list of the package (remove creation time and size)
#  tar tzvf $TMP/$package.tgz | awk '{ print $1,$2,$6 }' | sort -k 3 >footprint
  tar tzvf $TMP/$package.tgz | xargs -l | cut -d " " -f 1,2,6 | sort -k 3 | column -t >footprint

  # explodepkg package tree?
  if ! [ -d $TMP/package-$name ]; then
    # if *this* is a file we cannot remove, we must fail
    rm -f $TMP/package-$name || die
    mkdir $TMP/package-$name
    tar xzf $TMP/$package.tgz -C $TMP/package-$name/
  fi

  # generate requires list
  echo "$requires" >$t/old_req
  echo "$optional" >$t/old_opt
  find $TMP/package-$name/ -type f | xargs file >$t/ftypes
  deps() { /usr/lib/rpm/find-requires | sed "/^$/d;s,^perl(\(.*\)).*$,\1.3.gz,"; }
  find $TMP/package-$name/ | deps >$t/deps
  cat $t/deps | grep -wf - $ADM_DIR/packages/* | sed "s,.*:,/," | deps >$t/deps_deps
  { fgrep -vxf $t/deps_deps $t/deps | grep -wlf - $ADM_DIR/packages/* | pkg2name | any2base | grep -v ^$name$
    grep -qie ":.*python" -e "\.py:" $t/ftypes && echo python
  } | sort -u >$t/auto_req_raw

  # find and strip ignore list
#  ls_inst $ignore | pkg2name >$t/ignore
#  fgrep -vxf $t/ignore $t/auto_req_raw >$t/auto_req
  ls_inst $ignore | pkg2name | fgrep -vxf - $t/auto_req_raw >$t/auto_req

  # strip old lists to see what's new
  fgrep -vxf $t/old_req -f $t/old_opt $t/auto_req >$t/new_req

  # if there's alread a "requires" file, add new dependencies as optional
  if [ "$requires" ]; then
    optional=`( echo "$optional"; cat $t/new_req ) | sort -u`
  else
    requires=`( echo "$requires"; cat $t/new_req ) | sort -u`
  fi

  # remove script header
  sed -i "/^#!\/bin\/sh$/d" $script
  for i in MAINTAINER FLAGS BLOCKS OPTIONAL REQUIRES MD5SUMS SOURCES; do
    sed -i "/^# $i:/d" $script
  done

  # write header
#  sed -i "1s,.*,# FLAGS:`$slot_in && echo \ slot-in``$pseudo && echo \ pseudo``$no_fakeroot && echo \ no-fakeroot`\n&," $script
  sed -i "1s,.*,# FLAGS:`$no_fakeroot && echo \ no-fakeroot`\n&," $script
  sed -i "1s,.*,# BLOCKS: $blocks\n&," $script
  sed -i "1s,.*,# OPTIONAL: `echo $optional`\n&," $script
  sed -i "1s,.*,# REQUIRES: `echo $requires`\n&," $script
  echo "$md5sums" | while read md5 s; do
    sed -i "1s,.*,# MD5SUMS: $md5  $s\n&," $script
  done
  for s in $sources; do
    s=`echo $s | sed "s,&,\\\\\&,g"`
    sed -i "1s,.*,# SOURCES: $s\n&," $script
  done
  sed -i "1s,.*,# MAINTAINER: $MY_REALNAME '$MY_TAG' <$MY_EMAIL>\n&," $script
  sed -i "1s,.*,#\!/bin/sh\n&," $script
  for i in MAINTAINER FLAGS BLOCKS OPTIONAL REQUIRES MD5SUMS SOURCES; do
    sed -i "/^# $i: *$/d" $script
  done

  # show a few statistics
  $DEBUG && fgrep -xf $t/ignore $t/auto_req_raw | xargs -r echo "maintainer_mode(): ignored dependencies:" >&2
  xargs -r echo "  --> New dependencies:" <$t/new_req
#  fgrep -xf optional $t/auto_req | xargs -r echo "  --> Dependant options:"
  fgrep -hxvf $t/auto_req $t/new_req $t/old_req \
| xargs -r echo "  --> Arbitrary dependencies (KEEP THIS LIST SHORT):" | fmt

  # check for common mistakes
  { grep -e "-upgraded$" $t/auto_req
    ls_loc -v $exclude | pkg2name | any2base | fgrep -vxf - $t/auto_req
  } | xargs -r echo "WARNING: Check these dependencies:"

  # remove obsolete files
  rm -f arbitrary requires blocks optional slot-in pseudo no-fakeroot flags md5sums sources

  # footprint must be newer than the script for export
  touch $path/footprint
}

# build package
build_pkg()
{
  local t=`mktemp -d`
  local src srcname md5sum script_opt flags_var sh_opt
  stanza "Building $package:"

  if $maintain; then
#    script_opt=""
    warn "Maintainer mode: Modifying files: requires md5sums footprint flags"
    $rebuild && warn "You shouldn't rebuild. Better change BUILD number!"
#    md5sums=""
  else
    script_opt="--cleanup"
  fi

  cd `dirname $script` || return 1

  # download the source files
  for src in $sources; do
    # if the source is a cgi- or php-script, the file name can be
    # written behind a % in sources
    srcname=`basename "$src" | cut -d % -f 2`
    src=`echo "$src" | cut -d % -f 1`
    md5sum=`echo "$md5sums" | grep -s " $srcname$" | cut -d " " -f 1`
    # if $srcname is an existing file (!) it is not CVS and can be skipped
    if [ -f $SRC_DIR/$srcname ]; then
      row "$srcname found in $SRC_DIR/"
    else
      row "Downloading $srcname"
      $DRY_RUN || get $src $SRC_DIR/$srcname $md5sum || return 1
    fi
    if ! $DRY_RUN; then
      ln -sf $SRC_DIR/$srcname .
      # check md5sums when non-maintainer-mode
      if $maintain && [ -f $SRC_DIR/$srcname ]; then
        md5sums=`( echo "$md5sums"; md5sum $srcname ) | sort -u -k 2`
#      elif [ "$md5sum" ]; then
#        is_integer $srcname $md5sum || return 1
#      else
      elif ! [ "$md5sums" ]; then
        warn "No checksums available for $srcname!"
      fi
    fi
  done

  # exit when download-only or dry-run
  $DOWNLOAD_ONLY && return 0
  $DRY_RUN && row "Executing $script $script_opt"
  $DRY_RUN && return 0

  # build package
  if ! $REMAINTAIN; then
    [ -d $TMP/package-$name ] && rm -rf $TMP/package-$name
    rm -f $TMP/$package.tgz

    # find CFLAGS substitution (CFLAGS="$SLKCFLAGS")
    flags_var=`grep -o 'CFLAGS=\"\$[^ ]*' $script | cut -d = -f 2 | tail -n 1 | sed "s,[\"\$],,g"`
    if [ "$flags_var" ]; then
      debug "build_pkg(): use $flags_var for CFLAGS"
    else
      case $package in $name-$version-noarch-*) ;; *)
        $maintain && warn "No CFLAGS variable found! Compiling with default values";;
      esac
      flags_var=CFLAGS
    fi

    # check if the script wants to handle errors on its on ("|| exit 1")
    if grep -sq "|| exit 1$" $script; then
      sh_opt="-x"
    else
      sh_opt="-e -x"
    fi

    # execute SlackBuild
    mkdir -p $LOG_DIR
    if ! $no_fakeroot && has_prog fakeroot; then
      # run fakerooted SlackBuild
      row "Executing (fakerooted) $script $script_opt"
      if [ "`whoami`" = "root" ]; then
        row "Dropping privileges, becoming nobody"
        su nobody -c "ARCH=$ARCH $flags_var=\"$CFLAGS\" HOME=$TMP TMPDIR=$TMP \
PATH=\$PATH:/sbin fakeroot sh $sh_opt $script $script_opt" 2>&1 \
        | tee $LOG_DIR/$name.buildlog >$output
      else
        eval "ARCH=$ARCH $flags_var=\"$CFLAGS\" PATH=\$PATH:/sbin \
fakeroot sh $sh_opt $script $script_opt" 2>&1 \
        | tee $LOG_DIR/$name.buildlog >$output
      fi
    else
      $no_fakeroot && warn "Fakeroot disabled for this port!" \
      || warn "Please install fakeroot as soon as possible!"
      $PREPARE_ONLY && warn "Preparing without fakeroot is not a good idea!"
      row "Executing $script $script_opt"
      if [ "`whoami`" != "root" ]; then
        row "Gaining root privileges"
        su -c "ARCH=$ARCH $flags_var=\"$CFLAGS\" sh $sh_opt $script $script_opt" 2>&1 \
        | tee $LOG_DIR/$name.buildlog >$output
      else
        eval "ARCH=$ARCH $flags_var=\"$CFLAGS\" sh $sh_opt $script $script_opt" 2>&1 \
        | tee $LOG_DIR/$name.buildlog >$output
      fi
#      # this is a hack-around for some faulty install scripts
#      chmod 1777 /tmp
    fi

    # success? (this is the most promising test to ensure it worked)
    if ! [ -f $TMP/$package.tgz ]; then
      $VERBOSE || tail $LOG_DIR/$name.buildlog
      error "Compilation failed (see $LOG_DIR/$name.buildlog)!"
      $maintain && ln -sf $LOG_DIR/$name.buildlog PORT_IS_BROKEN
      return 1
    else
      # remove this tag in any case
      rm -f PORT_IS_BROKEN
    fi
  else
    if ! [ "$pkg_file" ]; then
      error "Remaintaining not possible: No package file found!"
      return 1
    fi
    row "Skipping package building"
    cp $pkg_file $TMP/
  fi

  # cruft for maintainers of port scripts :)
  maintainer_mode | tee -a $LOG_DIR/$name.buildlog

  # clean up
  row "Moving $package to $PKG_DIR/$group/"
  mkdir -p $PKG_DIR/$group
  cp $TMP/$package.tgz $PKG_DIR/$group/
  row "Cleaning up"
  for src in $sources; do
    srcname=`basename "$src" | cut -d % -f 2`
    # remove symlinks to sources
    rm -f `dirname $script`/$srcname
#    # pseudo ports: don't cache sources
#    $pseudo && rm -f $SRC_DIR/$srcname
  done
  gzip -f $LOG_DIR/$name.buildlog
  $maintain || ( [ -d $TMP/package-$name ] && rm -rf $TMP/package-$name )
  true
}

# do some basic checks on the current package
check_pkg()
{
  local t=`mktemp -d`
  local s
  debug "check_pkg()" "$@"
  $DRY_RUN && return 0
  [ -f $pkg_file ] || return 0

  # prepare a file list
#  tar tzvf $pkg_file | awk '{ print $1,$2,$6 }' >$t/footprint
  tar tzvf $pkg_file | xargs -l | cut -d " " -f 1,2,6 >$t/footprint

  # check for common mistakes
  egrep -oe " usr/(local/|etc/|share/pkgconfig/|share/doc/|share/man/|info/dir).*" \
    -e " etc/gconf/gconf\.xml\..*" -e " tmp/.*" -e ".*/$ARCH-slackware-linux-.*" $t/footprint \
  | xargs -r -l echo "WARNING: Unusual entries:"
  egrep -e "^........w" $t/footprint | xargs -r -l echo "WARNING: Unusual flags:"

  # check for files that interfere with other packages
  sed "s,.* ,," $t/footprint | grep -ve /$ -e ^install/ \
  | ( cd $ADM_DIR/packages; fgrep -xf - * ) | grep -v "$name-[^-]*-[^-]*-[^-]*:" \
  | sed -r "s,^(.*):(.*)$,WARNING: \2 interferes with \1,"

  # warn about tags
  case $package in *[0-9]) case $sources in ftp://ftp.slackware.com/*) ;; *)
    warn "No packager tag although not from slackware.com!";;
  esac;; esac

  # list .new files
  grep -wo "etc/.*\.new$" $t/footprint | while read s; do
    [ -f /${s%.new} ] && warn "Consider updating ${s%.new} with $s!"
  done

  # for now, all this is tolerable
  return 0
}

# really (re)install/upgrade current port
add_pkg()
{
  local t=`mktemp -d`
  local add

  # if it is already tracked as "started" (and therefore not "finished"),
  # it is either broken or a circular dependency
  if fgrep -sqx "$group/$package" $t/started; then
    debug "add_pkg(): broke up $package intentionally"
    error "Circular dependency! Stopping $name."
    return 1
  # otherwise if tracked as "finished" (because of a dependency), skip it
  elif fgrep -sqx "$group/$package" $t/finished; then
    return 0
  else
  # else track it as "started"
    echo $group/$package >>$t/started
  fi

  if ls_inst -Fqx $package && ! $REINSTALL; then
    stanza "$package is already installed. Skipping."
    return 0
  fi

  # requirements check
  check_reqs || return 1
  check_opts || return 1
  check_blocks || return 1

  # package file found in cache? (first in its group, then other places)
  if ! [ "$pkg_file" ] || $rebuild; then
    build_pkg || return 1
    # the new package is now here:
    pkg_file=$PKG_DIR/$group/$package.tgz
  elif $DOWNLOAD_ONLY || $PREPARE_ONLY; then
    # tell what's happening
    stanza "Already built. Skipping."
  fi

  # track as "finished", remove from "started" list
  echo $group/$package >>$t/finished
  sed -i "\,^$group/$package$,d" $t/started

  # break-points
  $DOWNLOAD_ONLY && return 0
  $PREPARE_ONLY && return 0

  # install the package
#  $slot_in && warn "Slot-in: Other releases will stay installed!"
  check_pkg || return 1

  # what to display?
#  if ! $slot_in && ls_inst -Fqx $package; then
  if ls_inst -Fqx $package; then
    case `pause "Continue reinstall $package? (s to skip)"` in s|S) continue;; esac
    stanza "Reinstalling $package..."
    add="$UPGRADEPKG --reinstall"
#  elif ! $slot_in && ls_inst -q $(regex $name); then
  elif ls_inst -q $(regex $name); then
    case `pause "Continue upgrade $(ls_inst $(regex $name)) with $package? (s to skip)"` in s|S) continue;; esac
    stanza "Upgrading $name to `echo $package | pkg2rel`..."
    add="$UPGRADEPKG"
  else
    case `pause "Continue install $package? (s to skip)"` in s|S) continue;; esac
    stanza "Installing $package..."
    add="$INSTALLPKG"
  fi

  # update install list cache
  echo $package >>$CACHE/inst

  $DRY_RUN && $level_one && echo -e "PACKAGE DESCRIPTION:\n$description"
  $DRY_RUN && return 0

  # call the install-command
  if ! su -c "$add $pkg_file | tee $t/install_log | grep -e ^PACKAGE -e ^$name: -e ^Executing"; then
    cat $t/install_log
    error "Installation failed!"
#    return 1
  fi
#  return 0
}

# prepare and install ports
do_add() # pkgex-list
{
  local arg ret
  debug "do_add() $@"

  # if we have implicit expressions here (groups), tell what they contain
  case "$@" in */|*/\ *)
    stanza "Targets: "`explicit "$@"` | fmt -t
    pause "Continue? (ctrl-c to abort)";;
  esac

  for arg in `explicit "$@"`; do
    ret=1
    get_info $arg || continue
    add_pkg
    ret=$?
  done

  return $ret
}

do_diff()
{
  local diff_list pkg avail_rel n inst_rel avail

  has_ports || die
  diff_list=`ls_diff`
  [ "$diff_list" ] || die "No differences found."

  stanza "PACKAGE NAME:\r\t\t\t\tAVAILABLE:\r\t\t\t\t\t\t\tINSTALLED:"
  for pkg in $diff_list; do
    debug "do_diff(): \$pkg=$pkg"
    avail_rel=`echo $pkg | pkg2rel`
    n=`echo $pkg | pkg2name`
    inst_rel=`ls_inst $(regex $n) | pkg2rel | head -n 1`
    avail=${avail:-$n}
    avail_rel=${avail_rel:-(n/a)}
    echo -e "$n\r\t\t\t\t$avail_rel\r\t\t\t\t\t\t\t$inst_rel"
  done
}

do_export()
{
  [ "$EXPORT" ] || die "Run pp-config to define export method first!"

  stanza "Exporting:"
  
  if  [ -f $PRT_DIR/plugins/$EXPORT ]; then
    ( . $PRT_DIR/plugins/$EXPORT )
  elif  [ -f $CFG_DIR/plugins/$EXPORT ]; then
    ( . $CFG_DIR/plugins/$EXPORT )
  else
    die "$EXPORT not found!"
  fi
}

# find ports by pattern
do_find() # text [..] >list
{
  local t=`mktemp -d`
  local arg

  has_args "$@" || die
  has_ports || die
  find $PRT_DIR/ -name "*slack-desc" >$t/list 2>/dev/null
  for arg; do
    xargs grep -lsi $arg >$t/list.new <$t/list
    mv $t/list.new $t/list
  done
#  [ -s $t/list ] && do_list `cat $t/list | slk2gname`
  [ -s $t/list ] && do_list `sed "s,[\./][^\./]*$,," $t/list | any2base`
}

# print information about a port
do_info() # pkgex-list
{
  local arg inst ret s size u_size
  has_ports || die

  for arg in `explicit "$@"`; do
    ret=1
    get_info $arg || continue
    ret=0
    inst=`ls_inst $(regex $name)`
    if [ "$pkg_file" ]; then
      s=`gzip -l $pkg_file 2>/dev/null | tail -n 1 | xargs`
#      size=`expr $(echo $s | awk '{ print $1 }') / 1024`
#      u_size=`expr $(echo $s | awk '{ print $2 }') / 1024`
      size=`expr $(echo $s | cut -d " " -f 1) / 1024`
      u_size=`expr $(echo $s | cut -d " " -f 2) / 1024`
    else
      size=""
      u_size=""
    fi
    stanza "PACKAGE NAME:  $package"
    [ "$inst" ] && echo "INSTALLED VERSION:  "$inst | fmt -t
    [ "$size" ] && echo "COMPRESSED PACKAGE SIZE:  $size K"
    [ "$u_size" ] && echo "UNCOMPRESSED PACKAGE SIZE:  $u_size K"
    [ "$pkg_file" ] && echo "PACKAGE LOCATION:  $pkg_file" | fmt -t
    echo "SCRIPT LOCATION:  $script" | fmt -t
    [ "$requires" ] && echo "PACKAGE REQUIRES:  "$requires | fmt -t
    [ "$optional" ] && echo "PACKAGE SUGGESTS:  "$optional | fmt -t
    [ "$uses" ] && echo "PACKAGE USES:  "$uses | fmt -t
    [ "$sources" ] && echo "SOURCE LOCATIONS:  "$sources | fmt -t
    [ "$description" ] && echo -e "PACKAGE DESCRIPTION:\n$description"
  done

  return $ret
}

# list available ports
do_list() # [pkgex-list] >glist
{
  has_ports || die
  case $* in
    "") ls_loc;;
    *)  # grep arguments
        ls_loc `regex "$@"`
        # in order to see virtual groups we list them here also
#        grep -hs `regex "$@"` {$CFG_DIR,$PRT_DIR}/virtual;;
        grep -hs `regex "$@"` $CFG_DIR/virtual $PRT_DIR/virtual;;
  esac | loc2gpkg
}

do_sync()
{
  local importer

  [ "$SYNC" ] || die "Run pp-config to define what to sync!"
  stanza "Syncing your data base:"

  for importer in $SYNC; do
    if [ -f $PRT_DIR/plugins/$importer ]; then
      ( . $PRT_DIR/plugins/$importer )
    elif [ -f $CFG_DIR/plugins/$importer ]; then
      ( . $CFG_DIR/plugins/$importer )
    else
      error "$importer not found!"
      continue
    fi
  done
}

# upgrade all installed ports that are not available
do_upgrade() # [pkgex-list]
{
  local diff_list
  has_ports || die
  diff_list=`ls_diff | pkg2name`
  [ "$diff_list" ] || die "No upgrades available."

  # interactive part
  stanza "Targets: "$diff_list | fmt -t
  pause "Continue? (ctrl-c to abort)"

  do_add $diff_list
}

help()
{
  cat <<EOF

Usage: portpkg [action] [options] [expression [...]]
  Build and install (or upgrade) a package.
Actions (alternative):
  -d, --diff        Compare installed versions with availables
  -i, --info        View information about specified ports
  -f, --find strs   Find ports by pattern strings
  -l, --list        List available ports
  -s, --sync        Sync local ports tree
  -u, --upgrade     Upgrade all (!) outdated ports (see --diff)
  -v, --version	    View version information
  -x, --export msg  Upload ports to portpkg.berlios.de
Options:
  -e, --reinstall   Reinstall package if already installed
  -b, --rebuild     Rebuild package if already build (implies --reinstall)
  -p, --prepare     Build package, but don't install (implies --noreqs)
  -o, --download    Download source files only
  -g, --verbose	    Show compile/download output
  -y, --dryrun	    Simulate install/build/download/upload
  -q, --noreqs	    Don't install/upgrade dependencies
  -a, --lazy        Don't upgrade dependencies to newest version
  -m, --maintain    Force maintainer mode
  -n, --noask       Do not ask for confirmations
Expressions:
  group/ or [group/]name[-version-arch-build]
EOF
}

version()
{
  cat <<EOF
    
Portpkg version $ENGINE_VER.
Copyright (C) 2003-2006 Thomas Pfaff <topf at users dot berlios dot de>.
Portpkg comes with ABSOLUTELY NO WARRANTY. This is free software, and you
are welcome to redistribute it under certain conditions.
EOF
}

parse_options()
{
  local shorts longs args start_args action
  action=do_add
  shorts="diflsuvhebogyqxzarpmn"
  longs="diff,info,find,list,sync,upgrade,version,help,reinstall,\
rebuild,download,verbose,dryrun,noreqs,debug,lazy,remaintain,prepare,\
maintain,export,noask"
  args=`getopt -qo $shorts -l $longs -- "$@"`
  [ "$?" = "0" ] || die "Bad Arguments! Try: portpkg --help"
  start_args="$@"
  eval set -- "$args"
  while [ "$1" ]; do
    case $1 in
      -d|--diff)        action=do_diff;;
      -i|--info)      	action=do_info;;
      -f|--find)        action=do_find;;
      -l|--list)      	action=do_list;;
      -s|--sync)        action=do_sync;;
      -u|--upgrade)     action=do_upgrade;;
      -v|--version)     action=version;;
      -x|--export)      action=do_export;;
      -h|--help)      	action=help;;
      -e|--reinstall)   REINSTALL=true;;
      -b|--rebuild)     REBUILD=true;;
      -o|--download)    DOWNLOAD_ONLY=true;;
      -g|--verbose)   	VERBOSE=true;;
      -y|--dryrun)      DRY_RUN=true;;
      -q|--noreqs)      NO_REQS=true;;
      -z|--debug)       DEBUG=true;;
      -a|--lazy)        LAZY_CHECKS=true;;
      -r|--remaintain)  REMAINTAIN=true;;
      -p|--prepare)     PREPARE_ONLY=true;;
      -m|--maintain)    MAINTAIN_ALL=true;;
      -n|--noask)       INTERACTIVE=false;;
      --)               shift
                        break;;
    esac
    shift
  done

  $PREPARE_ONLY && TEST_REQS=true
  $REBUILD && REINSTALL=true
  $REMAINTAIN && REBUILD=true
  $DRY_RUN && INTERACTIVE=false
  $VERBOSE && output=/dev/stdout

  debug "init(): arch_filter=\"$arch_filter\""
  debug "init(): repos=\""$repos"\""
  debug "init(): exclude=\"$exclude\""
  debug "init(): ignore=\"$ignore\""
  debug "init(): use=\"$use\""
  debug "init(): ARCH=$ARCH"
  debug "init(): PRT_DIR=$PRT_DIR"
  debug "init(): SRC_DIR=$SRC_DIR"
  debug "init(): PKG_DIR=$PKG_DIR"
  debug "init(): LOG_DIR=$LOG_DIR"
  debug "parse_options() $start_args"

  $NO_REQS && warn "Dependency resolving disabled!"
  $LAZY_CHECKS && warn "Enable lazy dependency checking!"
  $DRY_RUN && warn "Up-/downloading, packaging and installing simulated!"

  $action "$@"
  exit $?
}

init()
{
  # make/check temporary directory
  [ "$TMP" ] || die "TMP is emtpy!"
  [ "$TMP" = "/" ] && die "TMP cannot be /"
  [ -d "$TMP" ] || die "Internal error!"

  # clean up on exit
  trap "rm -rf $TMPDIR" EXIT
  # (this seems to be obsolete in Bash-3.1 - can any-one comfirm this?)
  case $BASH_VERSION in 3.1.*) ;; *) trap "" PIPE;; esac

  # check
#  has_prog sed || die
  case $ARCH in
    i?86) arch_filter="-\(i.86\|noarch\)-[^-]*$";;
    *-*)  die "ARCH value not allowed: $ARCH";;
    "")   die "ARCH is empty";;
    *)    arch_filter="-\($ARCH\|noarch\)-[^-]*$";;
  esac
  [ "`whoami`" = "root" ] && warn "You are root! Please run portpkg as unprivileged user!"

  # read mirrors, ignore and exclude
#  repos=`grep -vshe ^# -e ^$ {$CFG_DIR,$PRT_DIR}/repos{.local,} | sed "s,^,$PRT_DIR/,"`
  repos=`grep -vshe ^# -e ^$ $CFG_DIR/repos $PRT_DIR/repos | sed "s,^,$PRT_DIR/,"`
#  mirrors=`grep -vshe ^# -e ^$ {$CFG_DIR,$PRT_DIR}/mirrors{.local,.$MIRRORS,}`
  mirrors=`grep -vshe ^# -e ^$ $CFG_DIR/mirrors.$MIRRORS $CFG_DIR/mirrors $PRT_DIR/mirrors $CFG_DIR/mirrors.$MIRRORS`
#  ignore=`grep -vshe ^# -e ^$ {$CFG_DIR,$PRT_DIR}/ignore{.local,}`
  ignore=`grep -vshe ^# -e ^$ $CFG_DIR/ignore $PRT_DIR/ignore`
#  exclude=`grep -vshe ^# -e ^$ {$CFG_DIR,$PRT_DIR}/exclude{.local,}`
  exclude=`grep -vshe ^# -e ^$ $CFG_DIR/exclude $PRT_DIR/exclude`
#  use=`grep -vshe ^# -e ^$ {$CFG_DIR,$PRT_DIR}/use{.local,}`
  use=`grep -vshe ^# -e ^$ $CFG_DIR/use $PRT_DIR/use`
  repos=${repos:-$PRT_DIR}
  ignore=`regex $ignore`
  exclude=`regex $exclude`
  use=`regex $use`

  # if not used as include file then start me
  [ "`basename $0 2>/dev/null`" = "portpkg" ] && parse_options "$@"

  return 0
}

init "$@"
