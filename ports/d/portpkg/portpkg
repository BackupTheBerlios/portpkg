#!/bin/bash -u
#
# Portpkg - A portssystem for Slackware written in Bash++
# Copyright (C) 2003, 2004 Thomas Pfaff <toastbrot@web.de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# default settings
ENGINE_VER=current
SCRATCH_DIR=/tmp/portpkg-`whoami`-$$
ADM_DIR=/var/log
SRC_DIR=/usr/src/dist
PKG_DIR=/usr/obj/pkg
PRT_DIR=/usr/ports

# default options
action=do_add
download_only=false
reinstall=false
rebuild=false
verbose=false
dry_run=false
no_reqs=false
debug=${debug:-false}
output=/dev/null

# global variables
declare ignore mirrors exclude
declare package name group
declare script description requires size sources
declare fake_inst=$SCRATCH_DIR/fake_inst

# converters
pkg2name()	{ sed -r "s,^(.*)-.*-.*-.*$,\1,"; }
pkg2ver()	{ sed -r "s,^.*-(.*)-.*-.*$,\1,"; }
pkg2rel()	{ sed -r "s,^.*-(.*-.*-.*)$,\1,"; } 
loc2gpkg()	{ sed -r "s,^.*/(.*/.*)$,\1,"; }

# message system
stanza()	{ [ "$*" ] && echo -e "\n$@"; }
row()		{ echo -e "  --> $@"; }
warn()		{ echo -e "WARNING: $@"; }
error()		{ [ "$*" ] && stanza "$@" >&2; return 1; }
die()		{ error "$@"; exit 1; }

if $debug; then
debug()		{ echo $@ >&2; }
else
debug()		{ :; }
fi

# checks
has_args()	{ [ "$*" ] || error "Too few arguments! Try: portpkg --help"; }
is_root()	{ [ "$UID" == "0" ] || error "You must be root to run this action!"; }
has_pkg()	{ ls_inst | grep -q "^$1." || error "You need $1.0 or newer!"; }
has_ports()	{ [ -d $PRT_DIR ] || error "No ports found! Try: portpkg --sync"; }
is_inst()	{ [ -f $ADM_DIR/packages/$1 ] || fgrep -sqx $1 $fake_inst; }

# file utils
ls_inst()	{ find $ADM_DIR/packages/ -type f | sed "s,^.*/,," 2>/dev/null; cat $fake_inst; }
ls_cache()	{ find $PKG_DIR/ -name "*.tgz" | sed -r "s,^.*/(.*/.*)\.tgz$,\1," 2>/dev/null; }

# download a file
get()
{
    local url=$1 dest=$2
    has_pkg wget-1.9 || die
    mkdir -p `dirname $dest`
    # mirrors
    if [ "$mirrors" ]; then
	debug "get(): we have mirrors"
	echo "$mirrors" >$t.mirrors
        local master mirror
        while read master mirror; do
	    debug "get(): checking for $master $mirror"
	    url=`echo $url | sed "s,^$master,$mirror,"`
	done <$t.mirrors
    fi
    debug "get(): \$url=$url"
    if wget -c -O $dest.part $url 2>&1; then
	mv $dest.part $dest
    else
	error "Download failed!"
    fi
}

# prepare a unique scratch-dir or -file
private() # >filename
{
    local file=$SCRATCH_DIR/$RANDOM
    rm -rf $file
    echo $file
}

# generate a regular expression for grep from a pkgex-list
regex() # >regex_list
{
    local arg
    for arg; do
	case $arg in
	    */)	# groups
		echo -n " -e ^$arg";;
	    *)	# (g_)names and (g_)packages
		echo -n " -e ^$arg-[^-]*-[^-]*-[^-]*$"
		echo -n " -e /$arg-[^-]*-[^-]*-[^-]*$"
		echo -n " -e ^$arg$"
		echo -n " -e /$arg$";;
	esac
    done
    [ "$#" = "0" ] && echo "-e ^$"
}

# resolve groups/ to names
# note: do_list doesn't use explicit()!
explicit() # >pkgex-list
{
    local arg
    for arg; do
	case $arg in
	    */)	do_list $arg | pkg2name | cut -d / -f 2;;
	    *)	echo $arg;;
	esac
    done
}

# list all available ports
ls_locations()
{
    local cache=$SCRATCH_DIR/loc_cache
    if [ -f $cache ]; then
	cat $cache 2>/dev/null
	return
    fi
    find $PRT_DIR/ -follow -mindepth 3 -name "*SlackBuild" \
    | xargs egrep -sH "^VERSION=|^ARCH=|^BUILD=" \
    | tr "\n" " " | sed -r \
    -e "s,/[^/]*SlackBuild:VERSION=,-,g" \
    -e "s, [^ ]*:ARCH=,-,g" \
    -e "s, [^ ]*:BUILD=,-,g" \
    -e "s,\\$\{[A-Z]*:[-=],,g" \
    -e "s,},,g" \
    | tr " " "\n" \
    | sort \
    | tee $cache 2>/dev/null
}

# print non-available, but installed ports
ls_diff() # >list
{
    debug "ls_diff(): starting"
    local t=`private`
    debug "ls_diff(): call: ls_avail"
    ls_locations | loc2gpkg | grep -v $exclude | cut -d / -f 2 >$t.avail
    debug "ls_diff(): call: ls_inst"
    ls_inst >$t.inst
    debug "ls_diff(): call: pkg2name"
    pkg2name <$t.avail >$t.avail.names
    pkg2name <$t.inst >$t.inst.names
    debug "ls_diff(): call: fgrep"
    fgrep -xf $t.avail.names $t.inst.names >$t.check.names
    debug "ls_diff(): call: regex"
    local name
    while read name; do
#	grep -m 1 `regex $name` $t.avail >>$t.avail.check
#	grep -m 1 `regex $name` $t.inst >>$t.inst.check
	grep -m 1 "^$name-[^-]*-[^-]*-[^-]*$" $t.avail >>$t.avail.check
	grep -m 1 "^$name-[^-]*-[^-]*-[^-]*$" $t.inst >>$t.inst.check
    done <$t.check.names
    debug "ls_diff(): call: fgrep"
    fgrep -vxf $t.inst.check $t.avail.check
    debug "ls_diff(): finished"
}

# get information about a port and write it into global variables
get_info()
{
    debug "get_info(): start: $@"
    # if there are more than one, take the first
    local url=`ls_locations | grep -m 1 $(regex $1)`
    if ! [ "$url" ]; then
	error "No such port: $1"
	return 1
    fi
    local gpkg=`echo $url | loc2gpkg`
    group=`echo $gpkg | cut -d / -f 1`
    package=`echo $gpkg | cut -d / -f 2`
    name=`echo $package | pkg2name`
    version=`echo $package | pkg2ver`
    script=`find $(dirname $url)/$name -name "*SlackBuild" | head -n 1`
    local path=`echo $script | rev | cut -d / -f 2- | rev`
    # remove ' and " from description
    description=`grep -s ^$name: $path/slack-desc | sed "s,['\"],,g" | cut -d : -f 2- | cut -d " " -f 2-`
    requires=`grep -sv ^# $path/requires`
    sources=`grep -sv ^# $path/sources | sed "s,\\$VERSION,$version,g"`
    depends=`fgrep -sxl $name $path/../../*/*/requires | rev | cut -d / -f 2 | rev`
    size=`du $PKG_DIR/$group/$package.tgz 2>/dev/null | cut -f 1`
    debug "get_info(): end: $@"
    return 0
}

# check if all required packages are installed
check_reqs()
{
    $no_reqs && return 0
    local avail=$SCRATCH_DIR/avail_cache
    [ -f $avail ] || ls_locations | loc2gpkg >$avail
    debug "check_reqs(): starting: $package"
    # remember that for later
    local gpkg=$group/$package
    local refresh=false
    local req
    debug "check_reqs(): \$requires="$requires
    for req in $requires; do
	debug "check_reqs(): \$req=$req"
	local avail_pkg=`grep -m 1 $(regex $req) $avail | cut -d / -f 2`
	if [ "$avail_pkg" ]; then
	    debug "check_reqs(): \$avail_pkg=$avail_pkg"
	    is_inst $avail_pkg && continue
	    debug "check_reqs(): call: add_pkg $req"
	    if ! add_pkg $req; then
		error "$req is broken! Stopping."
		return 1
	    fi
	elif ! [ `ls_inst | grep -m 1 $(regex $req)` ]; then
	    error "Cannot find required package $req! Stopping."
	    return 1
	else
	    debug "check_reqs(): $req is sufficient and installed"
	fi
	refresh=true
    done
    # refresh info
    $refresh && get_info $gpkg
    debug "check_reqs(): finished: $package"
    return 0
}

# build package by SlackBuild
build_pkg()
{
    local t=`private`
    local path=`dirname $script`
    stanza "Building $package:"
    # check ports directory
    if ! [ -f $script ]; then
    	error "Strange: SlackBuild not found!"
	return 1
    fi
    # check SlackBuild header (this is for ls_avail)
    if [ "`egrep -o "^VERSION=|^ARCH=|^BUILD=" $script | xargs`" != "VERSION= ARCH= BUILD=" ]; then
	error "Malformed SlackBuild-header (VERSION, ARCH, BUILD)!"
	return 1
    fi
    # switch to maintainer mode if $rel end with -[0-9]*$MY_TAG
    local maintain=false
    if [ "$MY_TAG" ]; then
	local rel=`echo $package | pkg2rel`
	case $rel in *-[0-9]*$MY_TAG) maintain=true;; esac
    fi
    $MAINTAIN_ALL && maintain=true
    $maintain && warn "Maintainer mode: Port scripts will be modified!"
    $rebuild && warn "You shouldn't rebuild. Better change BUILD number!"
    # prepare build directory in /tmp
    mkdir -p $t.script/$name
    cd $t.script/$name/
    cp -a $path/* .
    # download the source files
    local src
    for src in $sources; do
	# if the source is a cgi- or php-script, the file name can be
	# written behind a % by the maintainer
	local srcname=`basename "$src" | cut -d % -f 2`
	local src=`echo "$src" | cut -d % -f 1`
	if [ -f $SRC_DIR/$srcname ]; then
	    row "$srcname found in $SRC_DIR/"
	else
	    if $dry_run; then
		row "Would have downloaded $src"
	    else
		row "Downloading $srcname"
		get $src $SRC_DIR/$srcname || return 1
	    fi
	fi
	# pseudo ports: don't cache sources
	if [ -f $path/pseudo ]; then
	    mv $SRC_DIR/$srcname .
	else
	    ln -s $SRC_DIR/$srcname .
	fi
    done
    $download_only && return 0
    if $dry_run; then
	row "Would have build $package"
	return 0
    fi
    # build package
#    if which fakeroot >/dev/null 2>&1; then
#	warn "fakeroot enabled: on problems remove it to disable"
#	local root="fakeroot -- sh -c PATH=/usr/local/sbin:/usr/sbin:/sbin:$PATH"
#    else
	local root="su -c"
#    fi
    row "Executing $script"
    $root "rm -rf /tmp/buildlog-$name
           rm -rf /tmp/$package.tgz
           sh $script 2>&1 | tee /tmp/buildlog-$name >$output" || return 1
    $maintain && cp /tmp/buildlog-$name $path/buildlog
    # success?
    if ! [ -f /tmp/$package.tgz ]; then
    	$verbose || tail /tmp/buildlog-$name
	error "Compilation failed (see /tmp/buildlog-$name)!"
	$maintain && touch $path/PORT_IS_BROKEN
	return 1
    fi
    # stuff for maintainers of port scripts :)
    if $maintain; then
	rm -rf $path/PORT_IS_BROKEN
	# is there a build tree?
	if [ -d /tmp/package-$name ]; then
	    # check libraries (don't log the package itself,
	    # aaa_base and aaa_elflibs, gcc and co.,
	    # glibc-derivates and all -solibs)
	    row "Finding requirements"
	    find /tmp/package-$name/ | xargs file | grep ELF \
	    | cut -d : -f 1 | xargs ldd 2>/dev/null | grep -o "/[^ ]*\.so" \
	    | sed -r "s,\./,," | cut -c 2- | sort -u | grep -lf - $ADM_DIR/packages/* \
	    | sed -r "s,^$ADM_DIR/packages/,," | pkg2name | sed -r \
            -e "s,-solibs$,," -e "s,^x11$,&\nx11-devel," \
	    | grep -ve ^$name$ $ignore | sort -u >$t.bin_req
	    echo "$requires" >$t.old_req
	    # now merge into old requirements-list
	    cat $t.bin_req $t.old_req | grep -v ^$ | sort -u >$t.new_req
	    # update requires
	    cat $t.new_req >$path/requires
	    # show tracked dependencies that are not binary
	    local diffs=`diff -u $t.old_req $t.bin_req | grep ^[-][^-] | cut -c 2-`
	    if [ "$diffs" ]; then
		row "Arbitrary requirements: "$diffs
		echo "$diffs" >$path/arbitrary
	    else
		rm -f $path/arbitrary
	    fi
	fi
	# write the footprint
	tar tzvf /tmp/$package.tgz | sort +5 >$path/footprint
	# write the diff: SlackBuild compared to a generic one
	grep -sv "^#" $PRT_DIR/SlackBuild | diff -bu - $script >$path/diff
    fi
    row "Moving $package to $PKG_DIR/$group/"
    mkdir -p $PKG_DIR/$group
    cp /tmp/$package.tgz $PKG_DIR/$group/
}

# really (re)install/upgrade current port
add_pkg() # tgz
{
    local t=`private`
    get_info $1 || continue
    # requirements check (flat, no versions)
    # (...well, a little deeper now :) )
    # (...quite deep now :) )
    check_reqs || continue
    # package file found in cache? (first in its group, then other places)
    local file=`find $PKG_DIR/{$group/,} -name $package.tgz 2>/dev/null | head -n 1`
    if ! [ $file ] || $rebuild; then
        build_pkg || continue
    elif [ "$file" != "$PKG_DIR/$group/$package.tgz" ]; then
        stanza "$package should be in $group/. Moving..."
        mkdir -p $PKG_DIR/$group
        mv $file $PKG_DIR/$group/
    fi
    if ! $download_only; then
        # install the package
        if is_inst $package && ! $reinstall; then
	    stanza "$package is already installed. Skipping."
	else
	    if $dry_run; then
		stanza "Would have installed $package."
		echo $package >>$fake_inst
		return 0
	    fi
	    if ! [ -f $PKG_DIR/$group/$package.tgz ]; then
	        error "Strange: $package.tgz not found."
	        return 1
	    fi
	    # what to display?
	    if is_inst $package; then
	        stanza "Reinstalling $package..."
	    elif [ "`ls_inst | grep $(regex $name)`" ]; then
	        stanza "Upgrading $name to `echo $package | pkg2rel`..."
	    else
    	        stanza "Installing $package..."
	    fi
	    # commercials to fill the time gap
	    $verbose || echo "$description" | sed "s,^,$name: ,"
	    # call the magic all-in-one install-command
	    if ! su -c "upgradepkg --install-new --reinstall \
		$PKG_DIR/$group/$package.tgz | tee $t.install_log >$output"; then
    	        $verbose || cat $t.install_log
	        error "Installation failed!"
	        return 1
	    fi
	fi
    fi
    return 0
}

# prepare and install ports
do_add() # pkgex-list
{
    debug "do_add(): starting: $@"
    has_args $@ || die
#    is_root || die
    has_ports || die
    local sum=$SCRATCH_DIR/sum
    local ret=0
    local arg
    for arg in `explicit $@`; do
   	ret=1
	debug "do_add(): \$arg=$arg"
	echo $arg >>$sum
        add_pkg $arg || continue
	echo $group/$package >>$sum.finished
	sed -i "/^$arg$/d" $sum
	ret=0
    done
    # summary
    if $verbose; then
        stanza "Summary:"
	touch $sum.finished
	cat $sum.finished | xargs -r -l echo "  --> Added successfully"
	cat $sum | xargs -r -l echo "  --> Failed at"
    fi
    debug "do_add(): finished: $@"
    return $ret
}

do_diff()
{
    local t=`private`
    has_ports || die
    local diff_list=`ls_diff`
    [ "$diff_list" ] || die "No differences found."
    stanza "PORT NAME:\r\t\t\t\tAVAILABLE:\r\t\t\t\t\t\t\tINSTALLED:"
    ls_inst >$t.inst
    ls_locations | loc2gpkg >$t.avail
    local pkg
    for pkg in $diff_list; do
	local avail_rel=`echo $pkg | pkg2rel`
	local name=`echo $pkg | pkg2name`
	local avail=`grep -m 1 $(regex $name) $t.avail | pkg2name`
	local inst_rel=`grep -m 1 $(regex $name) $t.inst | pkg2rel`
	avail=${avail:-$name}
	avail_rel=${avail_rel:-(n/a)}
	echo -e "$avail\r\t\t\t\t$avail_rel\r\t\t\t\t\t\t\t$inst_rel"
    done
}

# find ports by pattern
do_find() # text [..] >list
{
    local t=`private`
    has_ports || die
    local arg
    for arg; do
        find $PRT_DIR/ -follow -name slack-desc | xargs grep -shi $arg
    done | grep "^[^ ]*: " | cut -d : -f 1 | sort -u >$t.list
    [ -s $t.list ] && do_list `cat $t.list`
}

# print information about a port
do_info() # pkgex-list
{
    has_ports || die
    has_args $@ || die
    local ret=0
    local arg
    for arg in `explicit $@`; do
	ret=1
	get_info $arg || continue
	local desc=`echo "$description" | head -n 1`
	echo
	echo "PORT NAME:       $group/$package"
	echo "COMPRESSED SIZE: ${size:-(n/a)} K"
	echo "LOCATION:        $script"
	echo "DESCRIPTION:     ${desc:-(n/a)}"
	echo "REQUIREMENTS:    "${requires:-(n/a)}
	echo "DEPENDENCIES:    "${depends:-(n/a)}
	echo "SOURCES:         "${sources:-(n/a)}
	ret=0
    done | fmt -t
    return $ret
}

# list available ports (gives a glist)
do_list() # [pkgex-list] >glist
{
    has_ports || die
    # grep arguments
    if [ "$*" ]; then
    	ls_locations | loc2gpkg | grep `regex $@` 2>/dev/null
    else
    	ls_locations | loc2gpkg
    fi
}

do_sync()
{
    is_root || die
    has_pkg cvs-1.11 || die
    local cvsroot=:pserver:anonymous@cvs.portpkg.berlios.de:/cvsroot/portpkg
    stanza "Syncing your ports tree with `echo $cvsroot | cut -d @ -f 2 | cut -d : -f 1`:"
    local file
    if [ -d $PRT_DIR ]; then
        cd $PRT_DIR || die
	cvs -qz3 up -dPC -I footprint -I diff -I buildlog \
	-I PORT_IS_BROKEN -I arbitrary -I local -I "*.local" 2>/dev/null
    else
	mkdir -p $PRT_DIR
        cd `dirname $PRT_DIR` || die
	cvs -qz3 -d $cvsroot co -Pd `basename $PRT_DIR` ports 2>/dev/null
    fi | sed -r \
    -e "s,^.*$,  --> &," \
    -e "s, U , Updating ," \
    -e "s, C , Conflict with ," \
    -e "s, P , Patching ," \
    -e "s, \? , Unknown file ,"
#    -e "/\(.*\)/d" \
}

# upgrade all installed ports that are not available
do_upgrade() # [pkgex-list]
{
    debug "do_upgrade(): starting: $@"
    has_ports || die
    debug "do_upgrade(): call: ls_diff"
    local diff_list=`ls_diff | pkg2name`
    [ "$diff_list" ] || die "No upgrades available."
    debug "do_upgrade(): call: do_add $diff_list"
    do_add $diff_list
}

help()
{
    cat <<EOF

Usage: portpkg [action] [options] [list ...]
  Build and install (or upgrade) a port.
Actions:
  -d, --diff		Compare installed versions with availables
  -i, --info		View information about ports
  -f, --find		Find ports by pattern
  -l, --list		List available ports
  -s, --sync		Sync your ports tree with the global
  -u, --upgrade		Upgrade all (!) outdated ports
  -v, --version		View version information
Options:
  -e, --reinstall	Reinstall port if already installed
  -b, --rebuild		Rebuild port if alread build
  -o, --download	Download source files only
  -g, --verbose		Show compile output
  -y, --dryrun		Don't install/download/build
  -q, --noreqs		Don't check for requirements
Declaration:
  list: group/ or [group/]name[-version-arch-build]
EOF
}

version()
{
    cat <<EOF
	
Portpkg version $ENGINE_VER.
Copyright (C) 2003, 2004 Thomas Pfaff <toastbrot@web.de>.
This programme comes with ABSOLUTELY NO WARRANTY. This is free software, and
you are welcome to redistribute it under certain conditions.
EOF
}

parse_options()
{
    debug "parse_options(): starting: $@"
    local args
    local shorts="diflsuvhebogyq"
    local longs="diff,info,find,list,sync,upgrade,version,help,reinstall,\
rebuild,download,verbose,dryrun,noreqs"
    args=`getopt -quo $shorts -l $longs -- "$@"`
    [ "$?" == "0" ] || die "Bad Arguments! Try: portpkg --help"
    eval set -- "$args"
    while [ "$1" ]; do
    	case $1 in
	    -d|--diff)		action=do_diff;;
	    -i|--info)		action=do_info;;
	    -f|--find)		action=do_find;;
	    -l|--list)		action=do_list;;
	    -s|--sync)		action=do_sync;;
	    -u|--upgrade)	action=do_upgrade;;
	    -v|--version)	action=version;;
	    -h|--help)		action=help;;
	    -e|--reinstall)	reinstall=true;;
	    -b|--rebuild)	rebuild=true;;
	    -o|--download)	download_only=true;;
	    -g|--verbose)	verbose=true;;
	    -y|--dryrun)	dry_run=true;;
	    -q|--noreqs)	no_reqs=true;;
	    --)			shift
				break;;
	esac
	shift
    done
    $rebuild && reinstall=true
    $verbose && output=/dev/stdout
    debug "parse_options(): call: $action $@"
    $action $@
    exit $?
}

init()
{
    debug "init(): starting"
    # make temporary directory
    case $SCRATCH_DIR in ""|"/") die "Internal error!";; esac
    rm -rf $SCRATCH_DIR
    mkdir -p $SCRATCH_DIR
    chmod 700 $SCRATCH_DIR
    [ -d $SCRATCH_DIR ] || die "Internal error!"
    touch $fake_inst
    # clean up on exit
    trap "rm -rf $SCRATCH_DIR" EXIT
    trap "" PIPE
    # check requirements
    has_pkg sed-4 || die
    has_pkg coreutils-5.2 || die
    # prepare the exclude pattern
    [ -f $PRT_DIR/local.conf ] && source $PRT_DIR/local.conf
    MY_TAG=${MY_TAG:-}
    MAINTAIN_ALL=${MAINTAIN_ALL:-false}
    # global configs
    mirrors=`grep -vshe ^# -e ^$ $PRT_DIR/mirrors{,.local}`
    ignore=`grep -vshe ^# -e ^$ $PRT_DIR/ignore{,.local}`
    ignore=`regex $ignore`
    exclude=`grep -vshe ^# -e ^$ $PRT_DIR/exclude{,.local}`
    exclude=`regex $exclude`
    # check obsolete dirs
    if [ -d ~/ports ]; then
	warn "~/ports is obsolete! Move to $PRT_DIR!"
	PRT_DIR=~/ports
    fi
    if [ -d ~/sources ]; then
	warn "~/sources is obsolete! Move to $SRC_DIR!"
	SRC_DIR=~/sources
    fi
    if [ -d ~/packages ]; then
	warn "~/packages is obsolete! Move to $PKG_DIR!"
	PKG_DIR=~/packages
    fi
    # if not used as include file, start me
    [ `basename $0` == "portpkg" ] && parse_options $@
    return 0
}

init $@
