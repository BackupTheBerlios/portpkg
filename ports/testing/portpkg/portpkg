#!/bin/sh -ue
#
# Portpkg -- A ports system for Slackware Linux, written in Bash++
# Copyright (C) 2003-2005 Thomas Pfaff <topf at users dot berlios dot de>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# include host-specific configuration overlay
[ -f /etc/portpkg/local.conf ] && . /etc/portpkg/local.conf
[ -f ~/.portpkg.conf ] && . ~/.portpkg.conf

# default configuration
MAINTAIN_ALL=${MAINTAIN_ALL:-false}
VERBOSE=${VERBOSE:-false}
NO_REQS=${NO_REQS:-false}
LAZY_CHECKS=${LAZY_CHECKS:-false}
REBUILD=${REBUILD:-false}
REINSTALL=${REINSTALL:-false}
DOWNLOAD_ONLY=${DOWNLOAD_ONLY:-false}
PREPARE_ONLY=${PREPARE_ONLY:-false}
REMAINTAIN=${REMAINTAIN:-false}
DRYRUN=${DRYRUN:-false}
DEBUG=${DEBUG:-false}
NO_FAKEROOT=${NO_FAKEROOT:-false}
SLOT_IN=${SLOT_IN:-false}

ARCH=${ARCH:-i486}
CFLAGS=${CFLAGS:-""}
MY_TAG=${MY_TAG:-""}
MY_EMAIL=${MY_EMAIL:-""}
MY_REALNAME=${MY_REALNAME:-""}

ROOT=${ROOT:-}
CFG_DIR=${CFG_DIR:-$ROOT/etc/portpkg}
ADM_DIR=${ADM_DIR:-$ROOT/var/log}
LOG_DIR=${LOG_DIR:-$ROOT/var/log/portpkg}
SRC_DIR=${SRC_DIR:-$ROOT/usr/src/dist}
CVS_DIR=${CVS_DIR:-$ROOT/usr/src/cvs}
PKG_DIR=${PKG_DIR:-$ROOT/usr/obj/pkg}
PRT_DIR=${PRT_DIR:-$ROOT/usr/ports}
LPRT_DIR=${LPRT_DIR:-$PRT_DIR/local}
ZPRT_DIR=${ZPRT_DIR:-$PRT_DIR/z}
TMP=${TMP:-/tmp}

# constant values, temporary dirs, cache files
ENGINE_VER=cvs
TMPDIR=`mktemp -d $TMP/portpkg-XXXXXX` || exit 1
export TMPDIR
CACHE=`mktemp -d`

# message system
msg_level=0
item()		{ echo -e "$@" | fmt -t; }
row()		{ item "  --> $@"; }
stanza()	{ [ "$msg_level" = "0" ] && item "\n$@"; }
warn()		{ item "WARNING:  $@"; }
error()		{ item "\n$@"; return 1; }
die()		{ [ "$*" ] && error "$@"; exit 1; }

# listers
ls_inst() # regex >pkg_list
{ cache $CACHE/inst "find $ADM_DIR/packages/ -type f | sed \"s,^.*/,,\"" "$@"; }
ls_pkg() # regex >virt_list
{ cache $CACHE/pkg "find $PKG_DIR/ -name \"*.tgz\" -follow | sed \"s,\.tgz$,,\"" "$@"; }
ls_scr() # regex >scr_list
{ cache $CACHE/scr "find $PRT_DIR/ -name \"*SlackBuild\"" "$@"; }
ls_virt() # regex >virt_list
{ cache $CACHE/virt "ls_scr | scr2virt" "$@"; }

# sort port scripts
sorted() # <path_list >path_list
{ sed "s,^$LPRT_DIR/,/0/,;s,^$ZPRT_DIR/,/z/," \
| sort | sed "s,^/0/,$LPRT_DIR/,;s,^/z/,$ZPRT_DIR/,"; }

# common expressions
use_ex() # >regex
{ cache $CACHE/use "regex \$(grep -vse ^# -e ^$ $CFG_DIR/use)"; }
exclude_ex() # >regex
{ cache $CACHE/excl "regex \$(grep -vse ^# -e ^$ $CFG_DIR/exclude)"; }
ignore_ex() # >regex
{ cache $CACHE/ign "regex \$(grep -vse ^# -e ^$ $CFG_DIR/ignore)"; }

# converters
# rel(ease)	:= ver(sion)-arch-build	"1.0-i486-3"
# pkg		:= name-rel		"bla-1.0-i486-3"
# gpkg		:= group/pkg		"l/bla-1.0-i486-3"
# gname		:= group/name		"l/bla"
# scr(ipt)	:= path/*SlackBuild	"/usr/ports/l/bla/bla.SlackBuild"
# virt(ual)	:= path-rel		"/usr/ports/l/bla-1.0-i486-3"
pkg2name()	{ sed -r "s,^(.*)-.*-.*-.*$,\1,"; }
pkg2ver()	{ sed -r "s,^.*-(.*)-.*-.*$,\1,"; }
pkg2rel()	{ sed -r "s,^.*-(.*-.*-.*)$,\1,"; } 
any2base()	{ sed -r "s,^.*/(.*)$,\1,"; }
any2dir()	{ sed -r "s,^(.*)/.*$,\1,"; }
any2gpkg()	{ sed -r "s,^.*/(.*/.*)$,\1,"; }
scr2gname()	{ sed -r "s,^.*/(.*/.*)/.*$,\1,"; }
scr2virt()	{ xargs grep -sH "^VERSION=\|^ARCH=\|^BUILD=" -m 3 \
| sed -un "\,:VERSION=,{s,/[^/]*:VERSION=,-,;N;s,\n.*=,-,;N;s,\n.*=,-,;\
s,\${ARCH:-[^}]*},$ARCH,;s,\${[A-Z]*:-\([^}]*\)},\1,g;p}"; }
#FIXME: preset $BUILD and $VERSION is not supported, only reset!

# checks
has_args()	{ [ "$*" ] || error "Too few arguments! Try:  portpkg --help"; }
is_root()	{ [ "`whoami`" = "root" ] || error "You must be root to run this action!"; }
has_prog()	{ which $1 >/dev/null 2>&1 || error "Cannot find $1!"; }
has_ports()	{ [ -d "$PRT_DIR" ] || error "No ports found! Try:  portpkg --sync"; }
is_defined()	{ [ "`eval echo \$\{$1\} 2>/dev/null`" ] || error "Please define $1 in $CFG_DIR/local.conf!"; }
has_info()	{ [ "$path" ] || error "Internal error! No information about current port found."; }

# basic functions

# cache the output of "action" and grep a regex
cache() # file action regex
{
  local file=$1 action=$2
  shift 2
  [ "$*" ] && local filter="grep $@" || local filter="cat"
  if [ -s $file ]; then
    $filter $file
  else
    eval "$action" | tee $file | $filter -
  fi
}

# generate a regular expression for grep from a pkgex-list
regex() # pkgex_list >regex_list
{
  local arg
  for arg; do
    case $arg in
      */) # groups
          echo -n " -e \(^\|/\)$arg[^/]*$";;
      *)  # (g)names and (g)packages
          echo -n " -e \(^\|/\)$arg\(\|-[^-]*-[^-]*-[^-]*\)$";;
    esac
  done
  [ $# = 0 ] && echo "^$" || true
}

# resolve groups/ to names (note: do_list() doesn't use explicit()!)
explicit() # pkg_list >pkgex-list
{
  local arg
  for arg; do
    case $arg in
      */) ls_scr | scr2gname | grep `regex $arg` | any2base
          cat $CFG_DIR/virtual/${arg%/*} 2>/dev/null;;
      *)  echo $arg;;
    esac
  done
  # "turbo mode": port is current dir
  [ $# = 0 ] && echo . || true
}

# find a mirror
mirror() # url >url
{
  local master mirror
  grep -shve "^#" -e "^$" $CFG_DIR/mirrors | while read master mirror; do
    # use pathname expansion instead of regular expressions here
    case $1 in $master*)
      echo $mirror${1#$master}
      exit 1;;
    esac
  done && echo $1
  return 0
}

## translate an obselete port name to a recommended name
#translate() # name >name_list
#{
#  local old new
#  grep -shve "^#" -e "^$" $CFG_DIR/translate | while read old new; do
#    case $1 in $old|$new)
#      echo -e "$new\n$old"
#      exit 1;;
#    esac
#  done && echo $1
#  return 0
#}

# print non-available, but installed ports
ls_diff() # >pkgex_list
{
  local t=`mktemp -d`

  # generate installed and available lists
  ls_virt | sorted | grep -v `exclude_ex` | any2base >$t/avail
  ls_inst >$t/inst
  pkg2name <$t/avail >$t/avail.names
  pkg2name <$t/inst >$t/inst.names

  # find installed packages that are available
  local check
  fgrep -xf $t/avail.names $t/inst.names | while read check; do
    grep -xm 1 "$check-[^-]*-[^-]*-[^-]*" $t/avail >>$t/avail.check
    grep -xm 1 "$check-[^-]*-[^-]*-[^-]*" $t/inst >>$t/inst.check
  done

  # neglect architecture differences for ix86
  sed -i "s,-i.86-,-i.86-," $t/avail.check $t/inst.check

  # print differences
  fgrep -vxf $t/inst.check $t/avail.check | grep -xf - $t/avail | sort -u
}

# reset global, port specific variables
unset_info()
{
  package="" name="" group="" version=""
  script="" path="" description="" sources=""
  requires="" optional="" blocks="" uses=""
  pkg_file="" products=""
  tmp=$TMP
  maintain=$MAINTAIN_ALL
  verbose=$VERBOSE
  rebuild=$REBUILD
  reinstall=$REINSTALL
  no_fakeroot=$NO_FAKEROOT
  slot_in=$SLOT_IN
}

# get information about a port and write it into global variables
get_info() # pkgex
{
  unset_info

  case $1 in
    .)
      # "turbo mode": port directory is `pwd`, turn off dependencies
      NO_REQS=true
      path=`pwd`;;
    */*)
      # explicitly named port: no exclusion
      path=`ls_scr "/$1/[^/]*$" | any2dir | sorted | head -n 1`;;
    *)
      # normal: find port by list
      path=`ls_scr "/$1/[^/]*$" | any2dir | sorted | grep -v $(exclude_ex) | head -n 1`;;
  esac

  # prefer $name.SlackBuild over SlackBuild over any other *.SlackBuild
  name=`echo $path | any2base`
  script=`{ \
find $path/ -name "$name.SlackBuild" -maxdepth 1
find $path/ -name "SlackBuild" -maxdepth 1
find $path/ -name "*SlackBuild" -maxdepth 1; } | head -n 1`
 
  if ! [ "$script" ]; then
    error "No such port:  $1."
    return 1
  fi

  # virt is not a global variable
  local virt=`echo $script | scr2virt`

  group=`echo $virt | any2gpkg | cut -d / -f 1`
  package=`echo $virt | any2base`
  version=`echo $package | pkg2ver`
  description=`grep -sh ^$name: $path/slack-desc $path/slack-desc.$name $path/slack-desc/* $script`
  sources=`grep -sve ^# -e ^$ $path/sources | sed "s,[{}],,g;s,\\$NAME,$name,g;s,\\$VERSION,$version,g"`

  # dependencies
  requires=`{ \
grep -sve ^# -e ^$ $path/requires
grep -sve ^# -e ^$ $path/slack-required | cut -d " " -f 1; } | sort -u`
  optional=`{ \
grep -s "^# opt" $path/requires | cut -d " " -f 3
grep -sve ^# -e ^$ $path/optional; } | sort -u`
  blocks=`{ \
grep -s "^# block" $path/requires | cut -d " " -f 3
grep -sve ^# -e ^$ $path/blocks; } | sort -u`

  # calculate "use"-list
  $NO_REQS || uses=`ls_virt $(regex $optional) | grep $(use_ex) | any2base | pkg2name | sort -u`

  # find cached .tgz-packages (prefer packages in $group/)
  pkg_file=`{ \
find $PKG_DIR/ -path "*/$group/$package.tgz"
find $PKG_DIR/ -name "$package.tgz"; } | head -n 1`

  # check maintainance of port
  [ "$MY_TAG" ] && case $package in *[0-9]$MY_TAG) maintain=true; esac

  # check specific flags (old style)
  [ -f $path/no-fakeroot ] && no_fakeroot=true
  [ -f $path/slot-in ] && slot_in=true
  # new style
  grep -sqx no-fakeroot $path/flags && no_fakeroot=true
  grep -sqx slot-in $path/flags && slot_in=true
  grep -sqx verbose $path/flags && verbose=true
  grep -sqx rebuild $path/flags && rebuild=true

  # check $TMP
  grep -sq "^TMP=\${TMP:-" $script || tmp=/tmp

  # check if the script produces multiple packages
  if [ `grep "^[^#]*makepkg " $script | wc -l` -gt 1 ]; then
    local arch=`echo $package | pkg2rel | cut -d - -f 2`
    local build=`echo $package | pkg2rel | cut -d - -f 3`
    products=`sed -n "s,^[^#]*makepkg .*/\([^ ]*\)\.tgz.*,\1,p" $script \
| sed "s,[{}],,g;s,\\$VERSION,$version,g;s,\\$ARCH,$arch,g;s,\\$BUILD,$build,g"`
  else
    products="$package"
  fi

  return 0
}

# functions using global variables (current port): use get_info() before!

# download the source files of the current port
get_sources()
{
  local t=`mktemp -d`
  has_info || die
  $verbose && local output=/dev/stdout || local output=/dev/null
  local src
  for src in $sources; do
    # the source filename can have an arbitrary name written behind a %
    local filename=`basename ${src##*%}`
    local url=${src%\%*}
    local mirror=`mirror $url`
    case $mirror in
      cvs://*)
        local dest=$CVS_DIR/$filename
        row "Syncing CVS of $filename"
        has_prog cvs || return 1
	$DRYRUN && return 0
        if [ -d $dest ]; then
          ( cd $dest
            cvs -qz9 up -dP -I z -I 0 . >$output 2>/dev/null
          )
        else
          mkdir -p $dest
          mirror=`echo $mirror | sed "s,^cvs://,,"`
          ( cd `dirname $dest`
            cvs -qz9 -d `dirname $mirror` co -Pd $filename `basename $mirror` >$output 2>/dev/null
          )
        fi
        ln -s $dest $path/;;
      svn://*)
        local dest=$CVS_DIR/$filename
        row "Syncing SVN of $filename"
        has_prog svn || return 1
	$DRYRUN && return 0
        mkdir -p $dest
        ( cd `dirname $dest`
          # FIXME: support arbitrary filename for svn repo!
          svn co `dirname $mirror` `basename $mirror` >$output 2>/dev/null
        )
        ln -s $dest $path/;;
      file://*)
        local mirror=`echo $mirror | sed "s,^file://,,"`
        if [ -f "$filename" ]; then
          row "$filename found in `dirname $mirror`"
        else
          error "File not found:  $mirror"
          return 1
	fi
        $DRYRUN && return 0
	ln -s $mirror $path/$filename;;
      *)
        local dest=$SRC_DIR/$filename
        if [ -f "$dest" ]; then
          row "$filename found in $SRC_DIR/"
        else
          row "Downloading $filename"
          has_prog wget || return 1
          $DRYRUN && return 0
          mkdir -p $SRC_DIR
          # try primary url if mirror fails
          if (wget -c -O $dest.part $mirror 2>$output) \
|| ([ "$url" != "$mirror" ] && wget -c -O $dest.part $url 2>$output); then
            mv $dest.part $dest
          else
            error "Download failed!"
            return 1
          fi
        fi

        $DRYRUN && return 0
	ln -s $dest $path/

        # md5sums for versioned files only (mask *NN* or *N.N*)
        case $filename in *[0-9][0-9]*|*[0-9].[0-9]*);; *) return 0;; esac
        if $maintain; then
          # create md5sums
          md5sum $dest | sed "s, $SRC_DIR/, ," >>$path/md5sums
          sort -uo $path/md5sums $path/md5sums
        elif grep -sq " $filename$" $path/md5sums; then
          # check
          local md5sum=`grep " $filename$" $path/md5sums`
          ( cd $path
            if ! echo "$md5sum" | md5sum -c >/dev/null; then
              error "Integrity checking failed:  $filename"
              return 1
            fi
	  )
        else
          warn "No checksum available for $filename"
        fi;;
    esac
  done
}

# regenerate meta information (md5sums/footprint/requires) for the current port
update_meta_info()
{
  $maintain || return 0
  local t=`mktemp -d`
  row "Updating meta information"
  has_info || die

  # regenerate footprint (remove creation time)
  tar tzvf $tmp/$package.tgz | sort +5 | awk '{ print $1,$2,$6 }' \
| column -t >$path/footprint

  # unpack package?
  if ! [ -d $tmp/package-$name ]; then
    rm -rf $tmp/package-$name
    mkdir $tmp/package-$name
    tar xzf $tmp/$package.tgz -C $tmp/package-$name/
  fi

  # generate requires/optional list
  echo "$requires" >$t/old_req
  echo "$optional" >$t/old_opt

  # why not? rpm's find-requires lists all dependencies (libs, perl modules, etc.)
  # (perl modules will be identified by their man-pages!)
  has_prog rpm || return 1
  find $tmp/package-$name/ | /usr/lib/rpm/find-requires \
| sed "s,^perl(\(.*\))$,\1.3.gz,;\,)$,d;\,^$,d;\, ,d;\,^/bin/sh$,d;s,^/,," >$t/auto_req_raw_files

  # resolve file names to package names, strip ignore list
  ls_inst `ignore_ex` | any2base | pkg2name >$t/ignore
  grep -lwf $t/auto_req_raw_files $ADM_DIR/packages/* $ADM_DIR/scripts/* \
| any2base | pkg2name | fgrep -xvf $t/ignore \
| sed -e "s,-solibs$,," -e "s,^x11$,&\nx11-devel," -e "/^$name$/d" \
| sort -u >$t/auto_req

  # strip old lists to see what's new
  fgrep -vxf $t/old_req -f $t/old_opt $t/auto_req >$t/new_req

  # if "requires" already exists, mark new dependencies as optional
  if [ "$requires" ]; then
    optional="$optional
`cat $t/new_req`"
  else
    requires="$requires
`cat $t/new_req`"
  fi

  # now generate new "requires" file
  echo "$requires" >>$t/requires
  echo "$optional" | xargs -r -l echo "# optional:" >>$t/requires
  echo "$blocks" | xargs -r -l echo "# block:" >>$t/requires
  sort -uo $t/requires $t/requires
  sed -i "/^$/d" $t/requires
  mv $t/requires $path/requires

#  # translate old port names to new ones
#  local req
#  for req in $requires $optional $blocks; do
#    local trans=`translate $req | head -n 1`
#    if [ "$req" != "$trans" ]; then
#      row "Translating $req to $trans"
#      sed -i "s,\(^\| \)$req$,\1$trans," $path/requires
#    fi
#  done

  # show a few statistics
  cat $t/new_req | xargs -r echo "  --> New dependencies:"
  fgrep -hxvf $t/auto_req $t/new_req $t/old_req | xargs -r echo "  --> Arbitrary dependencies:"
  
#  has_prog pkgcheck && pkgcheck $tmp/$package.tgz

  # check for common mistakes
  egrep -woe "usr/(local/|etc/|share/doc/|share/man/|info/dir).*" \
-e "/$ARCH-slackware-linux-" $path/footprint >$t/check_path
  egrep -e "^........w" -e " root/root .*( |/)(|s)bin/" $path/footprint >$t/check_perm
  egrep -e "-upgraded$" $t/auto_req >$t/check_req
  ls_virt | grep -v `exclude_ex` | any2base | pkg2name \
| fgrep -vxf - $t/auto_req >>$t/check_req
  cat $t/check_path | xargs -r -l echo "WARNING:  Check this path:"
  cat $t/check_perm | xargs -r -l echo "WARNING:  Check these permissions:"
  cat $t/check_req | xargs -r echo "WARNING:  Check these dependencies:"

  # remove empty and obsolete files
  [ -f $path/no-fakeroot ] && echo no-fakeroot >>$path/flags
  [ -f $path/slot-in ] && echo slot-in >>$path/flags
  [ -f $path/flags ] && sort -uo $path/flags $path/flags
  local file
  ls $path/optional $path/blocks $path/arbitrary $path/no-fakeroot $path/slot-in 2>/dev/null \
  xargs -r -i echo "WARNING:  {} is obsolete! Removed/converted."
  ls $path/optional $path/blocks $path/arbitrary $path/no-fakeroot $path/slot-in 2>/dev/null \
  xargs -r rm
  for file in requires md5sums flags; do
    [ -s $path/$file ] || rm -f $path/$file
  done
}

# build package (mostly "run SlackBuild") for the current port
build_pkg()
{
  if [ -f "$pkg_file" ] && ! $rebuild; then
    if $DOWNLOAD_ONLY || $PREPARE_ONLY; then
      stanza "Already built. Skipping."
    fi
    return 0
  fi
  local t=`mktemp -d`
  stanza "Building $package:"
  has_info || die

  # find CFLAGS substitution (CFLAGS="$SLKCFLAGS")
  local cflags_var=`grep -o "CFLAGS=\\"*\\$[^ ]*" $script | cut -d = -f 2 | tail -n 1 | sed "s,[\"\$],,g"`
  if ! [ "$cflags_var" ]; then
    $maintain && case $package in $name-$version-noarch-*) ;; *)
      warn "No CFLAGS usage in this script! Compiling with default values."
    esac
    # this is just a wild guess
    cflags_var=CFLAGS
  fi

  # check if the script supports break-on-errors ("|| exit 1")
  local sh_opt="-e -x"
  if grep -sq "|| exit 1$" $script; then
    sh_opt="-x"
  fi

  # check if we should --cleanup the SlackBuild
  local script_opt="--cleanup"
  if $maintain; then
    warn "Maintainer mode:  Modifying files:  requires md5sums footprint"
    $rebuild && warn "Change BUILD number if you made changes to the script!"
    script_opt=""
  fi

  # check if the script supports custom TMP
  if [ "$TMP" != "$tmp" ]; then
    warn "This port ignores your TMP setting. Trying to redirect to $tmp."
    warn "If this fails, please report this as a bug to the maintainer!"
  fi

  local vars="HOME=$tmp TMPDIR=$tmp ARCH=$ARCH $cflags_var=\"$CFLAGS\" TMP=$tmp"
  local run="sh $sh_opt $script $script_opt"

  # check if we should run fakeroot
  if $no_fakeroot || ! has_prog fakeroot; then
    run="$vars $run"
    $no_fakeroot && warn "Fakeroot disabled for this port!" \
|| warn "Please install fakeroot as soon as possible!"
    $PREPARE_ONLY && warn "Preparing without fakeroot is not recommended!"

    # without fakeroot we need root permissions here
    if [ "`whoami`" != "root" ]; then
      error "To build a package without fakeroot, you must be root yourself!"
      return 1
    fi
  else
    # if we are root, change to nobody first
    if [ "`whoami`" = "root" ]; then
      run="su nobody -c 'PATH=\$PATH:/sbin:/opt/kde/bin $vars fakeroot $run'"
    else
      run="PATH=\$PATH:/sbin:/opt/kde/bin $vars fakeroot $run"
    fi
  fi

  # assume, all symlinks here are old links to log files or source files
  [ "$path" ] || die "Internal error!"
  find $path/ -type l -exec rm {} \;

  get_sources || return 1

  # exit when download-only or dry-run
  $DRYRUN && row "Executing $script"
  $DOWNLOAD_ONLY && return 0
  $DRYRUN && return 0

  # run the script
  if $REMAINTAIN; then
    row "Skipping package building"
    cp $pkg_file $tmp/
  else
    rm -rf $tmp/package-$name
    rm -rf $tmp/$package.tgz

    cd $path || return 1
    mkdir -p $LOG_DIR

    # execute the SlackBuild
    row "Executing $script"
    $verbose && local output=/dev/stdout || local output=/dev/null
    eval "$run" 2>&1 | tee $LOG_DIR/$package >$output
#    # this is a hack-around for some faulty install scripts
#    chmod 1777 /tmp
  fi

  # success? (this is the most promising test to ensure it worked)
  if [ -f $tmp/$package.tgz ]; then
    # remove this flag in any case
    rm -rf $path/PORT_IS_BROKEN
  else
    $verbose || tail $LOG_DIR/$package
    error "Compilation failed (see $LOG_DIR/$package)!"
    $maintain && ln -sf $LOG_DIR/$package $path/PORT_IS_BROKEN
    return 1
  fi

  # cruft for maintainers of port scripts :)
  update_meta_info | tee -a $LOG_DIR/$package

  # finish
  mkdir -p $PKG_DIR/$group
  echo "$products" | xargs -i echo "  --> Moving {} to $PKG_DIR/$group/"
  echo "$products" | xargs -i mv $tmp/{}.tgz $PKG_DIR/$group/
  pkg_file=$PKG_DIR/$group/$package.tgz
  find $path/ -type l -exec rm -rf {} \;
  # remove source files with arbitrary names from $SRC_DIR
  $LAZY_CHECKS || grep -s % $path/sources | cut -d % -f 2 | xargs -i rm -rf $SRC_DIR/{}
  $maintain || row "Cleaning up $tmp/"
  $maintain || rm -rf $tmp/package-$name
}

# check if all required packages of the current port are installed
check_reqs()
{
  $NO_REQS && return 0
  local t=`mktemp -d`
  has_info || die
  local gname=""
  local req
  for req in $requires $uses; do
#    # also look for translations
#    local req=`translate $req`
    local inst_pkg=`ls_inst $(regex $req) | sed "s,-i.86-,-i.86-," | head -n 1`
    local avail_pkg=`ls_virt $(regex $req) | sorted | grep -v $(exclude_ex) | any2gpkg | any2base | head -n 1`

    # is the dependency available?
    if [ "$avail_pkg" ]; then
      # is it up-to-date?
      if ! ( $LAZY_CHECKS && [ "$inst_pkg" ] ) && \
! echo $avail_pkg | grep -xsq "$inst_pkg"; then
        # add it and remember group and name
        $DRYRUN && ! [ "$gname"  ] && stanza "Preparing for $package:"
        gname=$group/$name
	$DRYRUN && row "Requiring $avail_pkg"
        get_info `echo $avail_pkg | pkg2name`
        $DRYRUN && msg_level=$(($msg_level+1))
        if ! add_pkg; then
          $DRYRUN && msg_level=$(($msg_level-1))
          error "$avail_pkg is broken! Stopping `echo $gname | any2base`."
          return 1
        fi
        $DRYRUN && msg_level=$(($msg_level-1))
        # after that add_pkg, we have to refresh
        get_info $gname
      fi
    # is such a package installed?
    elif [ "$inst_pkg" ]; then
      :
    # is maybe a package in the cache?
    elif [ "`ls_pkg $(regex $req)`" ]; then
      $DRYRUN && return
      if ! sh -c "installpkg `ls_pkg $(regex $req) | head -n 1`.tgz \
| tee $t/output | grep -e ^PACKAGE -e ^$name: -e ^Executing"; then
        cat $t/output
        error "Install failed!"
        return 1
      fi
    else
      error "Cannot resolve dependency $req! Stopping."
      return 1
    fi
  done
  return 0
}

check_blocks()
{
  $NO_REQS && return 0
  has_info || die
  local block
  for block in $blocks; do
    if [ "`ls_inst $(regex $block) | head -n 1`" ]; then
      # we have a blocking package installed, exit!
      error "$block is blocking $name. Please uninstall first!"
      return 1
    fi
  done
}

# really (re)install/upgrade current port
add_pkg()
{
  local t=`mktemp -d`
  has_info || die

  if [ "`ls_inst ^$package$`" ] && ! $reinstall; then
    stanza "$package is already installed. Skipping."
    return 0
  fi

  check_blocks || return 1
  check_reqs || return 1
  build_pkg || return 1

  $DOWNLOAD_ONLY && return 0
  $PREPARE_ONLY && return 0

  # install the package
  $slot_in && warn "Slot-in:  Other releases will stay installed!"

  # what to display?
  if ! [ -f $path/slot-in ] && [ "`ls_inst ^$package$`" ]; then
    stanza "Reinstalling $package..."
    local add="upgradepkg --reinstall"
  elif ! [ -f $path/slot-in ] && [ "`ls_inst $(regex $name)`" ]; then
    stanza "Upgrading $name to `echo $package | pkg2rel`..."
    local add="upgradepkg"
    local old_pkg=`ls_inst $(regex $name) | head -n 1`
    sed -i "/^$old_pkg$/d" $CACHE/inst
  else
    stanza "Installing $package..."
    local add="installpkg"
  fi
  echo $package >>$CACHE/inst

  $DRYRUN && [ "$msg_level" = "0" ] && echo -e "PACKAGE DESCRIPTION:\n$description"
  $DRYRUN && return 0

  # call the install-command
  if ! sh -c "$add $pkg_file | tee $t/output \
| grep -e ^PACKAGE -e ^$name: -e ^Executing"; then
    cat $t/output
    error "Installation failed!"
    return 1
  fi
  return 0
}

# action functions after options parsing

do_add() # pkgex_list
{
  local t=`mktemp -d`
  ls_inst >$t/inst
  >$t/building

  # if we got groups here, tell what they contain
  case "$@" in */*) stanza "Resolving targets:  "`explicit "$@"`;; esac

  local arg
  for arg in `explicit "$@"`; do
    get_info $arg || continue
    # if the current port is already tracked as started and not finished, it is
    # either broken or a circular dependency and should fail now
    if fgrep -sqx "$package" $t/building; then
      row "Circular dependency! Skipping $name."
      return 0
    fi
    echo "$package" >>$t/building
    add_pkg || continue
    sed -i "/^$package$/d" $t/building
  done
}

do_diff()
{
  local t=`mktemp -d`
  local diff_list=`ls_diff`
  [ "$diff_list" ] || die "No differences found."
  ls_inst >$t/inst
  local pkg
  { echo -e "\nPACKAGE: AVAILABLE: INSTALLED:" && continue
    for pkg in $diff_list; do
      local name=`echo $pkg | pkg2name`
      local avail_rel=`echo $pkg | pkg2rel`
      local inst_rel=`grep -m 1 $(regex $name) $t/inst | pkg2rel`
      echo "$name $avail_rel $inst_rel"
    done
  } | column -t
}

do_export() # message pkgex_list
{
  local export_opt="$1"
  shift

  # make sure, the user didn't accidently give a port for summary
  case "$export_opt" in *\ *) ;; *) die "Summary must be at least two words!"; esac

  stanza "Exporting:"
  local arg
  for arg in `explicit "$@"`; do
    get_info $arg || continue

    # make some check before exporting
    if ! $maintain; then
      error "$group/$name is not your port. Skipping."
    elif [ -f $path/PORT_IS_BROKEN ]; then
      error "Cannot export broken ports:  $group/$name"
    elif ! [ -f $path/footprint ] || [ $path/footprint -ot $script ]; then
      error "No or too old footprint:  $group/$name"
    elif [ `echo "$description" | grep :.. | wc -l` -lt 2 ]; then
      error "Too short description:  $group/$name"
    elif [ "`find $path/ -type l`" ]; then
      error "Remove links before export:  $group/$name"
    fi
    [ $? != 0 ] && continue

    # start 3rd-party-exporter
    if [ -f $CFG_DIR/export ]; then
      $DRYRUN && row "Executing $CFG_DIR/export $group/$package" || ( . $CFG_DIR/export )
    else
      die "Exporter not defined:  $CFG_DIR/export"
    fi
  done
}

# find ports by pattern
do_find() # text [...] >pkgex_list
{
  local t=`mktemp -d`
  has_args "$@" || die
  find $PRT_DIR/ -follow -name slack-desc >$t/list
  local arg
  for arg; do
    cat $t/list | xargs grep -lsi $arg >$t/list.new
    mv $t/list.new $t/list
  done
  [ -s $t/list ] && do_list `cat $t/list | scr2gname`
}

# print information about a port
do_info() # pkgex-list
{
  local arg
  for arg in `explicit "$@"`; do
    get_info $arg || continue
    stanza "PACKAGE NAME:  $package"
    if [ "$pkg_file" ]; then
      local s=`gzip -l $pkg_file | tail -n 1`
      local size=`echo $s | awk '{ print $1 }'`
      local u_size=`echo $s | awk '{ print $2 }'`
      item "COMPRESSED PACKAGE SIZE:  `expr $size / 1024` K"
      item "UNCOMPRESSED PACKAGE SIZE:  `expr $u_size / 1024` K"
      item "PACKAGE LOCATION:  $pkg_file"
    fi
    item "SCRIPT LOCATION:  $script"
    [ "$products" != "$package" ] && item "SCRIPT PRODUCES:  "$products
    [ "$requires" ] && item "PACKAGE REQUIRES:  "$requires
    [ "$optional" ] && item "PACKAGE SUGGESTS:  "$optional
    [ "$blocks" ] && item "PACKAGE BLOCKS:  "$blocks
    [ "$uses" ] && item "PACKAGE USES:  "$uses
    [ "$sources" ] && item "SOURCE LOCATIONS:  "$sources
    [ "$description" ] && echo -e "PACKAGE DESCRIPTION:\n$description"
    $verbose && [ -f $path/footprint ] && cat $path/footprint \
| awk 'BEGIN { print "FILE LIST:" } { print $3 }'
  done
}

# list available ports
do_list() # [pkgex-list] >pkgex_list
{
  case "$*" in
    "") ls_virt;;
    *)  # grep arguments
        ls_virt `regex "$@"`
        # in order to see virtual groups we add them here intentionally
        grep -sH . $CFG_DIR/virtual/* | sed "s,:,/," | grep `regex "$@"`;;
  esac | sorted | any2gpkg
}

do_sync()
{
  local t=`mktemp -d`
  stanza "Syncing your ports:"

  # start 3rd-party-importers
  local importer
  for importer in `find $CFG_DIR/plugins/sync.*`; do
    if [ -x $importer ]; then
      $DRYRUN && row "Executing $importer" || ( . $importer )
    fi
  done
}

# upgrade all installed ports that are not available
do_upgrade()
{
  local diff_list=`ls_diff | pkg2name`
  [ "$diff_list" ] || die "No upgrades available."
  do_add $diff_list
}

do_help()
{
  cat <<EOF

Usage:  portpkg [<action>] [<options>] [<expression> [...]]
  Build a package by source and install it.
Actions (alternative):
  -d, --diff         Compare installed versions with availables
  -x, --export text  Submit ports via $CFG_DIR/export
  -f, --find text    Find ports by matching pattern strings
  -i, --info         View information about specified ports
  -l, --list         List (all or certain) available ports
  -s, --sync         Sync local ports tree in [$PRT_DIR]
  -u, --upgrade      Upgrade all (!) outdated ports (see --diff)
  -v, --version	     View version information
Options:
  -p, --prepare      Build only, don't install [implies --noreqs]
  -o, --download     Download only, don't build/install
  -r, --remaintain   Maintain only, skip building [implies --rebuild]
  -y, --dryrun	     Simulate only, don't build/install/up-/download
  -b, --rebuild      Force building, if already built [implies --reinstall]
  -e, --reinstall    Force installing, if already installed
  -m, --maintain     Force maintaining, update meta info
  -q, --noreqs       Ignore dependencies
  -a, --lazy         Ignore release differences, don't upgrade dependencies
  -g, --verbose      More output
Expressions:  <group>/ or [<group>/]<portname> or nothing for current dir
EOF
}

do_version()
{
  cat <<EOF
    
Portpkg version $ENGINE_VER.
Copyright (C) 2003-2005 Thomas Pfaff <topf at users dot berlios dot de>.
Portpkg comes with ABSOLUTELY NO WARRANTY. This is free software, and you
are welcome to redistribute it under certain conditions.
EOF
}

# interpret and run command line

parse_options()
{
  local shorts="diflsuvhebogyqxzarpm"
  local longs="diff,info,find,list,sync,upgrade,version,help,reinstall,\
rebuild,download,verbose,dryrun,debug,noreqs,lazy,remaintain,prepare,\
maintain,export"

  local args
  args=`getopt -qo $shorts -l $longs -- "$@"`
  [ "$?" = "0" ] || die "Bad Arguments! Try:  portpkg --help"
  eval set -- "$args"

  # do_add is the default action
  local action=do_add

  while [ "$1" ]; do
    case $1 in
      -d|--diff)        action=do_diff;;
      -x|--export)      action=do_export;;
      -f|--find)        action=do_find;;
      -h|--help)      	action=do_help;;
      -i|--info)      	action=do_info;;
      -l|--list)      	action=do_list;;
      -s|--sync)        action=do_sync;;
      -u|--upgrade)     action=do_upgrade;;
      -v|--version)     action=do_version;;
      -p|--prepare)     PREPARE_ONLY=true;;
      -o|--download)    DOWNLOAD_ONLY=true;;
      -r|--remaintain)  REMAINTAIN=true;;
      -m|--maintain)    MAINTAIN_ALL=true;;
      -y|--dryrun)      DRYRUN=true;;
      -g|--verbose)   	VERBOSE=true;;
      -z|--debug)       DEBUG=true;;
      -q|--noreqs)      NO_REQS=true;;
      -a|--lazy)        LAZY_CHECKS=true;;
      -b|--rebuild)     REBUILD=true;;
      -e|--reinstall)   REINSTALL=true;;
      --)               shift
                        break;;
    esac
    shift
  done

  $PREPARE_ONLY && NO_REQS=true
  $REBUILD && REINSTALL=true
  $REMAINTAIN && REBUILD=true
  $DEBUG && set -x -v && VERBOSE=true

  $action "$@"
}

# initialise portpkg

init()
{
  # clean up on exit
  trap "rm -rf $TMPDIR" EXIT
  trap "" PIPE

  umask 022
  export LC_ALL=C

  unset_info

  # check
  has_prog sed || die

  # if not used as include file then start me
  [ `basename $0` = "portpkg" ] && parse_options "$@" || true
}

init "$@"
