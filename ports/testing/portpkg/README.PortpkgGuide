The Portpkg Project Guide

  Copyright

   Copyright (C) 2004, 2005 Thomas Pfaff <topf at users dot berlios dot de>

   This is free software; you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation; either version 2 of the License, or (at your option) any later
   version.

   --------------------------------------------------------------------------

Introduction

  What is the Portpkg Project and how does it work?

   Portpkg is a ports system for Slackware Linux. Its purpose is to build and
   manage a larger set of software for Slackware. This is done not by
   provding binary packages, but by collecting scripts that download, compile
   and install software on your machine. The implementation is very simple
   and automated while still gaining a maximum of system integration: It is
   based on SlackBuilds aslike Slackware's Pkgtools. The information of how
   to compile what software, what version and where to find is stored in
   additional files, these are catalogised in a so called ports tree.
   Portpkg's administration scripts make it possible to browse, search and
   handle these scripts. Contribution of own ports is realised by uploading
   them onto our server which commits them into an open directory. The
   contributed ports will be checked and merged into the ports tree later.

  Why should I use Portpkg?

   The traditional way of adding software to a Slackware system is either to
   install a ready-made package or to compile it by hand. While the first one
   is dead easy, the other one gives you full control over any details of the
   resulting software. Portpkg is in the middle of both: It has a comfortable
   administration interface similiar to installpkg, but also a source script
   system, as Slackware uses it to compile and gives you as much control as
   possible. Also, the Portpkg project doesn't change Slackware's behaviour
   in any way. Portpkg is a ports system that tries to match Slackware's way
   as close as possible.

  Overview of this guide

     o Installing Portpkg
     o Using the ports

          o Building and installing ports
          o Listing all available ports
          o Viewing information of ports
          o Finding ports
          o Listing outdated packages
          o Upgrading all outdated packages
          o The tool Checkpkg

     o Writing ports

          o Preparing

               o Maintainer mode
               o Classifying ports

          o Ports and their parts

               o SlackBuild
               o Doinst.sh
               o Slack-desc
               o Sources
               o Slot-in
               o Pseudo
               o Requires
               o Optional
               o No-fakeroot
               o Ignore
               o Miscellaneous

          o Configuration of Portpkg

               o Local.conf
               o Mirrors ans mirrors.local
               o Ignore and ignore.local
               o Exclude and exclude.local

          o The tool Autoport

     o Contribute to the Portpkg Project
     o Backgrounds

          o A small introduction into the ports tree
          o Terminology
          o Theory
          o File system
          o Ports tree
          o The SlackBuild-blackbox
          o Dealing with ports

   --------------------------------------------------------------------------

Installing Portpkg

   First, make sure you have permissions to switch to root! If you are not
   allowed, Portpkg makes no sense to you. You will also need access to the
   internet, although Portpkg should work fine on a dial-up system, too!
   Download a recent version of Portpkg from
   http://developer.berlios.de/project/showfiles.php?group_id=2486 to your
   home directory and install it as root:

 $ su
 Password:
 # installpkg portpkg-xxx-noarch-1tom.tgz

   This will install just the administration tools in /usr/bin. Now, make
   sure you have all dependend programmes installed to use it. You will need
   cvs and wget (d/ and n/ groups) to retrieve the ports collection and
   distributed files, To build packages you will definitively need the
   development packages in Slackware's d/ group. Checkout the ports tree
   with:

 # portpkg --sync

 Syncing your ports tree with cvs.berlios.de:
   --> Updating ports/ap/abook
   --> Updating ports/ap/athcool
   --> Updating ports/ap/bonnie++
 (...)

   Portpkg will now write a copy of the current ports tree to /usr/ports. Use
   this command to update your ports tree later as the it changes quite
   often. Portpkg is now ready to compile.

   --------------------------------------------------------------------------

Using the ports

   The most important administration tool for the ports is portpkg: It has
   several types of action (such as list available ports, find ports by
   keywords, view detailes about certain ports, list outdated ports, make a
   system-upgrade) and a default behaviour, which simply is to build and
   install a specified port.

  Building and installing ports

   The default action of portpkg is to build and install a package (that
   includes checking for neccessary dependend packages and download of source
   code files). When this is called default, it means there's no other
   parameters needed. Its usage is quite simple, just write down the port
   names you would like to add to your system or bring to its latest release:

 # portpkg xdaf

 Building package xdaf-A.01.11.01-i486-1tom:
   --> Downloading xdaf-A.01.11.01.tar.gz
   --> Executing /usr/ports/xap/xdaf/SlackBuild
   --> Moving package to /usr/obj/pkg/xap/

 Installing package xdaf-A.01.11.01-i486-1tom...
 PACKAGE DESCRIPTION:
 xdaf: xdaf (X11 Disk Activity Feedback)
 xdaf:
 xdaf: xdaf is a small tool to provide a visual feedback
 xdaf: of the local disks activity by changing the default
 xdaf: X11 mouse pointer to an animated wheel (the wheel
 xdaf: is white when the disks are been used for reading
 xdaf: and it turns red when writing occurs).
 xdaf:

   This would install (or upgrade if needed) the port xdaf. You can specify
   more than one port in one line. Portpkg will not reinstall a port if
   exactly that release is already installed. If it is your intention to do
   so, you must add the parameter --reinstall. E.g:

 # portpkg --reinstall alreadyhere

   Here's a complete list of all options to adjust portpkg:

   +------------------------------------------------------------------+
   |--reinstall|Reinstall package if already installed                |
   |-----------+------------------------------------------------------|
   |--rebuild  |Rebuild package if already build (implies --reinstall)|
   |-----------+------------------------------------------------------|
   |--prepare  |Build package, but don't install (implies --noreqs)   |
   |-----------+------------------------------------------------------|
   |--download |Download source files only                            |
   |-----------+------------------------------------------------------|
   |--verbose  |Show compile output                                   |
   |-----------+------------------------------------------------------|
   |--dryrun   |Simulate install/download/build                       |
   |-----------+------------------------------------------------------|
   |--noexlcude|Don't use exclude list                                |
   |-----------+------------------------------------------------------|
   |--noreqs   |Don't check for requirements                          |
   |-----------+------------------------------------------------------|
   |--lazy     |Don't upgrade dependencies to newest version          |
   +------------------------------------------------------------------+

  Listing all available ports

   Portpkg has a few alternative actions, that means it will have a different
   behaviour with them enabled. Get a full list of available ports (groups
   and release information) with the action --list:

 # portpkg --list
 (...)
 xap/mplayer-1.0pre5-i486-4tom
 xap/ogle-0.9.2-i486-2tom
 xap/ogle_gui-0.9.2-i486-1tom
 xap/pyne-1.0.2-i486-1tom
 xap/redhat-artwork-0.98-i486-3tom
 xap/straw-0.22.1-i486-4tom
 xap/tagtool-0.10-i486-3tom
 xap/video-dvdrip-0.51.1-i486-1tom
 xap/xdaf-A.01.11.01-i486-1tom
 xap/xmbmon-203-i486-1tom
 xap/xvid4conf-1.12-i486-1tom
 xap/zinf-2.2.5-i486-2tom

  Viewing information of ports

   Get detailed information about certain ports with --info:

 # portpkg --info dunnodiz

 PORT NAME:  dunnodiz-2.2.5-i486-2tom
 PORT SIZE (compressed):  1520 K
 PORT LOCATION:  /usr/ports/xap/dunnodiz/SlackBuild
 PORT REQUIREMENTS:  alsa-lib atk audiofile cxxlibs esound expat gdbm
    glib2 glibc gtk+2 id3lib libmusicbrainz libogg libvorbis ncurses
    pango x11 x11-devel zlib
 PORT SOURCES:  http://dl.sourceforge.net/dunnodiz/dunnodiz-2.2.5.tar.gz
 PORT DESCRIPTION:
 dunnodiz: dunnodiz (a package)
 dunnodiz:
 dunnodiz: dunnodiz doesn't know anything about itself. This can be realy
 dunnodiz: annoying since you don't know either anything about it. Strange.
 dunnodiz:

  Finding ports

   Find ports by keywords:

 # portpkg --find gui


  Listing outdated packages

   List all installed packages, that have a newer version in the ports
   collection:

 # porpkg --diff

 PORT NAME:                 AVAILABLE:              INSTALLED:
 gnome/gparted              0.0.6-i486-2tom         0.0.6-i486-1tom
 l/bluecurve                1.0-i486-11tom          1.0-i486-10tom
 gnome/epiphany             1.4.5-i486-1tom         1.4.4-i486-1tom

  Upgrading all outdated packages

   Upgrading is not always recommended, although it just balances what --diff
   lists. You should do this first with the option --dry-run:

 # portpkg --upgrade

  The tool Checkpkg

   Checkpkg is a menu controlled programme (similiar to pkgtool) to keep
   track of installed and available ports.

   (For now see Screenshots.)

   --------------------------------------------------------------------------

Writing ports

   First of all: Writing new ports can be quite easy, but can also become
   hard work and implies at least the possibility to shred your system! The
   procedure described here, is subject to certain conditions (one script
   just writes another script, and that could fail). So instead of just using
   portpkg, writing ports is more difficult and you should now what you are
   doing, this is at your own risk!

  Preparing

   For your own ports, you should use the subdirectory local/ for two
   reasons: These ports will be listed preferred, that means that your ports
   overlay other ports. All other directories will be overwritten by a sync
   with the official tree.

    Maintainer mode

   If you are maintaining ports, portpkg will fall automatically into a
   maintainer mode after the compilation process to make a few extra checks
   to assure your ports have been built correct. To have portpkg identify
   your ports you must have a tag specified (please have a look at
   /usr/ports/AUTHORS to see, what tags are already in use). Furthermore, if
   you plan to contribute your ports and make them puplic, we need your real
   name and mail address to contact you. These values will be written to the
   file /etc/portpkg/local.conf, which looks something like this:

 MY_TAG="me"
 MY_EMAIL="myself@here.org"
 MY_REALNAME="I. M. Weasel"

   Your tag has to be added (and will be added by Autoport automatically) to
   the revision number of your ports and therefore it has to be written in
   every SlackBuild (BUILD=1me).

    Classifying ports

   Every package/port identifier (short: the package) is a composition of at
   least 4 segments divided by -. Count from the tail (by leaving out .tgz):
   the revision (or build), the architecture (or noarch for architecture
   independend ports), the version and anything remaining is the name:

 this-is-a-package-1.0-noarch-1.tgz
 |                 |   |      |
 name              ver.arch.  revision

   Example
           On naming a new port it is best to come from the source package:
           http://download.sourceforge.net/mjpeg/mjpegtools-1.6.2.tar.gz.
           Here the name is mjpegtools, the version is 1.6.2, the
           architecture would be i486 an a x86 machine. So our port will be
           called mjpegtools-1.6.2-i486-1me.tgz, because it is our first try.
           Now, we make a directory called mjpegtools in our group (which is
           here ap/) where all the scripts can be written for this port.

   Why is that so important? -- Ports can be tracked as requirements later by
   other ports. To avoid cluttering we should follow a naming scheme.

   Notes
           * Versions (and architectures, revisions) cannot have a - inside.
           * Names should not have capitals.

  Ports and their parts

   A ports is made up of different files (most important the SlackBuild) and
   its path, where the critical part is only the last two parent directories,
   which describe the port's group and name:

 /usr/ports/local/kde-stuff/audio/l/artsd/SlackBuild
 \________/                      /  \___/ \________/
     |                          /     |       |
 ports tree                group    name  contains version,
                                          arch and release

    SlackBuild

   -- "Why does my package have such a fantastic compression ratio?"

   The file SlackBuild (and also any file according to name.SlackBuild) on
   its own determines the layout of the resulting package! It is a
   Bash-script and is executed when portpkg builds a binary package for
   installation. Generally, SlackBuilds need to be specially adjusted to a
   source package. It is recommended to use Autoport to write new ports.

   Please follow the basic filesystem layout in Slackware:

   +----------------------+
   |Configuration|/etc    |
   |-------------+--------|
   |Variable data|/var/lib|
   |-------------+--------|
   |Prefix       |/usr    |
   |-------------+--------|
   |Documentation|/usr/doc|
   |-------------+--------|
   |Manpages     |/usr/man|
   +----------------------+

   The Filesystem Hierarchy Standard, which should be followed in general,
   makes exceptions only for very few programmes, that are essential for
   booting the system (prefix /) or for big and closed software packages
   (prefix /opt/name). Note, that the prefix /usr/local, which is normally
   the default prefix for any source code, should never be used for packages,
   but only for installations by hands! The same is in the other way around.

   Make ports portable

   Ports should be portable for architectures other than x86 (particularly
   s390 and x86_64), so if the code will be architecture-dependend, ARCH must
   be set to {ARCH:-i486}, which means, that i486 is the default
   architecture, otherwise it has to be noarch. Granted, SlackBuilds aren't
   predestinated for porting to other platforms, but they can also be made
   suitable for processor optimisations via CFLAGS. To satisfy
   CFLAGS-customisation, a SlackBuild must have these lines or appropriate
   instructions (supposed it makes use of ./configure):

 if [ "$ARCH" = "i386" ]; then
   SLKCFLAGS="-O2 -march=i386 -mcpu=i686"
 elif [ "$ARCH" = "i486" ]; then
   SLKCFLAGS="-O2 -march=i486 -mcpu=i686"
 elif [ "$ARCH" = "s390" ]; then
   SLKCFLAGS="-O2"
 elif [ "$ARCH" = "x86_64" ]; then
   SLKCFLAGS="-O2"
 fi

   It is important that default values will be set only for i386, i486, s390
   and x86_64. For any other ARCH (especially effected by a general else
   instruction), there should be no default value! Later, SLKCFLAGS must be
   handed over to ./configure via

 CFLAGS="$SLKCFLAGS" \
 ./configure \
 (...)

   Notes
           * Executable files in bin/ and sbin/ and their directories have to
             be owned by root.bin.
           * Always have a look at footprint to find misfits earlier!
           * If something doesn't need to be patched, please don't patch it!

    Doinst.sh

   The file doinst.sh is also a Bash-script that is executed on every
   installation of a binary package, right after unpacking the files. It is
   located in install/ in the root of the binary package and in
   /var/log/scripts/ but with the package's file name after its installation.

   Slackware's package system for example stores symbolic links in doinst.sh
   (don't bother this, they will be removed from the package and written to
   doinst.sh automatically by makepkg). SlackBuilds should be configured to
   write initialisation scripts for GConf schemas and Scrollkeeper documents
   (which is detected by Autoport), but you can also write down commands that
   are not usual but important for the installation of a package (e.g.
   gstreamer needs gst-register).

   It is also common use in Slackware to rename configuration scripts to
   file.new and install them with config(), which in turn renames it to its
   final name only if it doesn't overwrite an already existing one. So, the
   administrator can (and should) later check whether he wants to have the
   new file or keep his old:

 config() {
   NEW="$1"
   OLD="`dirname $NEW`/`basename $NEW .new`"
   # If there's no config file by that name, mv it over:
   if [ ! -r $OLD ]; then
     mv $NEW $OLD
   elif [ "`cat $OLD | md5sum`" = "`cat $NEW | md5sum`" ]; then # toss the redundant copy
     rm $NEW
   fi
   # Otherwise, we leave the .new copy for the admin to consider...
 }
 config etc/only_if_not_yet_here.new

   Note
           * Use relative paths rather than absolute paths here, since
             packages can be installed on different roots (not with Portpkg,
             but with installpkg)!

    Slack-desc

   Example

 shortname: Projectname (short desciption)
 shortname:
 shortname: Here can be a longer and deeper going description of the package.
 shortname: Note that you do not go behind 75 characters and 11 lines.
 shortname:

    Sources^1

   In order to reduce bandwidth for the Portpkg Project and for you, source
   package URLs should be written in sources. This file is special to
   Portpkg. To make version updates later easier, use the string $VERSION
   where the version number of the package is placed. You can also use $NAME.
   Portpkg will download these files into the port directory before running
   the SlackBuild, then they will be stored in /usr/src/dist. If a file
   should be saved with a different name than its URL calls it, use a %
   before its URL.

   Example

 http://www.host.org/downloads/package-$VERSION.tar.gz
 http://www.host.org/downloads/package-addon-$VERSION.tar.gz
 http://www.host.org/downloads/download.php?file=data%package-data

   Note
           * Please list only primary download sites here and use .tar.bz2
             archives rather than .tar.gz archives if possible in terms of
             reducing bandwidth.

    Slot-in^1

   The normal policy is to "install" packages with upgradepkg. That means, if
   another version of the port is already installed, the new one replaces the
   old one. E.g.: mplayer-1.0pre4-i486-1tom is already installed,
   mplayer-1.0pre5-i486-1tom is available in the ports, so the command
   portpkg mplayer removes the first one to install the last one.

   If this behaviour is not intended, and you want Portpkg not to remove the
   older package (this is mostly for packages as kernels or kernel-modules),
   there's the possibility to mark a port as a "slot-in":

 # touch slot-in

    Pseudo^1

   The empty file pseudo marks a "pseudo port", as you can see in the ports
   tree Pp-sync-bin builds. These pseudo ports list binary Slackware packages
   as their souce packages, therefore the presents of slot-in instructs
   Portpkg not to store them in /usr/src/dist when the installation is done.

   Nore: This is more for the sake of completeness, it is subject to be
   removed if Portpkg implements a way of interacting with Slackware
   repository tools.

    Requires^1

   The file requires contains dependend packages and ports that are tracked
   by Portpkg in the maintainer mode after compiling. These required packages
   and ports are obligatory for compiling this port! While this file is
   written when running in maintainer mode, in normal mode Portpkg checks, if
   these requirements are met. You shouldn't write this file by hand
   normally, but there may be dependencies that cannot be found
   automatically, then add them. Portpkg won't remove any item you write to
   requires.

    Optional^2

   The file optional contains dependencies, that can occur, but needn't to.
   Since requires is obligatory at build time and written automatically, this
   file is a exclude-list for requires. Entries of this file won't be written
   to it. How to use it: You may have found out, that a certain port has
   dependencies listed in requires, that are indeed optional. Add this
   package name to optional and remove it from requires. After all, this file
   is an advisory information for non-maintainers.

    No-fakeroot^1

   To make the whole build process more secure Portpkg changes to user nobody
   while running the SlackBuild and simulates being root without actually
   having root permissions, but being able to make a package with root-owned
   files. This is done by fakeroot.

   However, there are few ports that cannot be build with fakeroot, the
   Maintainer must mark them with an empty file no-fakeroot.

    Ignore^1, 2

   The file ignore.

    Miscellaneous

   Several files are available in maintainer mode to indicate the result of
   the package making process:

   +------------------------------------------------------------------------+
   |PORT_IS_BROKEN^1|Marks a failure of the last compilation                |
   |----------------+-------------------------------------------------------|
   |arbitrary^1     |List of dependencies that couldn't be tracked          |
   |                |automatically and should be checked                    |
   |----------------+-------------------------------------------------------|
   |buildlog^1      |Detailed log of the SlackBuild-output                  |
   |----------------+-------------------------------------------------------|
   |footprint^1     |File list of the package content                       |
   +------------------------------------------------------------------------+

  Configuration of Portpkg

   The configuration files are located in /usr/ports. Generally, there are
   configuration files that are distributed (mirrors, ignore and exclude),
   don't edit them. Use a host specific file instead (mirrors.local,
   ignore.local and exclude.local) that won't be overwritten.

    Local.conf

   You can customise portpkg with several variables in local.conf:

   +------------------------------------------------------------------------+
   |MY_TAG=tag             |Your personal tag                               |
   |-----------------------+------------------------------------------------|
   |MY_EMAIL=email         |Your mail address for contacting you if you plan|
   |                       |to contribute                                   |
   |-----------------------+------------------------------------------------|
   |MY_REALNAME="real name"|Your real name for contacting you if you plan to|
   |                       |contribute                                      |
   |-----------------------+------------------------------------------------|
   |MAINTAIN_ALL=true      |Let Portpkg always work in maintainer mode      |
   |-----------------------+------------------------------------------------|
   |DIST_VER=version       |The target Slackware version if you use         |
   |                       |Pp-sync-bin or Pp-sync-src                      |
   |-----------------------+------------------------------------------------|
   |BIN_PRT_DIR=path       |The path of your binary pseudo ports tree       |
   |                       |(/usr/ports/z/bin is recommended)               |
   |-----------------------+------------------------------------------------|
   |VERBOSE=true           |Let Portpkg always work in verbose mode         |
   |                       |(--verbose)                                     |
   |-----------------------+------------------------------------------------|
   |NO_REQS=true           |Let Portpkg always work without requirements    |
   |                       |resolving (--noreqs)                            |
   |-----------------------+------------------------------------------------|
   |LAZY_CHECKS=true       |Don't upgrade dependencies (--lazy)             |
   |-----------------------+------------------------------------------------|
   |ARCH=arch              |Architecture of the target platform             |
   |-----------------------+------------------------------------------------|
   |CFLAGS=cflags          |Compiler optimisations flags                    |
   +------------------------------------------------------------------------+

    Mirrors and mirrors.local

   While primary download URLs should be listed in sources, in mirrors
   there're global mirror sites for common source package locations. If you
   want to have some special mirror sites for your own, write them into
   mirrors.local.

    Ignore and ignore.local

   Normally, dependencies are tracked automatically by Portpkg in the
   maintainer mode after compiling and written to the file requires. If you
   find any dependencies in requires that shouldn't be tracked, write them
   into ignore.local:

     o Packages or ports, that are optional: mostly newer versions of
       libraries included in other Slackware packages (e.g. freetype,
       fontconfig etc. are already included in Slackware's x11 package)
     o Packages or ports being useless to track, because they're already and
       for sure installed (e.g. aaa_elflibs)

   A global list of common ignored dependencies is in ignore.

    Exclude and exclude.local

   Ports you don't want to be built (also as a dependency or as an upgrade),
   should be written to exclude.local. A common set of ports that should be
   excluded is in the global file exclude. These ports can be listed as
   normal via portpkg --list, but won't be available, unless it is your
   intention: specify them via portpkg group/name!

  The tool Autoport

   -- "Packages as mom does"

   The package Portpkg contains a script called Autoport, an interactive
   step-by-step script that will assist you to prepare ports for very common
   installation methods. A source file URL given, Autoport tries to guess
   default answers (encluded in [ and ]) that should be the right choice, so
   just press RETURN to accept them or enter a different value.

 # autoport http://dl.sourceforge.net/lame/lame-3.96.tar.gz

 Autoport -- An Automatic SlackBuild Generator
 Copyright (C) 2004 Thomas Pfaff <topf at users dot berlios dot de>
 Autoport comes with ABSOLUTELY NO WARRANTY. This is free software, and you
 are welcome to redistribute it under certain conditions.

 Autoport is quite experimental, but seems to work better than 'addport'. The
 difference is, autoport will download the source code package you have to
 enter and searches for different keywords to adjust a suitable SlackBuild
 script.

 If autoport doesn't work as expected, please mail at:
 <topf at users dot berlios dot de>

 * First step: Give meta information. Continue? (ctrl-c to quit)

 Source file [http://dl.sourceforge.net/lame/lame-3.96.tar.gz]:

 Group [local]:

 Name [lame]:

 Version [3.96]:

 Arch [i486]:

 Build [1mich]:

 Description (1-liner) [lame]:

   Enter lame (create mp3 audio files)!

 Description (details) (Write or paste and finish with a single '.')
 []

   Enter:

   LAME is an LGPL MP3 encoder. The Open source development model allowed to
   improve its quality and speed since 1999. It is now an highly evolved MP3
   encoder, with quality and speed able to rival state of the art commercial
   encoders.

   .

   Don't forget the dot at the end to finish!

 Creating now a port with this information:

 PORT NAME:  lame-3.96-i486-2mich
 PORT LOCATION:  /usr/ports/local/lame/SlackBuild
 PORT SOURCE:  http://dl.sourceforge.net/lame/lame-$VERSION.tar.gz
 PORT DESCRIPTION:
 lame: lame (create mp3 audio files)
 lame:
 lame: LAME is an LGPL MP3 encoder. The Open source development model
 lame: allowed to improve its quality and speed since 1999. It is now an
 lame: highly evolved MP3 encoder, with quality and speed able to rival
 lame: state of the art commercial encoders.
 lame:

 * Last chance to quit. Port scripts will now be written.
 Next step: Downloading and checking source code. Continue? (ctrl-c to quit)

   Press RETURN!

 Downloading source file:
 (...)

 Alright, since we have the code, I'll have a look into it:
   --> Checking format... .tar.gz
   --> Checking source-prefix... lame-3.96/
   --> Checking docs... COPYING ChangeLog HACKING INSTALL INSTALL.configure LICENSE README README.WINGTK TODO.
   --> Checking for setup.py... no
   --> Checking for Makefile.PL... no
   --> Checking for configure... yes
   --> Checking for DESTDIR... yes
   --> Checking for CFLAGS... yes
   --> Checking for CXXFLAGS... yes
   --> Checking for gconf schemas... no
   --> Checking for scrollkeeper... no

 We're done. Port written in /usr/ports/local/lame.

   You can now build it via Portpkg:

 # portpkg local/lame

 Building lame-3.96-i486-1mich:
 WARNING: Maintainer mode: Port scripts will be modified!
   --> lame-3.96.tar.gz found in /usr/src/dist/
   --> Executing /usr/ports/local/lame/SlackBuild
   --> Going maintainer mode
   --> Finding requirements
   --> Moving lame-3.96-i486-1mich to /usr/obj/pkg/local/

 Installing lame to 3.96-i486-1mich...
 PACKAGE DESCRIPTION:
 lame: lame (create mp3 audio files)
 lame:
 lame: LAME is an LGPL MP3 encoder. The Open source development model
 lame: allowed to improve its quality and speed since 1999. It is now an
 lame: highly evolved MP3 encoder, with quality and speed able to rival
 lame: state of the art commercial encoders.
 lame:
 Executing install script for lame...

   We hope you plan to contribute your ports to this project, it is a simple
   task!

   --------------------------------------------------------------------------

Contribute to the Portpkg Project

   Contributing your ports to the Portpkg Project is very easy: Please
   consider a reasonable summary of your export (did you patch a certain bug,
   did you upgraded the version):

 # portpkg --export "Upgraded to version 1.2." ap/package

 Exporting to cvs.portpkg.berlios.de:
   --> Uploading ap/package-1.2-i486-1tom

   Ports that are submitted via --export will be picked up by a cron job on
   portpkg.berlios.de that merges them into open/.

   --------------------------------------------------------------------------

Backgrounds

   This section will address some theoretical hows and whys of the
   administration tool Portpkg and its inner work and development. It is
   concrete incarnation of the term work in progress.

  A small introduction into the ports tree

   Portpkg uses CVS to collect and distribute the ports scripts. To sync with
   the official ports tree do:

 # cvs -qz9 -d:pserver:anonymous@cvs.berlios.de:/cvsroot/portpkg co ports

   You have now a local copy in ports/. This ports tree is divided in groups
   and groups are subdivided in ports. For each one there is a directory. To
   compile e.g. enlightenment which is in group xap/, go to the directory
   xap/enlightenment/, download the source files you need, they are listet in
   a file called sources, but check the version, that is declared in the file
   SlackBuild:

 # cd ports/xap/enlightenment
 # grep VERSION= SlackBuild
 VERSION=0.16.7.1
 # cat sources
 http://dl.sourceforge.net/enlightenment/enlightenment-$VERSION.tar.gz
 # wget http://dl.sourceforge.net/enlightenment/enlightenment-0.16.7.1.tar.gz
 (...)

   ... and start the script:

 # sh ./SlackBuild

   This will compile the sources and prepare a package for you. Some ports
   will need other ports to be build before they can build, you should check,
   if all packages in requires are installed, before you start:

 # cat requires
 alsa-lib
 audiofile
 esound
 glibc
 imlib
 libtool
 x11
 x11-devel
 zlib

   Each of them are either ports in this tree or official Slackware packages.
   Remind also, that each of them can have their own requires file!

  Terminology

   Port
           A set of scripts or files that describe how to make a certain
           binary package.

   Group, or series
           Directories that seperate ports and packages in topical pools.

   Package, or binary package
           A file that contains all files that belong together, prepared for
           a certain OS and architecture, mostly machine code and ready to
           run. In Slackware, ending always in .tgz.

   Source package
           A file that contains all files that belong together, mostly plain
           text, valid for several OSes and architectures, and have to be
           prepared for installation first. Ending in .tar.gz, .tar.bz2, .tgz
           or .src.rpm etc.

   SlackBuild
           A Bash-script that is executed to build a package.

   Ports tree
           Hierarchy of port scripts.

   Package name, or short name
           In Slackware, the first of the 4 segments in a package descriptor,
           delimited by -. E.g.: mplayer is the package name of the package
           mplayer-1.0pre5-i486-1tom.

   Build, or release
           In Slackware, the last of the 4 segments in a package descriptor,
           delimited by -. E.g.: 1tom is the build of the package
           mplayer-1.0pre5-i486-1tom.

  Theory

   -- "What is exactly the difference between the ports in Portpkg and the
   "ports" in Slackware?"

   Slackware doesn't call that ports! It's just the source code of Slackware.

   The most obvious difference seems to be the file source: While Slackware
   stores every source package in the same directory, Portpkg just gives a
   list of URLs, where to get them. The effect is the same, because they have
   to be downloaded anyway.

   Moreover the SlackBuilds in Portpkg are a little more consequential in
   declarations (each SlackBuild has to have the lines VERSION=, ARCH= and
   BUILD= and its values in plain text) and more consequential in
   implementation (each port has one SlackBuild, each SlackBuild makes one
   binary package). Have a look at the .build-scripts, the X11-SlackBuild and
   the KDE-scipts to see what I mean. This behaviour may change in future to
   make Portpkg more compatible with the Slackware sources.

   The concept of Portpkg's ports tree is to provide a functionality without
   Portpkg at all, although it's not that easy to use:

 # cd /usr/ports/ap/dbus
 # cat sources | sed "s#\$VERSION#1.2.3#" | wget -i -
 (...)
 # sh ./SlackBuild
 (...)
 # installpkg /tmp/dbus-*.tgz
 (...)

   Portpkg generates a list of available ports on-the-fly. That means a
   VERSION-change in one SlackBuild of a port is immediatly translated.

   Usage and output of Portpkg is mostly analogue to the usage and output of
   Slackware's installpkg. Again, layout of the ports tree is analogue to the
   layout of Slackware's source/ directory.

  File system

   -- "What directories are used for Portpkg and its scripts?"

   +-----------------------------------------+
   |/usr/ports    |Ports tree copy           |
   |--------------+--------------------------|
   |/usr/obj/pkg  |Stored binary packages    |
   |--------------+--------------------------|
   |/usr/src/dist |Downloaded source packages|
   |--------------+--------------------------|
   |/usr/src/cvs^2|CVS-repositories          |
   +-----------------------------------------+

  Ports tree

   This part is sort of phenomenology of the packages tree in Slackware.
   Let's start with the most common groups:

   +---------------------------------------------------+
   |ap/   |Applications, console based                 |
   |------+--------------------------------------------|
   |d/    |Development tools                           |
   |------+--------------------------------------------|
   |gnome/|Applications, that require the GNOME-desktop|
   |------+--------------------------------------------|
   |kde/  |Applications, that require the KDE          |
   |------+--------------------------------------------|
   |l/    |Libraries                                   |
   |------+--------------------------------------------|
   |n/    |Network servers and clients                 |
   |------+--------------------------------------------|
   |xap/  |X-applications                              |
   +---------------------------------------------------+

   These are special groups, that should better only be used for the
   Slackware distribution:

   +------------------------------------------------------------------------+
   |  |Base packages, that have to be installed first. Portpkg sorts the    |
   |a/|ports list, therefore a/ is listed before other groups, and that's   |
   |  |why pp-sync-dist uses group z/, to make sure, they are used as last  |
   |  |resort.                                                              |
   |--+---------------------------------------------------------------------|
   |x/|X-server and its fonts and drivers, sort of "a/" group of            |
   |  |X-applications                                                       |
   +------------------------------------------------------------------------+

   These groups have special meanings in Portpkg and are normally marked to
   be excluded:

   +------------------------------------------------------------------------+
   |pasture/|Packages for compatibility reasons, packages a                 |
   |        |release-based-system needs, but not a current-based-system     |
   |--------+---------------------------------------------------------------|
   |testing/|Packages for testing                                           |
   |--------+---------------------------------------------------------------|
   |open/   |The open group: a temporary place (special to Portpkg) for     |
   |        |ports that are uploaded by users with the web interface.       |
   |--------+---------------------------------------------------------------|
   |local/  |A subdirectory (not a group!) that is always preferred before  |
   |        |all others                                                     |
   |--------+---------------------------------------------------------------|
   |z/      |A subdirectory (not a group!) that contains ports to be used as|
   |        |last resort (e.g. by Pp-sync-bin and Pp-sync-dist)             |
   +------------------------------------------------------------------------+

   Notes
           * Smart slackers will yell when reading pasture/ and testing/
             being a group or series. In fact these directories are located
             one level above the package tree. To be discussed :)
           * It is possible to have a port in
             /usr/ports/local/newstuff/l/wxgtk/SlackBuild, which will be
             interpreted as l/wxgtk and not as a port of group local/!

  The SlackBuild-blackbox

   To work with Portpkg in a lower level, a SlackBuild must meet following
   conditions:

     o It must be named SlackBuild or *.SlackBuild
     o It must be a shell script (not necessary to have an executable bit
       set)
     o It must run without parameters
     o It must have all its relating files in the same directory
     o It must not write to anything but /tmp
     o It must have the lines VERSION=version, ARCH=arch and BUILD=build
       without spaces or tabs or variables, beside the form ${ARCH:-i486}
     o It must name its package name-$VERSION-$ARCH-$BUILD.tgz, while name is
       the directory it's located in
     o It must leave its package in /tmp

     o It may use a custom $ARCH (see above)
     o It may remove the source tree invoked by parameter --cleanup

   What SlackBuild do definitely not work with Portpkg?

     o If it builds no or more than one .tgz-package (meta-SlackBuilds)

  Dealing with ports

   Portpkg makes using port scripts easier by providing several functions for
   users and maintainers also. Maintainer mode is automatically initiated
   when the value of MY_TAG (in /etc/portpkg/local.conf) matches the
   build-tag of the port being built.

     o Downloads required source packages while resuming aborted downloads
     o Checks and completes (in maintainer mode) a list of required packages
       to build a port
     o Collects source packages and binary packages in seperate directories
     o Assists maintainers to check if the resulting package is built correct

   --------------------------------------------------------------------------

   Notes
           ^1 This file is specific to Portpkg, ^2 Planning

   --------------------------------------------------------------------------


References

   Visible links
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#1
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#2
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#2-1
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#2-2
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#2-3
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#2-4
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#2-5
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#2-6
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#2-7
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-1
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-1-1
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-1-2
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-1
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-2
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-3
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-4
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-5
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-6
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-7
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-8
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-9
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-10
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-2-11
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-3
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-3-1
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-3-2
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-3-3
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-3-4
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#3-4
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#4
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#5
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#5-1
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#5-2
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#5-3
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#5-4
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#5-5
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#5-6
   . file:///usr/ports/d/portpkg/PortpkgGuide.html#5-7
   . http://developer.berlios.de/project/showfiles.php?group_id=2486
   . file:///usr/ports/d/portpkg/doc.php?page=Screenshots
   . http://www.pathname.com/fhs/pub/fhs-2.3.html
   . file:///usr/ports/d/portpkg/doc.php?page=edit/PortpkgGuide
   . file:///usr/ports/d/portpkg/doc.php?page=links/PortpkgGuide
   . file:///usr/ports/d/portpkg/doc.php?page=info/PortpkgGuide
